/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "serialized_result_set_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kTResultSetLayoutValues[] = {
  TResultSetLayout::GroupByPerfectHash,
  TResultSetLayout::GroupByBaselineHash,
  TResultSetLayout::Projection,
  TResultSetLayout::NonGroupedAggregate
};
const char* _kTResultSetLayoutNames[] = {
  "GroupByPerfectHash",
  "GroupByBaselineHash",
  "Projection",
  "NonGroupedAggregate"
};
const std::map<int, const char*> _TResultSetLayout_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTResultSetLayoutValues, _kTResultSetLayoutNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TResultSetLayout::type& val) {
  std::map<int, const char*>::const_iterator it = _TResultSetLayout_VALUES_TO_NAMES.find(val);
  if (it != _TResultSetLayout_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTCountDistinctImplTypeValues[] = {
  TCountDistinctImplType::Invalid,
  TCountDistinctImplType::Bitmap,
  TCountDistinctImplType::StdSet
};
const char* _kTCountDistinctImplTypeNames[] = {
  "Invalid",
  "Bitmap",
  "StdSet"
};
const std::map<int, const char*> _TCountDistinctImplType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTCountDistinctImplTypeValues, _kTCountDistinctImplTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TCountDistinctImplType::type& val) {
  std::map<int, const char*>::const_iterator it = _TCountDistinctImplType_VALUES_TO_NAMES.find(val);
  if (it != _TCountDistinctImplType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTAggKindValues[] = {
  TAggKind::AVG,
  TAggKind::MIN,
  TAggKind::MAX,
  TAggKind::SUM,
  TAggKind::COUNT,
  TAggKind::APPROX_COUNT_DISTINCT,
  TAggKind::SAMPLE
};
const char* _kTAggKindNames[] = {
  "AVG",
  "MIN",
  "MAX",
  "SUM",
  "COUNT",
  "APPROX_COUNT_DISTINCT",
  "SAMPLE"
};
const std::map<int, const char*> _TAggKind_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTAggKindValues, _kTAggKindNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TAggKind::type& val) {
  std::map<int, const char*>::const_iterator it = _TAggKind_VALUES_TO_NAMES.find(val);
  if (it != _TAggKind_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


TSlotSize::~TSlotSize() throw() {
}


void TSlotSize::__set_padded(const int16_t val) {
  this->padded = val;
}

void TSlotSize::__set_logical(const int16_t val) {
  this->logical = val;
}
std::ostream& operator<<(std::ostream& out, const TSlotSize& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSlotSize::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->padded);
          this->__isset.padded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->logical);
          this->__isset.logical = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TSlotSize::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSlotSize");

  xfer += oprot->writeFieldBegin("padded", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->padded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("logical", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->logical);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSlotSize &a, TSlotSize &b) {
  using ::std::swap;
  swap(a.padded, b.padded);
  swap(a.logical, b.logical);
  swap(a.__isset, b.__isset);
}

TSlotSize::TSlotSize(const TSlotSize& other0) {
  padded = other0.padded;
  logical = other0.logical;
  __isset = other0.__isset;
}
TSlotSize& TSlotSize::operator=(const TSlotSize& other1) {
  padded = other1.padded;
  logical = other1.logical;
  __isset = other1.__isset;
  return *this;
}
void TSlotSize::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSlotSize(";
  out << "padded=" << to_string(padded);
  out << ", " << "logical=" << to_string(logical);
  out << ")";
}


TColSlotContext::~TColSlotContext() throw() {
}


void TColSlotContext::__set_slot_sizes(const std::vector<TSlotSize> & val) {
  this->slot_sizes = val;
}

void TColSlotContext::__set_col_to_slot_map(const std::vector<std::vector<int32_t> > & val) {
  this->col_to_slot_map = val;
}
std::ostream& operator<<(std::ostream& out, const TColSlotContext& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColSlotContext::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->slot_sizes.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->slot_sizes.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += this->slot_sizes[_i6].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.slot_sizes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->col_to_slot_map.clear();
            uint32_t _size7;
            ::apache::thrift::protocol::TType _etype10;
            xfer += iprot->readListBegin(_etype10, _size7);
            this->col_to_slot_map.resize(_size7);
            uint32_t _i11;
            for (_i11 = 0; _i11 < _size7; ++_i11)
            {
              {
                this->col_to_slot_map[_i11].clear();
                uint32_t _size12;
                ::apache::thrift::protocol::TType _etype15;
                xfer += iprot->readListBegin(_etype15, _size12);
                this->col_to_slot_map[_i11].resize(_size12);
                uint32_t _i16;
                for (_i16 = 0; _i16 < _size12; ++_i16)
                {
                  xfer += iprot->readI32(this->col_to_slot_map[_i11][_i16]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.col_to_slot_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColSlotContext::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColSlotContext");

  xfer += oprot->writeFieldBegin("slot_sizes", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->slot_sizes.size()));
    std::vector<TSlotSize> ::const_iterator _iter17;
    for (_iter17 = this->slot_sizes.begin(); _iter17 != this->slot_sizes.end(); ++_iter17)
    {
      xfer += (*_iter17).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_to_slot_map", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->col_to_slot_map.size()));
    std::vector<std::vector<int32_t> > ::const_iterator _iter18;
    for (_iter18 = this->col_to_slot_map.begin(); _iter18 != this->col_to_slot_map.end(); ++_iter18)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter18).size()));
        std::vector<int32_t> ::const_iterator _iter19;
        for (_iter19 = (*_iter18).begin(); _iter19 != (*_iter18).end(); ++_iter19)
        {
          xfer += oprot->writeI32((*_iter19));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColSlotContext &a, TColSlotContext &b) {
  using ::std::swap;
  swap(a.slot_sizes, b.slot_sizes);
  swap(a.col_to_slot_map, b.col_to_slot_map);
  swap(a.__isset, b.__isset);
}

TColSlotContext::TColSlotContext(const TColSlotContext& other20) {
  slot_sizes = other20.slot_sizes;
  col_to_slot_map = other20.col_to_slot_map;
  __isset = other20.__isset;
}
TColSlotContext& TColSlotContext::operator=(const TColSlotContext& other21) {
  slot_sizes = other21.slot_sizes;
  col_to_slot_map = other21.col_to_slot_map;
  __isset = other21.__isset;
  return *this;
}
void TColSlotContext::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColSlotContext(";
  out << "slot_sizes=" << to_string(slot_sizes);
  out << ", " << "col_to_slot_map=" << to_string(col_to_slot_map);
  out << ")";
}


TCountDistinctDescriptor::~TCountDistinctDescriptor() throw() {
}


void TCountDistinctDescriptor::__set_impl_type(const TCountDistinctImplType::type val) {
  this->impl_type = val;
}

void TCountDistinctDescriptor::__set_min_val(const int64_t val) {
  this->min_val = val;
}

void TCountDistinctDescriptor::__set_bitmap_sz_bits(const int64_t val) {
  this->bitmap_sz_bits = val;
}

void TCountDistinctDescriptor::__set_approximate(const bool val) {
  this->approximate = val;
}

void TCountDistinctDescriptor::__set_device_type(const  ::TDeviceType::type val) {
  this->device_type = val;
}

void TCountDistinctDescriptor::__set_sub_bitmap_count(const int64_t val) {
  this->sub_bitmap_count = val;
}
std::ostream& operator<<(std::ostream& out, const TCountDistinctDescriptor& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCountDistinctDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast22;
          xfer += iprot->readI32(ecast22);
          this->impl_type = (TCountDistinctImplType::type)ecast22;
          this->__isset.impl_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->min_val);
          this->__isset.min_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bitmap_sz_bits);
          this->__isset.bitmap_sz_bits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->approximate);
          this->__isset.approximate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast23;
          xfer += iprot->readI32(ecast23);
          this->device_type = ( ::TDeviceType::type)ecast23;
          this->__isset.device_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sub_bitmap_count);
          this->__isset.sub_bitmap_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCountDistinctDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCountDistinctDescriptor");

  xfer += oprot->writeFieldBegin("impl_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->impl_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min_val", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->min_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bitmap_sz_bits", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->bitmap_sz_bits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("approximate", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->approximate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("device_type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->device_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sub_bitmap_count", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->sub_bitmap_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCountDistinctDescriptor &a, TCountDistinctDescriptor &b) {
  using ::std::swap;
  swap(a.impl_type, b.impl_type);
  swap(a.min_val, b.min_val);
  swap(a.bitmap_sz_bits, b.bitmap_sz_bits);
  swap(a.approximate, b.approximate);
  swap(a.device_type, b.device_type);
  swap(a.sub_bitmap_count, b.sub_bitmap_count);
  swap(a.__isset, b.__isset);
}

TCountDistinctDescriptor::TCountDistinctDescriptor(const TCountDistinctDescriptor& other24) {
  impl_type = other24.impl_type;
  min_val = other24.min_val;
  bitmap_sz_bits = other24.bitmap_sz_bits;
  approximate = other24.approximate;
  device_type = other24.device_type;
  sub_bitmap_count = other24.sub_bitmap_count;
  __isset = other24.__isset;
}
TCountDistinctDescriptor& TCountDistinctDescriptor::operator=(const TCountDistinctDescriptor& other25) {
  impl_type = other25.impl_type;
  min_val = other25.min_val;
  bitmap_sz_bits = other25.bitmap_sz_bits;
  approximate = other25.approximate;
  device_type = other25.device_type;
  sub_bitmap_count = other25.sub_bitmap_count;
  __isset = other25.__isset;
  return *this;
}
void TCountDistinctDescriptor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCountDistinctDescriptor(";
  out << "impl_type=" << to_string(impl_type);
  out << ", " << "min_val=" << to_string(min_val);
  out << ", " << "bitmap_sz_bits=" << to_string(bitmap_sz_bits);
  out << ", " << "approximate=" << to_string(approximate);
  out << ", " << "device_type=" << to_string(device_type);
  out << ", " << "sub_bitmap_count=" << to_string(sub_bitmap_count);
  out << ")";
}


TResultSetBufferDescriptor::~TResultSetBufferDescriptor() throw() {
}


void TResultSetBufferDescriptor::__set_layout(const TResultSetLayout::type val) {
  this->layout = val;
}

void TResultSetBufferDescriptor::__set_keyless(const bool val) {
  this->keyless = val;
}

void TResultSetBufferDescriptor::__set_entry_count(const int32_t val) {
  this->entry_count = val;
}

void TResultSetBufferDescriptor::__set_idx_target_as_key(const int32_t val) {
  this->idx_target_as_key = val;
}

void TResultSetBufferDescriptor::__set_min_val(const int64_t val) {
  this->min_val = val;
}

void TResultSetBufferDescriptor::__set_max_val(const int64_t val) {
  this->max_val = val;
}

void TResultSetBufferDescriptor::__set_bucket(const int64_t val) {
  this->bucket = val;
}

void TResultSetBufferDescriptor::__set_group_col_widths(const std::vector<int16_t> & val) {
  this->group_col_widths = val;
}

void TResultSetBufferDescriptor::__set_key_bytewidth(const int16_t val) {
  this->key_bytewidth = val;
}

void TResultSetBufferDescriptor::__set_col_slot_context(const TColSlotContext& val) {
  this->col_slot_context = val;
}

void TResultSetBufferDescriptor::__set_target_groupby_indices(const std::vector<int32_t> & val) {
  this->target_groupby_indices = val;
}

void TResultSetBufferDescriptor::__set_count_distinct_descriptors(const TCountDistinctDescriptors& val) {
  this->count_distinct_descriptors = val;
}

void TResultSetBufferDescriptor::__set_force_4byte_float(const bool val) {
  this->force_4byte_float = val;
}
std::ostream& operator<<(std::ostream& out, const TResultSetBufferDescriptor& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TResultSetBufferDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast26;
          xfer += iprot->readI32(ecast26);
          this->layout = (TResultSetLayout::type)ecast26;
          this->__isset.layout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->keyless);
          this->__isset.keyless = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->entry_count);
          this->__isset.entry_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->idx_target_as_key);
          this->__isset.idx_target_as_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->min_val);
          this->__isset.min_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_val);
          this->__isset.max_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bucket);
          this->__isset.bucket = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->group_col_widths.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->group_col_widths.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += iprot->readI16(this->group_col_widths[_i31]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.group_col_widths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->key_bytewidth);
          this->__isset.key_bytewidth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->col_slot_context.read(iprot);
          this->__isset.col_slot_context = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->target_groupby_indices.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->target_groupby_indices.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += iprot->readI32(this->target_groupby_indices[_i36]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.target_groupby_indices = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->count_distinct_descriptors.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->count_distinct_descriptors.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += this->count_distinct_descriptors[_i41].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.count_distinct_descriptors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->force_4byte_float);
          this->__isset.force_4byte_float = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TResultSetBufferDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TResultSetBufferDescriptor");

  xfer += oprot->writeFieldBegin("layout", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->layout);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("keyless", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->keyless);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entry_count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->entry_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("idx_target_as_key", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->idx_target_as_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min_val", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->min_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_val", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->max_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bucket", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->bucket);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("group_col_widths", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->group_col_widths.size()));
    std::vector<int16_t> ::const_iterator _iter42;
    for (_iter42 = this->group_col_widths.begin(); _iter42 != this->group_col_widths.end(); ++_iter42)
    {
      xfer += oprot->writeI16((*_iter42));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_bytewidth", ::apache::thrift::protocol::T_I16, 9);
  xfer += oprot->writeI16(this->key_bytewidth);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_slot_context", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->col_slot_context.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_groupby_indices", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->target_groupby_indices.size()));
    std::vector<int32_t> ::const_iterator _iter43;
    for (_iter43 = this->target_groupby_indices.begin(); _iter43 != this->target_groupby_indices.end(); ++_iter43)
    {
      xfer += oprot->writeI32((*_iter43));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count_distinct_descriptors", ::apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->count_distinct_descriptors.size()));
    std::vector<TCountDistinctDescriptor> ::const_iterator _iter44;
    for (_iter44 = this->count_distinct_descriptors.begin(); _iter44 != this->count_distinct_descriptors.end(); ++_iter44)
    {
      xfer += (*_iter44).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("force_4byte_float", ::apache::thrift::protocol::T_BOOL, 13);
  xfer += oprot->writeBool(this->force_4byte_float);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TResultSetBufferDescriptor &a, TResultSetBufferDescriptor &b) {
  using ::std::swap;
  swap(a.layout, b.layout);
  swap(a.keyless, b.keyless);
  swap(a.entry_count, b.entry_count);
  swap(a.idx_target_as_key, b.idx_target_as_key);
  swap(a.min_val, b.min_val);
  swap(a.max_val, b.max_val);
  swap(a.bucket, b.bucket);
  swap(a.group_col_widths, b.group_col_widths);
  swap(a.key_bytewidth, b.key_bytewidth);
  swap(a.col_slot_context, b.col_slot_context);
  swap(a.target_groupby_indices, b.target_groupby_indices);
  swap(a.count_distinct_descriptors, b.count_distinct_descriptors);
  swap(a.force_4byte_float, b.force_4byte_float);
  swap(a.__isset, b.__isset);
}

TResultSetBufferDescriptor::TResultSetBufferDescriptor(const TResultSetBufferDescriptor& other45) {
  layout = other45.layout;
  keyless = other45.keyless;
  entry_count = other45.entry_count;
  idx_target_as_key = other45.idx_target_as_key;
  min_val = other45.min_val;
  max_val = other45.max_val;
  bucket = other45.bucket;
  group_col_widths = other45.group_col_widths;
  key_bytewidth = other45.key_bytewidth;
  col_slot_context = other45.col_slot_context;
  target_groupby_indices = other45.target_groupby_indices;
  count_distinct_descriptors = other45.count_distinct_descriptors;
  force_4byte_float = other45.force_4byte_float;
  __isset = other45.__isset;
}
TResultSetBufferDescriptor& TResultSetBufferDescriptor::operator=(const TResultSetBufferDescriptor& other46) {
  layout = other46.layout;
  keyless = other46.keyless;
  entry_count = other46.entry_count;
  idx_target_as_key = other46.idx_target_as_key;
  min_val = other46.min_val;
  max_val = other46.max_val;
  bucket = other46.bucket;
  group_col_widths = other46.group_col_widths;
  key_bytewidth = other46.key_bytewidth;
  col_slot_context = other46.col_slot_context;
  target_groupby_indices = other46.target_groupby_indices;
  count_distinct_descriptors = other46.count_distinct_descriptors;
  force_4byte_float = other46.force_4byte_float;
  __isset = other46.__isset;
  return *this;
}
void TResultSetBufferDescriptor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TResultSetBufferDescriptor(";
  out << "layout=" << to_string(layout);
  out << ", " << "keyless=" << to_string(keyless);
  out << ", " << "entry_count=" << to_string(entry_count);
  out << ", " << "idx_target_as_key=" << to_string(idx_target_as_key);
  out << ", " << "min_val=" << to_string(min_val);
  out << ", " << "max_val=" << to_string(max_val);
  out << ", " << "bucket=" << to_string(bucket);
  out << ", " << "group_col_widths=" << to_string(group_col_widths);
  out << ", " << "key_bytewidth=" << to_string(key_bytewidth);
  out << ", " << "col_slot_context=" << to_string(col_slot_context);
  out << ", " << "target_groupby_indices=" << to_string(target_groupby_indices);
  out << ", " << "count_distinct_descriptors=" << to_string(count_distinct_descriptors);
  out << ", " << "force_4byte_float=" << to_string(force_4byte_float);
  out << ")";
}


TTargetInfo::~TTargetInfo() throw() {
}


void TTargetInfo::__set_is_agg(const bool val) {
  this->is_agg = val;
}

void TTargetInfo::__set_kind(const TAggKind::type val) {
  this->kind = val;
}

void TTargetInfo::__set_type(const  ::TTypeInfo& val) {
  this->type = val;
}

void TTargetInfo::__set_arg_type(const  ::TTypeInfo& val) {
  this->arg_type = val;
}

void TTargetInfo::__set_skip_nulls(const bool val) {
  this->skip_nulls = val;
}

void TTargetInfo::__set_is_distinct(const bool val) {
  this->is_distinct = val;
}
std::ostream& operator<<(std::ostream& out, const TTargetInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTargetInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_agg);
          this->__isset.is_agg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast47;
          xfer += iprot->readI32(ecast47);
          this->kind = (TAggKind::type)ecast47;
          this->__isset.kind = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->type.read(iprot);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->arg_type.read(iprot);
          this->__isset.arg_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->skip_nulls);
          this->__isset.skip_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_distinct);
          this->__isset.is_distinct = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTargetInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTargetInfo");

  xfer += oprot->writeFieldBegin("is_agg", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_agg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("kind", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->kind);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->type.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg_type", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->arg_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skip_nulls", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->skip_nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_distinct", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->is_distinct);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTargetInfo &a, TTargetInfo &b) {
  using ::std::swap;
  swap(a.is_agg, b.is_agg);
  swap(a.kind, b.kind);
  swap(a.type, b.type);
  swap(a.arg_type, b.arg_type);
  swap(a.skip_nulls, b.skip_nulls);
  swap(a.is_distinct, b.is_distinct);
  swap(a.__isset, b.__isset);
}

TTargetInfo::TTargetInfo(const TTargetInfo& other48) {
  is_agg = other48.is_agg;
  kind = other48.kind;
  type = other48.type;
  arg_type = other48.arg_type;
  skip_nulls = other48.skip_nulls;
  is_distinct = other48.is_distinct;
  __isset = other48.__isset;
}
TTargetInfo& TTargetInfo::operator=(const TTargetInfo& other49) {
  is_agg = other49.is_agg;
  kind = other49.kind;
  type = other49.type;
  arg_type = other49.arg_type;
  skip_nulls = other49.skip_nulls;
  is_distinct = other49.is_distinct;
  __isset = other49.__isset;
  return *this;
}
void TTargetInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTargetInfo(";
  out << "is_agg=" << to_string(is_agg);
  out << ", " << "kind=" << to_string(kind);
  out << ", " << "type=" << to_string(type);
  out << ", " << "arg_type=" << to_string(arg_type);
  out << ", " << "skip_nulls=" << to_string(skip_nulls);
  out << ", " << "is_distinct=" << to_string(is_distinct);
  out << ")";
}


TCountDistinctSetStorage::~TCountDistinctSetStorage() throw() {
}


void TCountDistinctSetStorage::__set_bitmap(const std::string& val) {
  this->bitmap = val;
__isset.bitmap = true;
}

void TCountDistinctSetStorage::__set_sparse_set(const std::set<int64_t> & val) {
  this->sparse_set = val;
__isset.sparse_set = true;
}
std::ostream& operator<<(std::ostream& out, const TCountDistinctSetStorage& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCountDistinctSetStorage::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitmap);
          this->__isset.bitmap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->sparse_set.clear();
            uint32_t _size50;
            ::apache::thrift::protocol::TType _etype53;
            xfer += iprot->readSetBegin(_etype53, _size50);
            uint32_t _i54;
            for (_i54 = 0; _i54 < _size50; ++_i54)
            {
              int64_t _elem55;
              xfer += iprot->readI64(_elem55);
              this->sparse_set.insert(_elem55);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.sparse_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCountDistinctSetStorage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCountDistinctSetStorage");

  if (this->__isset.bitmap) {
    xfer += oprot->writeFieldBegin("bitmap", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->bitmap);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sparse_set) {
    xfer += oprot->writeFieldBegin("sparse_set", ::apache::thrift::protocol::T_SET, 2);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->sparse_set.size()));
      std::set<int64_t> ::const_iterator _iter56;
      for (_iter56 = this->sparse_set.begin(); _iter56 != this->sparse_set.end(); ++_iter56)
      {
        xfer += oprot->writeI64((*_iter56));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCountDistinctSetStorage &a, TCountDistinctSetStorage &b) {
  using ::std::swap;
  swap(a.bitmap, b.bitmap);
  swap(a.sparse_set, b.sparse_set);
  swap(a.__isset, b.__isset);
}

TCountDistinctSetStorage::TCountDistinctSetStorage(const TCountDistinctSetStorage& other57) {
  bitmap = other57.bitmap;
  sparse_set = other57.sparse_set;
  __isset = other57.__isset;
}
TCountDistinctSetStorage& TCountDistinctSetStorage::operator=(const TCountDistinctSetStorage& other58) {
  bitmap = other58.bitmap;
  sparse_set = other58.sparse_set;
  __isset = other58.__isset;
  return *this;
}
void TCountDistinctSetStorage::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCountDistinctSetStorage(";
  out << "bitmap="; (__isset.bitmap ? (out << to_string(bitmap)) : (out << "<null>"));
  out << ", " << "sparse_set="; (__isset.sparse_set ? (out << to_string(sparse_set)) : (out << "<null>"));
  out << ")";
}


TCountDistinctSet::~TCountDistinctSet() throw() {
}


void TCountDistinctSet::__set_type(const TCountDistinctImplType::type val) {
  this->type = val;
}

void TCountDistinctSet::__set_storage(const TCountDistinctSetStorage& val) {
  this->storage = val;
}

void TCountDistinctSet::__set_remote_ptr(const int64_t val) {
  this->remote_ptr = val;
}
std::ostream& operator<<(std::ostream& out, const TCountDistinctSet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCountDistinctSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast59;
          xfer += iprot->readI32(ecast59);
          this->type = (TCountDistinctImplType::type)ecast59;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->storage.read(iprot);
          this->__isset.storage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->remote_ptr);
          this->__isset.remote_ptr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCountDistinctSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCountDistinctSet");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("storage", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->storage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote_ptr", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->remote_ptr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCountDistinctSet &a, TCountDistinctSet &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.storage, b.storage);
  swap(a.remote_ptr, b.remote_ptr);
  swap(a.__isset, b.__isset);
}

TCountDistinctSet::TCountDistinctSet(const TCountDistinctSet& other60) {
  type = other60.type;
  storage = other60.storage;
  remote_ptr = other60.remote_ptr;
  __isset = other60.__isset;
}
TCountDistinctSet& TCountDistinctSet::operator=(const TCountDistinctSet& other61) {
  type = other61.type;
  storage = other61.storage;
  remote_ptr = other61.remote_ptr;
  __isset = other61.__isset;
  return *this;
}
void TCountDistinctSet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCountDistinctSet(";
  out << "type=" << to_string(type);
  out << ", " << "storage=" << to_string(storage);
  out << ", " << "remote_ptr=" << to_string(remote_ptr);
  out << ")";
}


TSerializedRows::~TSerializedRows() throw() {
}


void TSerializedRows::__set_buffers(const std::vector<std::string> & val) {
  this->buffers = val;
}

void TSerializedRows::__set_buffer_lengths(const std::vector<int64_t> & val) {
  this->buffer_lengths = val;
}

void TSerializedRows::__set_buffers_total_size(const int64_t val) {
  this->buffers_total_size = val;
}

void TSerializedRows::__set_total_compression_time_ms(const int32_t val) {
  this->total_compression_time_ms = val;
}

void TSerializedRows::__set_descriptor(const TResultSetBufferDescriptor& val) {
  this->descriptor = val;
}

void TSerializedRows::__set_targets(const std::vector<TTargetInfo> & val) {
  this->targets = val;
}

void TSerializedRows::__set_target_init_vals(const std::vector<int64_t> & val) {
  this->target_init_vals = val;
}

void TSerializedRows::__set_varlen_buffer(const std::vector<std::string> & val) {
  this->varlen_buffer = val;
}

void TSerializedRows::__set_count_distinct_sets(const std::vector<TCountDistinctSet> & val) {
  this->count_distinct_sets = val;
}

void TSerializedRows::__set_explanation(const std::string& val) {
  this->explanation = val;
}
std::ostream& operator<<(std::ostream& out, const TSerializedRows& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSerializedRows::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->buffers.clear();
            uint32_t _size62;
            ::apache::thrift::protocol::TType _etype65;
            xfer += iprot->readListBegin(_etype65, _size62);
            this->buffers.resize(_size62);
            uint32_t _i66;
            for (_i66 = 0; _i66 < _size62; ++_i66)
            {
              xfer += iprot->readBinary(this->buffers[_i66]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.buffers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->buffer_lengths.clear();
            uint32_t _size67;
            ::apache::thrift::protocol::TType _etype70;
            xfer += iprot->readListBegin(_etype70, _size67);
            this->buffer_lengths.resize(_size67);
            uint32_t _i71;
            for (_i71 = 0; _i71 < _size67; ++_i71)
            {
              xfer += iprot->readI64(this->buffer_lengths[_i71]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.buffer_lengths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->buffers_total_size);
          this->__isset.buffers_total_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total_compression_time_ms);
          this->__isset.total_compression_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->descriptor.read(iprot);
          this->__isset.descriptor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->targets.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _etype75;
            xfer += iprot->readListBegin(_etype75, _size72);
            this->targets.resize(_size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              xfer += this->targets[_i76].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->target_init_vals.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readListBegin(_etype80, _size77);
            this->target_init_vals.resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += iprot->readI64(this->target_init_vals[_i81]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.target_init_vals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->varlen_buffer.clear();
            uint32_t _size82;
            ::apache::thrift::protocol::TType _etype85;
            xfer += iprot->readListBegin(_etype85, _size82);
            this->varlen_buffer.resize(_size82);
            uint32_t _i86;
            for (_i86 = 0; _i86 < _size82; ++_i86)
            {
              xfer += iprot->readBinary(this->varlen_buffer[_i86]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.varlen_buffer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->count_distinct_sets.clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _etype90;
            xfer += iprot->readListBegin(_etype90, _size87);
            this->count_distinct_sets.resize(_size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              xfer += this->count_distinct_sets[_i91].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.count_distinct_sets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->explanation);
          this->__isset.explanation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TSerializedRows::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSerializedRows");

  xfer += oprot->writeFieldBegin("buffers", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->buffers.size()));
    std::vector<std::string> ::const_iterator _iter92;
    for (_iter92 = this->buffers.begin(); _iter92 != this->buffers.end(); ++_iter92)
    {
      xfer += oprot->writeBinary((*_iter92));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("buffer_lengths", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->buffer_lengths.size()));
    std::vector<int64_t> ::const_iterator _iter93;
    for (_iter93 = this->buffer_lengths.begin(); _iter93 != this->buffer_lengths.end(); ++_iter93)
    {
      xfer += oprot->writeI64((*_iter93));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("buffers_total_size", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->buffers_total_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_compression_time_ms", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->total_compression_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("descriptor", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->descriptor.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->targets.size()));
    std::vector<TTargetInfo> ::const_iterator _iter94;
    for (_iter94 = this->targets.begin(); _iter94 != this->targets.end(); ++_iter94)
    {
      xfer += (*_iter94).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_init_vals", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->target_init_vals.size()));
    std::vector<int64_t> ::const_iterator _iter95;
    for (_iter95 = this->target_init_vals.begin(); _iter95 != this->target_init_vals.end(); ++_iter95)
    {
      xfer += oprot->writeI64((*_iter95));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("varlen_buffer", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->varlen_buffer.size()));
    std::vector<std::string> ::const_iterator _iter96;
    for (_iter96 = this->varlen_buffer.begin(); _iter96 != this->varlen_buffer.end(); ++_iter96)
    {
      xfer += oprot->writeBinary((*_iter96));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count_distinct_sets", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->count_distinct_sets.size()));
    std::vector<TCountDistinctSet> ::const_iterator _iter97;
    for (_iter97 = this->count_distinct_sets.begin(); _iter97 != this->count_distinct_sets.end(); ++_iter97)
    {
      xfer += (*_iter97).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("explanation", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->explanation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSerializedRows &a, TSerializedRows &b) {
  using ::std::swap;
  swap(a.buffers, b.buffers);
  swap(a.buffer_lengths, b.buffer_lengths);
  swap(a.buffers_total_size, b.buffers_total_size);
  swap(a.total_compression_time_ms, b.total_compression_time_ms);
  swap(a.descriptor, b.descriptor);
  swap(a.targets, b.targets);
  swap(a.target_init_vals, b.target_init_vals);
  swap(a.varlen_buffer, b.varlen_buffer);
  swap(a.count_distinct_sets, b.count_distinct_sets);
  swap(a.explanation, b.explanation);
  swap(a.__isset, b.__isset);
}

TSerializedRows::TSerializedRows(const TSerializedRows& other98) {
  buffers = other98.buffers;
  buffer_lengths = other98.buffer_lengths;
  buffers_total_size = other98.buffers_total_size;
  total_compression_time_ms = other98.total_compression_time_ms;
  descriptor = other98.descriptor;
  targets = other98.targets;
  target_init_vals = other98.target_init_vals;
  varlen_buffer = other98.varlen_buffer;
  count_distinct_sets = other98.count_distinct_sets;
  explanation = other98.explanation;
  __isset = other98.__isset;
}
TSerializedRows& TSerializedRows::operator=(const TSerializedRows& other99) {
  buffers = other99.buffers;
  buffer_lengths = other99.buffer_lengths;
  buffers_total_size = other99.buffers_total_size;
  total_compression_time_ms = other99.total_compression_time_ms;
  descriptor = other99.descriptor;
  targets = other99.targets;
  target_init_vals = other99.target_init_vals;
  varlen_buffer = other99.varlen_buffer;
  count_distinct_sets = other99.count_distinct_sets;
  explanation = other99.explanation;
  __isset = other99.__isset;
  return *this;
}
void TSerializedRows::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSerializedRows(";
  out << "buffers=" << to_string(buffers);
  out << ", " << "buffer_lengths=" << to_string(buffer_lengths);
  out << ", " << "buffers_total_size=" << to_string(buffers_total_size);
  out << ", " << "total_compression_time_ms=" << to_string(total_compression_time_ms);
  out << ", " << "descriptor=" << to_string(descriptor);
  out << ", " << "targets=" << to_string(targets);
  out << ", " << "target_init_vals=" << to_string(target_init_vals);
  out << ", " << "varlen_buffer=" << to_string(varlen_buffer);
  out << ", " << "count_distinct_sets=" << to_string(count_distinct_sets);
  out << ", " << "explanation=" << to_string(explanation);
  out << ")";
}


