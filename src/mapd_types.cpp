/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "mapd_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kTExecuteModeValues[] = {
  TExecuteMode::GPU,
  TExecuteMode::CPU
};
const char* _kTExecuteModeNames[] = {
  "GPU",
  "CPU"
};
const std::map<int, const char*> _TExecuteMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTExecuteModeValues, _kTExecuteModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TExecuteMode::type& val) {
  std::map<int, const char*>::const_iterator it = _TExecuteMode_VALUES_TO_NAMES.find(val);
  if (it != _TExecuteMode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTFileTypeValues[] = {
  TFileType::DELIMITED,
  TFileType::POLYGON,
  TFileType::PARQUET
};
const char* _kTFileTypeNames[] = {
  "DELIMITED",
  "POLYGON",
  "PARQUET"
};
const std::map<int, const char*> _TFileType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTFileTypeValues, _kTFileTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TFileType::type& val) {
  std::map<int, const char*>::const_iterator it = _TFileType_VALUES_TO_NAMES.find(val);
  if (it != _TFileType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTPartitionDetailValues[] = {
  TPartitionDetail::DEFAULT,
  TPartitionDetail::REPLICATED,
  TPartitionDetail::SHARDED,
  TPartitionDetail::OTHER
};
const char* _kTPartitionDetailNames[] = {
  "DEFAULT",
  "REPLICATED",
  "SHARDED",
  "OTHER"
};
const std::map<int, const char*> _TPartitionDetail_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTPartitionDetailValues, _kTPartitionDetailNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TPartitionDetail::type& val) {
  std::map<int, const char*>::const_iterator it = _TPartitionDetail_VALUES_TO_NAMES.find(val);
  if (it != _TPartitionDetail_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTGeoFileLayerContentsValues[] = {
  TGeoFileLayerContents::EMPTY,
  TGeoFileLayerContents::GEO,
  TGeoFileLayerContents::NON_GEO,
  TGeoFileLayerContents::UNSUPPORTED_GEO
};
const char* _kTGeoFileLayerContentsNames[] = {
  "EMPTY",
  "GEO",
  "NON_GEO",
  "UNSUPPORTED_GEO"
};
const std::map<int, const char*> _TGeoFileLayerContents_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTGeoFileLayerContentsValues, _kTGeoFileLayerContentsNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TGeoFileLayerContents::type& val) {
  std::map<int, const char*>::const_iterator it = _TGeoFileLayerContents_VALUES_TO_NAMES.find(val);
  if (it != _TGeoFileLayerContents_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTImportHeaderRowValues[] = {
  TImportHeaderRow::AUTODETECT,
  TImportHeaderRow::NO_HEADER,
  TImportHeaderRow::HAS_HEADER
};
const char* _kTImportHeaderRowNames[] = {
  "AUTODETECT",
  "NO_HEADER",
  "HAS_HEADER"
};
const std::map<int, const char*> _TImportHeaderRow_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTImportHeaderRowValues, _kTImportHeaderRowNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TImportHeaderRow::type& val) {
  std::map<int, const char*>::const_iterator it = _TImportHeaderRow_VALUES_TO_NAMES.find(val);
  if (it != _TImportHeaderRow_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTRoleValues[] = {
  TRole::SERVER,
  TRole::AGGREGATOR,
  TRole::LEAF,
  TRole::STRING_DICTIONARY
};
const char* _kTRoleNames[] = {
  "SERVER",
  "AGGREGATOR",
  "LEAF",
  "STRING_DICTIONARY"
};
const std::map<int, const char*> _TRole_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTRoleValues, _kTRoleNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TRole::type& val) {
  std::map<int, const char*>::const_iterator it = _TRole_VALUES_TO_NAMES.find(val);
  if (it != _TRole_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTMergeTypeValues[] = {
  TMergeType::UNION,
  TMergeType::REDUCE
};
const char* _kTMergeTypeNames[] = {
  "UNION",
  "REDUCE"
};
const std::map<int, const char*> _TMergeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTMergeTypeValues, _kTMergeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TMergeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TMergeType_VALUES_TO_NAMES.find(val);
  if (it != _TMergeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTExpressionRangeTypeValues[] = {
  TExpressionRangeType::INVALID,
  TExpressionRangeType::INTEGER,
  TExpressionRangeType::FLOAT,
  TExpressionRangeType::DOUBLE
};
const char* _kTExpressionRangeTypeNames[] = {
  "INVALID",
  "INTEGER",
  "FLOAT",
  "DOUBLE"
};
const std::map<int, const char*> _TExpressionRangeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTExpressionRangeTypeValues, _kTExpressionRangeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TExpressionRangeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TExpressionRangeType_VALUES_TO_NAMES.find(val);
  if (it != _TExpressionRangeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTDBObjectTypeValues[] = {
  TDBObjectType::AbstractDBObjectType,
  TDBObjectType::DatabaseDBObjectType,
  TDBObjectType::TableDBObjectType,
  TDBObjectType::DashboardDBObjectType,
  TDBObjectType::ViewDBObjectType
};
const char* _kTDBObjectTypeNames[] = {
  "AbstractDBObjectType",
  "DatabaseDBObjectType",
  "TableDBObjectType",
  "DashboardDBObjectType",
  "ViewDBObjectType"
};
const std::map<int, const char*> _TDBObjectType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTDBObjectTypeValues, _kTDBObjectTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TDBObjectType::type& val) {
  std::map<int, const char*>::const_iterator it = _TDBObjectType_VALUES_TO_NAMES.find(val);
  if (it != _TDBObjectType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


TDatumVal::~TDatumVal() throw() {
}


void TDatumVal::__set_int_val(const int64_t val) {
  this->int_val = val;
}

void TDatumVal::__set_real_val(const double val) {
  this->real_val = val;
}

void TDatumVal::__set_str_val(const std::string& val) {
  this->str_val = val;
}

void TDatumVal::__set_arr_val(const std::vector<TDatum> & val) {
  this->arr_val = val;
}
std::ostream& operator<<(std::ostream& out, const TDatumVal& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDatumVal::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->int_val);
          this->__isset.int_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->real_val);
          this->__isset.real_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->str_val);
          this->__isset.str_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arr_val.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->arr_val.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->arr_val[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arr_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDatumVal::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDatumVal");

  xfer += oprot->writeFieldBegin("int_val", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->int_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("real_val", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->real_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("str_val", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->str_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arr_val", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arr_val.size()));
    std::vector<TDatum> ::const_iterator _iter5;
    for (_iter5 = this->arr_val.begin(); _iter5 != this->arr_val.end(); ++_iter5)
    {
      xfer += (*_iter5).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDatumVal &a, TDatumVal &b) {
  using ::std::swap;
  swap(a.int_val, b.int_val);
  swap(a.real_val, b.real_val);
  swap(a.str_val, b.str_val);
  swap(a.arr_val, b.arr_val);
  swap(a.__isset, b.__isset);
}

TDatumVal::TDatumVal(const TDatumVal& other6) {
  int_val = other6.int_val;
  real_val = other6.real_val;
  str_val = other6.str_val;
  arr_val = other6.arr_val;
  __isset = other6.__isset;
}
TDatumVal& TDatumVal::operator=(const TDatumVal& other7) {
  int_val = other7.int_val;
  real_val = other7.real_val;
  str_val = other7.str_val;
  arr_val = other7.arr_val;
  __isset = other7.__isset;
  return *this;
}
void TDatumVal::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDatumVal(";
  out << "int_val=" << to_string(int_val);
  out << ", " << "real_val=" << to_string(real_val);
  out << ", " << "str_val=" << to_string(str_val);
  out << ", " << "arr_val=" << to_string(arr_val);
  out << ")";
}


TDatum::~TDatum() throw() {
}


void TDatum::__set_val(const TDatumVal& val) {
  this->val = val;
}

void TDatum::__set_is_null(const bool val) {
  this->is_null = val;
}
std::ostream& operator<<(std::ostream& out, const TDatum& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDatum::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->val.read(iprot);
          this->__isset.val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_null);
          this->__isset.is_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDatum::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDatum");

  xfer += oprot->writeFieldBegin("val", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->val.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_null", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDatum &a, TDatum &b) {
  using ::std::swap;
  swap(a.val, b.val);
  swap(a.is_null, b.is_null);
  swap(a.__isset, b.__isset);
}

TDatum::TDatum(const TDatum& other8) {
  val = other8.val;
  is_null = other8.is_null;
  __isset = other8.__isset;
}
TDatum& TDatum::operator=(const TDatum& other9) {
  val = other9.val;
  is_null = other9.is_null;
  __isset = other9.__isset;
  return *this;
}
void TDatum::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDatum(";
  out << "val=" << to_string(val);
  out << ", " << "is_null=" << to_string(is_null);
  out << ")";
}


TStringValue::~TStringValue() throw() {
}


void TStringValue::__set_str_val(const std::string& val) {
  this->str_val = val;
}

void TStringValue::__set_is_null(const bool val) {
  this->is_null = val;
}
std::ostream& operator<<(std::ostream& out, const TStringValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStringValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->str_val);
          this->__isset.str_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_null);
          this->__isset.is_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringValue");

  xfer += oprot->writeFieldBegin("str_val", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->str_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_null", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStringValue &a, TStringValue &b) {
  using ::std::swap;
  swap(a.str_val, b.str_val);
  swap(a.is_null, b.is_null);
  swap(a.__isset, b.__isset);
}

TStringValue::TStringValue(const TStringValue& other10) {
  str_val = other10.str_val;
  is_null = other10.is_null;
  __isset = other10.__isset;
}
TStringValue& TStringValue::operator=(const TStringValue& other11) {
  str_val = other11.str_val;
  is_null = other11.is_null;
  __isset = other11.__isset;
  return *this;
}
void TStringValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStringValue(";
  out << "str_val=" << to_string(str_val);
  out << ", " << "is_null=" << to_string(is_null);
  out << ")";
}


TColumnType::~TColumnType() throw() {
}


void TColumnType::__set_col_name(const std::string& val) {
  this->col_name = val;
}

void TColumnType::__set_col_type(const  ::TTypeInfo& val) {
  this->col_type = val;
}

void TColumnType::__set_is_reserved_keyword(const bool val) {
  this->is_reserved_keyword = val;
}

void TColumnType::__set_src_name(const std::string& val) {
  this->src_name = val;
}

void TColumnType::__set_is_system(const bool val) {
  this->is_system = val;
}

void TColumnType::__set_is_physical(const bool val) {
  this->is_physical = val;
}

void TColumnType::__set_col_id(const int64_t val) {
  this->col_id = val;
}
std::ostream& operator<<(std::ostream& out, const TColumnType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col_name);
          this->__isset.col_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->col_type.read(iprot);
          this->__isset.col_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_reserved_keyword);
          this->__isset.is_reserved_keyword = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->src_name);
          this->__isset.src_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_system);
          this->__isset.is_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_physical);
          this->__isset.is_physical = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->col_id);
          this->__isset.col_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnType");

  xfer += oprot->writeFieldBegin("col_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->col_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_type", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->col_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_reserved_keyword", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_reserved_keyword);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->src_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_system", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_system);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_physical", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->is_physical);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_id", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->col_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnType &a, TColumnType &b) {
  using ::std::swap;
  swap(a.col_name, b.col_name);
  swap(a.col_type, b.col_type);
  swap(a.is_reserved_keyword, b.is_reserved_keyword);
  swap(a.src_name, b.src_name);
  swap(a.is_system, b.is_system);
  swap(a.is_physical, b.is_physical);
  swap(a.col_id, b.col_id);
  swap(a.__isset, b.__isset);
}

TColumnType::TColumnType(const TColumnType& other12) {
  col_name = other12.col_name;
  col_type = other12.col_type;
  is_reserved_keyword = other12.is_reserved_keyword;
  src_name = other12.src_name;
  is_system = other12.is_system;
  is_physical = other12.is_physical;
  col_id = other12.col_id;
  __isset = other12.__isset;
}
TColumnType& TColumnType::operator=(const TColumnType& other13) {
  col_name = other13.col_name;
  col_type = other13.col_type;
  is_reserved_keyword = other13.is_reserved_keyword;
  src_name = other13.src_name;
  is_system = other13.is_system;
  is_physical = other13.is_physical;
  col_id = other13.col_id;
  __isset = other13.__isset;
  return *this;
}
void TColumnType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnType(";
  out << "col_name=" << to_string(col_name);
  out << ", " << "col_type=" << to_string(col_type);
  out << ", " << "is_reserved_keyword=" << to_string(is_reserved_keyword);
  out << ", " << "src_name=" << to_string(src_name);
  out << ", " << "is_system=" << to_string(is_system);
  out << ", " << "is_physical=" << to_string(is_physical);
  out << ", " << "col_id=" << to_string(col_id);
  out << ")";
}


TRow::~TRow() throw() {
}


void TRow::__set_cols(const std::vector<TDatum> & val) {
  this->cols = val;
}
std::ostream& operator<<(std::ostream& out, const TRow& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRow::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cols.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->cols.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += this->cols[_i18].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRow");

  xfer += oprot->writeFieldBegin("cols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cols.size()));
    std::vector<TDatum> ::const_iterator _iter19;
    for (_iter19 = this->cols.begin(); _iter19 != this->cols.end(); ++_iter19)
    {
      xfer += (*_iter19).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRow &a, TRow &b) {
  using ::std::swap;
  swap(a.cols, b.cols);
  swap(a.__isset, b.__isset);
}

TRow::TRow(const TRow& other20) {
  cols = other20.cols;
  __isset = other20.__isset;
}
TRow& TRow::operator=(const TRow& other21) {
  cols = other21.cols;
  __isset = other21.__isset;
  return *this;
}
void TRow::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRow(";
  out << "cols=" << to_string(cols);
  out << ")";
}


TColumnData::~TColumnData() throw() {
}


void TColumnData::__set_int_col(const std::vector<int64_t> & val) {
  this->int_col = val;
}

void TColumnData::__set_real_col(const std::vector<double> & val) {
  this->real_col = val;
}

void TColumnData::__set_str_col(const std::vector<std::string> & val) {
  this->str_col = val;
}

void TColumnData::__set_arr_col(const std::vector<TColumn> & val) {
  this->arr_col = val;
}
std::ostream& operator<<(std::ostream& out, const TColumnData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->int_col.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->int_col.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += iprot->readI64(this->int_col[_i26]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.int_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->real_col.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->real_col.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += iprot->readDouble(this->real_col[_i31]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.real_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->str_col.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->str_col.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += iprot->readString(this->str_col[_i36]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.str_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arr_col.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->arr_col.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += this->arr_col[_i41].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arr_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnData");

  xfer += oprot->writeFieldBegin("int_col", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->int_col.size()));
    std::vector<int64_t> ::const_iterator _iter42;
    for (_iter42 = this->int_col.begin(); _iter42 != this->int_col.end(); ++_iter42)
    {
      xfer += oprot->writeI64((*_iter42));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("real_col", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->real_col.size()));
    std::vector<double> ::const_iterator _iter43;
    for (_iter43 = this->real_col.begin(); _iter43 != this->real_col.end(); ++_iter43)
    {
      xfer += oprot->writeDouble((*_iter43));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("str_col", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->str_col.size()));
    std::vector<std::string> ::const_iterator _iter44;
    for (_iter44 = this->str_col.begin(); _iter44 != this->str_col.end(); ++_iter44)
    {
      xfer += oprot->writeString((*_iter44));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arr_col", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arr_col.size()));
    std::vector<TColumn> ::const_iterator _iter45;
    for (_iter45 = this->arr_col.begin(); _iter45 != this->arr_col.end(); ++_iter45)
    {
      xfer += (*_iter45).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnData &a, TColumnData &b) {
  using ::std::swap;
  swap(a.int_col, b.int_col);
  swap(a.real_col, b.real_col);
  swap(a.str_col, b.str_col);
  swap(a.arr_col, b.arr_col);
  swap(a.__isset, b.__isset);
}

TColumnData::TColumnData(const TColumnData& other46) {
  int_col = other46.int_col;
  real_col = other46.real_col;
  str_col = other46.str_col;
  arr_col = other46.arr_col;
  __isset = other46.__isset;
}
TColumnData& TColumnData::operator=(const TColumnData& other47) {
  int_col = other47.int_col;
  real_col = other47.real_col;
  str_col = other47.str_col;
  arr_col = other47.arr_col;
  __isset = other47.__isset;
  return *this;
}
void TColumnData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnData(";
  out << "int_col=" << to_string(int_col);
  out << ", " << "real_col=" << to_string(real_col);
  out << ", " << "str_col=" << to_string(str_col);
  out << ", " << "arr_col=" << to_string(arr_col);
  out << ")";
}


TColumn::~TColumn() throw() {
}


void TColumn::__set_data(const TColumnData& val) {
  this->data = val;
}

void TColumn::__set_nulls(const std::vector<bool> & val) {
  this->nulls = val;
}
std::ostream& operator<<(std::ostream& out, const TColumn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nulls.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->nulls.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += iprot->readBool(this->nulls[_i52]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumn");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->nulls.size()));
    std::vector<bool> ::const_iterator _iter53;
    for (_iter53 = this->nulls.begin(); _iter53 != this->nulls.end(); ++_iter53)
    {
      xfer += oprot->writeBool((*_iter53));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumn &a, TColumn &b) {
  using ::std::swap;
  swap(a.data, b.data);
  swap(a.nulls, b.nulls);
  swap(a.__isset, b.__isset);
}

TColumn::TColumn(const TColumn& other54) {
  data = other54.data;
  nulls = other54.nulls;
  __isset = other54.__isset;
}
TColumn& TColumn::operator=(const TColumn& other55) {
  data = other55.data;
  nulls = other55.nulls;
  __isset = other55.__isset;
  return *this;
}
void TColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumn(";
  out << "data=" << to_string(data);
  out << ", " << "nulls=" << to_string(nulls);
  out << ")";
}


TStringRow::~TStringRow() throw() {
}


void TStringRow::__set_cols(const std::vector<TStringValue> & val) {
  this->cols = val;
}
std::ostream& operator<<(std::ostream& out, const TStringRow& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStringRow::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cols.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _etype59;
            xfer += iprot->readListBegin(_etype59, _size56);
            this->cols.resize(_size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              xfer += this->cols[_i60].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringRow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringRow");

  xfer += oprot->writeFieldBegin("cols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cols.size()));
    std::vector<TStringValue> ::const_iterator _iter61;
    for (_iter61 = this->cols.begin(); _iter61 != this->cols.end(); ++_iter61)
    {
      xfer += (*_iter61).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStringRow &a, TStringRow &b) {
  using ::std::swap;
  swap(a.cols, b.cols);
  swap(a.__isset, b.__isset);
}

TStringRow::TStringRow(const TStringRow& other62) {
  cols = other62.cols;
  __isset = other62.__isset;
}
TStringRow& TStringRow::operator=(const TStringRow& other63) {
  cols = other63.cols;
  __isset = other63.__isset;
  return *this;
}
void TStringRow::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStringRow(";
  out << "cols=" << to_string(cols);
  out << ")";
}


TStepResult::~TStepResult() throw() {
}


void TStepResult::__set_serialized_rows(const  ::TSerializedRows& val) {
  this->serialized_rows = val;
}

void TStepResult::__set_execution_finished(const bool val) {
  this->execution_finished = val;
}

void TStepResult::__set_merge_type(const TMergeType::type val) {
  this->merge_type = val;
}

void TStepResult::__set_sharded(const bool val) {
  this->sharded = val;
}

void TStepResult::__set_row_desc(const TRowDescriptor& val) {
  this->row_desc = val;
}

void TStepResult::__set_node_id(const int32_t val) {
  this->node_id = val;
}
std::ostream& operator<<(std::ostream& out, const TStepResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStepResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serialized_rows.read(iprot);
          this->__isset.serialized_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->execution_finished);
          this->__isset.execution_finished = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast64;
          xfer += iprot->readI32(ecast64);
          this->merge_type = (TMergeType::type)ecast64;
          this->__isset.merge_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sharded);
          this->__isset.sharded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_desc.clear();
            uint32_t _size65;
            ::apache::thrift::protocol::TType _etype68;
            xfer += iprot->readListBegin(_etype68, _size65);
            this->row_desc.resize(_size65);
            uint32_t _i69;
            for (_i69 = 0; _i69 < _size65; ++_i69)
            {
              xfer += this->row_desc[_i69].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStepResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStepResult");

  xfer += oprot->writeFieldBegin("serialized_rows", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->serialized_rows.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_finished", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->execution_finished);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("merge_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->merge_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sharded", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->sharded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_desc", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row_desc.size()));
    std::vector<TColumnType> ::const_iterator _iter70;
    for (_iter70 = this->row_desc.begin(); _iter70 != this->row_desc.end(); ++_iter70)
    {
      xfer += (*_iter70).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStepResult &a, TStepResult &b) {
  using ::std::swap;
  swap(a.serialized_rows, b.serialized_rows);
  swap(a.execution_finished, b.execution_finished);
  swap(a.merge_type, b.merge_type);
  swap(a.sharded, b.sharded);
  swap(a.row_desc, b.row_desc);
  swap(a.node_id, b.node_id);
  swap(a.__isset, b.__isset);
}

TStepResult::TStepResult(const TStepResult& other71) {
  serialized_rows = other71.serialized_rows;
  execution_finished = other71.execution_finished;
  merge_type = other71.merge_type;
  sharded = other71.sharded;
  row_desc = other71.row_desc;
  node_id = other71.node_id;
  __isset = other71.__isset;
}
TStepResult& TStepResult::operator=(const TStepResult& other72) {
  serialized_rows = other72.serialized_rows;
  execution_finished = other72.execution_finished;
  merge_type = other72.merge_type;
  sharded = other72.sharded;
  row_desc = other72.row_desc;
  node_id = other72.node_id;
  __isset = other72.__isset;
  return *this;
}
void TStepResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStepResult(";
  out << "serialized_rows=" << to_string(serialized_rows);
  out << ", " << "execution_finished=" << to_string(execution_finished);
  out << ", " << "merge_type=" << to_string(merge_type);
  out << ", " << "sharded=" << to_string(sharded);
  out << ", " << "row_desc=" << to_string(row_desc);
  out << ", " << "node_id=" << to_string(node_id);
  out << ")";
}


TRowSet::~TRowSet() throw() {
}


void TRowSet::__set_row_desc(const TRowDescriptor& val) {
  this->row_desc = val;
}

void TRowSet::__set_rows(const std::vector<TRow> & val) {
  this->rows = val;
}

void TRowSet::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
}

void TRowSet::__set_is_columnar(const bool val) {
  this->is_columnar = val;
}
std::ostream& operator<<(std::ostream& out, const TRowSet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRowSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_desc.clear();
            uint32_t _size73;
            ::apache::thrift::protocol::TType _etype76;
            xfer += iprot->readListBegin(_etype76, _size73);
            this->row_desc.resize(_size73);
            uint32_t _i77;
            for (_i77 = 0; _i77 < _size73; ++_i77)
            {
              xfer += this->row_desc[_i77].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rows.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->rows.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += this->rows[_i82].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size83;
            ::apache::thrift::protocol::TType _etype86;
            xfer += iprot->readListBegin(_etype86, _size83);
            this->columns.resize(_size83);
            uint32_t _i87;
            for (_i87 = 0; _i87 < _size83; ++_i87)
            {
              xfer += this->columns[_i87].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_columnar);
          this->__isset.is_columnar = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRowSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRowSet");

  xfer += oprot->writeFieldBegin("row_desc", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row_desc.size()));
    std::vector<TColumnType> ::const_iterator _iter88;
    for (_iter88 = this->row_desc.begin(); _iter88 != this->row_desc.end(); ++_iter88)
    {
      xfer += (*_iter88).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rows.size()));
    std::vector<TRow> ::const_iterator _iter89;
    for (_iter89 = this->rows.begin(); _iter89 != this->rows.end(); ++_iter89)
    {
      xfer += (*_iter89).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumn> ::const_iterator _iter90;
    for (_iter90 = this->columns.begin(); _iter90 != this->columns.end(); ++_iter90)
    {
      xfer += (*_iter90).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_columnar", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_columnar);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRowSet &a, TRowSet &b) {
  using ::std::swap;
  swap(a.row_desc, b.row_desc);
  swap(a.rows, b.rows);
  swap(a.columns, b.columns);
  swap(a.is_columnar, b.is_columnar);
  swap(a.__isset, b.__isset);
}

TRowSet::TRowSet(const TRowSet& other91) {
  row_desc = other91.row_desc;
  rows = other91.rows;
  columns = other91.columns;
  is_columnar = other91.is_columnar;
  __isset = other91.__isset;
}
TRowSet& TRowSet::operator=(const TRowSet& other92) {
  row_desc = other92.row_desc;
  rows = other92.rows;
  columns = other92.columns;
  is_columnar = other92.is_columnar;
  __isset = other92.__isset;
  return *this;
}
void TRowSet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRowSet(";
  out << "row_desc=" << to_string(row_desc);
  out << ", " << "rows=" << to_string(rows);
  out << ", " << "columns=" << to_string(columns);
  out << ", " << "is_columnar=" << to_string(is_columnar);
  out << ")";
}


TQueryResult::~TQueryResult() throw() {
}


void TQueryResult::__set_row_set(const TRowSet& val) {
  this->row_set = val;
}

void TQueryResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TQueryResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}

void TQueryResult::__set_nonce(const std::string& val) {
  this->nonce = val;
}
std::ostream& operator<<(std::ostream& out, const TQueryResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TQueryResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_set.read(iprot);
          this->__isset.row_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          this->__isset.nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TQueryResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TQueryResult");

  xfer += oprot->writeFieldBegin("row_set", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->row_set.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TQueryResult &a, TQueryResult &b) {
  using ::std::swap;
  swap(a.row_set, b.row_set);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.nonce, b.nonce);
  swap(a.__isset, b.__isset);
}

TQueryResult::TQueryResult(const TQueryResult& other93) {
  row_set = other93.row_set;
  execution_time_ms = other93.execution_time_ms;
  total_time_ms = other93.total_time_ms;
  nonce = other93.nonce;
  __isset = other93.__isset;
}
TQueryResult& TQueryResult::operator=(const TQueryResult& other94) {
  row_set = other94.row_set;
  execution_time_ms = other94.execution_time_ms;
  total_time_ms = other94.total_time_ms;
  nonce = other94.nonce;
  __isset = other94.__isset;
  return *this;
}
void TQueryResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TQueryResult(";
  out << "row_set=" << to_string(row_set);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ", " << "nonce=" << to_string(nonce);
  out << ")";
}


TDataFrame::~TDataFrame() throw() {
}


void TDataFrame::__set_sm_handle(const std::string& val) {
  this->sm_handle = val;
}

void TDataFrame::__set_sm_size(const int64_t val) {
  this->sm_size = val;
}

void TDataFrame::__set_df_handle(const std::string& val) {
  this->df_handle = val;
}

void TDataFrame::__set_df_size(const int64_t val) {
  this->df_size = val;
}
std::ostream& operator<<(std::ostream& out, const TDataFrame& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDataFrame::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->sm_handle);
          this->__isset.sm_handle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sm_size);
          this->__isset.sm_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->df_handle);
          this->__isset.df_handle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->df_size);
          this->__isset.df_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDataFrame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataFrame");

  xfer += oprot->writeFieldBegin("sm_handle", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->sm_handle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sm_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->sm_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("df_handle", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->df_handle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("df_size", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->df_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDataFrame &a, TDataFrame &b) {
  using ::std::swap;
  swap(a.sm_handle, b.sm_handle);
  swap(a.sm_size, b.sm_size);
  swap(a.df_handle, b.df_handle);
  swap(a.df_size, b.df_size);
  swap(a.__isset, b.__isset);
}

TDataFrame::TDataFrame(const TDataFrame& other95) {
  sm_handle = other95.sm_handle;
  sm_size = other95.sm_size;
  df_handle = other95.df_handle;
  df_size = other95.df_size;
  __isset = other95.__isset;
}
TDataFrame& TDataFrame::operator=(const TDataFrame& other96) {
  sm_handle = other96.sm_handle;
  sm_size = other96.sm_size;
  df_handle = other96.df_handle;
  df_size = other96.df_size;
  __isset = other96.__isset;
  return *this;
}
void TDataFrame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDataFrame(";
  out << "sm_handle=" << to_string(sm_handle);
  out << ", " << "sm_size=" << to_string(sm_size);
  out << ", " << "df_handle=" << to_string(df_handle);
  out << ", " << "df_size=" << to_string(df_size);
  out << ")";
}


TDBInfo::~TDBInfo() throw() {
}


void TDBInfo::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void TDBInfo::__set_db_owner(const std::string& val) {
  this->db_owner = val;
}
std::ostream& operator<<(std::ostream& out, const TDBInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDBInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_owner);
          this->__isset.db_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDBInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDBInfo");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_owner", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDBInfo &a, TDBInfo &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.db_owner, b.db_owner);
  swap(a.__isset, b.__isset);
}

TDBInfo::TDBInfo(const TDBInfo& other97) {
  db_name = other97.db_name;
  db_owner = other97.db_owner;
  __isset = other97.__isset;
}
TDBInfo& TDBInfo::operator=(const TDBInfo& other98) {
  db_name = other98.db_name;
  db_owner = other98.db_owner;
  __isset = other98.__isset;
  return *this;
}
void TDBInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDBInfo(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "db_owner=" << to_string(db_owner);
  out << ")";
}


TMapDException::~TMapDException() throw() {
}


void TMapDException::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}
std::ostream& operator<<(std::ostream& out, const TMapDException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TMapDException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMapDException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMapDException");

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMapDException &a, TMapDException &b) {
  using ::std::swap;
  swap(a.error_msg, b.error_msg);
  swap(a.__isset, b.__isset);
}

TMapDException::TMapDException(const TMapDException& other99) : TException() {
  error_msg = other99.error_msg;
  __isset = other99.__isset;
}
TMapDException& TMapDException::operator=(const TMapDException& other100) {
  error_msg = other100.error_msg;
  __isset = other100.__isset;
  return *this;
}
void TMapDException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMapDException(";
  out << "error_msg=" << to_string(error_msg);
  out << ")";
}

const char* TMapDException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TMapDException";
  }
}


TCopyParams::~TCopyParams() throw() {
}


void TCopyParams::__set_delimiter(const std::string& val) {
  this->delimiter = val;
}

void TCopyParams::__set_null_str(const std::string& val) {
  this->null_str = val;
}

void TCopyParams::__set_has_header(const TImportHeaderRow::type val) {
  this->has_header = val;
}

void TCopyParams::__set_quoted(const bool val) {
  this->quoted = val;
}

void TCopyParams::__set_quote(const std::string& val) {
  this->quote = val;
}

void TCopyParams::__set_escape(const std::string& val) {
  this->escape = val;
}

void TCopyParams::__set_line_delim(const std::string& val) {
  this->line_delim = val;
}

void TCopyParams::__set_array_delim(const std::string& val) {
  this->array_delim = val;
}

void TCopyParams::__set_array_begin(const std::string& val) {
  this->array_begin = val;
}

void TCopyParams::__set_array_end(const std::string& val) {
  this->array_end = val;
}

void TCopyParams::__set_threads(const int32_t val) {
  this->threads = val;
}

void TCopyParams::__set_file_type(const TFileType::type val) {
  this->file_type = val;
}

void TCopyParams::__set_s3_access_key(const std::string& val) {
  this->s3_access_key = val;
}

void TCopyParams::__set_s3_secret_key(const std::string& val) {
  this->s3_secret_key = val;
}

void TCopyParams::__set_s3_region(const std::string& val) {
  this->s3_region = val;
}

void TCopyParams::__set_geo_coords_encoding(const  ::TEncodingType::type val) {
  this->geo_coords_encoding = val;
}

void TCopyParams::__set_geo_coords_comp_param(const int32_t val) {
  this->geo_coords_comp_param = val;
}

void TCopyParams::__set_geo_coords_type(const  ::TDatumType::type val) {
  this->geo_coords_type = val;
}

void TCopyParams::__set_geo_coords_srid(const int32_t val) {
  this->geo_coords_srid = val;
}

void TCopyParams::__set_sanitize_column_names(const bool val) {
  this->sanitize_column_names = val;
}

void TCopyParams::__set_geo_layer_name(const std::string& val) {
  this->geo_layer_name = val;
}

void TCopyParams::__set_s3_endpoint(const std::string& val) {
  this->s3_endpoint = val;
}
std::ostream& operator<<(std::ostream& out, const TCopyParams& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCopyParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->delimiter);
          this->__isset.delimiter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->null_str);
          this->__isset.null_str = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast101;
          xfer += iprot->readI32(ecast101);
          this->has_header = (TImportHeaderRow::type)ecast101;
          this->__isset.has_header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->quoted);
          this->__isset.quoted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->quote);
          this->__isset.quote = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->escape);
          this->__isset.escape = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->line_delim);
          this->__isset.line_delim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->array_delim);
          this->__isset.array_delim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->array_begin);
          this->__isset.array_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->array_end);
          this->__isset.array_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->threads);
          this->__isset.threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast102;
          xfer += iprot->readI32(ecast102);
          this->file_type = (TFileType::type)ecast102;
          this->__isset.file_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_access_key);
          this->__isset.s3_access_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_secret_key);
          this->__isset.s3_secret_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_region);
          this->__isset.s3_region = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast103;
          xfer += iprot->readI32(ecast103);
          this->geo_coords_encoding = ( ::TEncodingType::type)ecast103;
          this->__isset.geo_coords_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->geo_coords_comp_param);
          this->__isset.geo_coords_comp_param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast104;
          xfer += iprot->readI32(ecast104);
          this->geo_coords_type = ( ::TDatumType::type)ecast104;
          this->__isset.geo_coords_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->geo_coords_srid);
          this->__isset.geo_coords_srid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sanitize_column_names);
          this->__isset.sanitize_column_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->geo_layer_name);
          this->__isset.geo_layer_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_endpoint);
          this->__isset.s3_endpoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCopyParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCopyParams");

  xfer += oprot->writeFieldBegin("delimiter", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->delimiter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("null_str", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->null_str);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_header", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->has_header);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quoted", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->quoted);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quote", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->quote);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("escape", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->escape);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("line_delim", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->line_delim);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("array_delim", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->array_delim);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("array_begin", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->array_begin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("array_end", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->array_end);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("threads", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->threads);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("file_type", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32((int32_t)this->file_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_access_key", ::apache::thrift::protocol::T_STRING, 13);
  xfer += oprot->writeString(this->s3_access_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_secret_key", ::apache::thrift::protocol::T_STRING, 14);
  xfer += oprot->writeString(this->s3_secret_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_region", ::apache::thrift::protocol::T_STRING, 15);
  xfer += oprot->writeString(this->s3_region);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_encoding", ::apache::thrift::protocol::T_I32, 16);
  xfer += oprot->writeI32((int32_t)this->geo_coords_encoding);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_comp_param", ::apache::thrift::protocol::T_I32, 17);
  xfer += oprot->writeI32(this->geo_coords_comp_param);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_type", ::apache::thrift::protocol::T_I32, 18);
  xfer += oprot->writeI32((int32_t)this->geo_coords_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_srid", ::apache::thrift::protocol::T_I32, 19);
  xfer += oprot->writeI32(this->geo_coords_srid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sanitize_column_names", ::apache::thrift::protocol::T_BOOL, 20);
  xfer += oprot->writeBool(this->sanitize_column_names);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_layer_name", ::apache::thrift::protocol::T_STRING, 21);
  xfer += oprot->writeString(this->geo_layer_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_endpoint", ::apache::thrift::protocol::T_STRING, 22);
  xfer += oprot->writeString(this->s3_endpoint);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCopyParams &a, TCopyParams &b) {
  using ::std::swap;
  swap(a.delimiter, b.delimiter);
  swap(a.null_str, b.null_str);
  swap(a.has_header, b.has_header);
  swap(a.quoted, b.quoted);
  swap(a.quote, b.quote);
  swap(a.escape, b.escape);
  swap(a.line_delim, b.line_delim);
  swap(a.array_delim, b.array_delim);
  swap(a.array_begin, b.array_begin);
  swap(a.array_end, b.array_end);
  swap(a.threads, b.threads);
  swap(a.file_type, b.file_type);
  swap(a.s3_access_key, b.s3_access_key);
  swap(a.s3_secret_key, b.s3_secret_key);
  swap(a.s3_region, b.s3_region);
  swap(a.geo_coords_encoding, b.geo_coords_encoding);
  swap(a.geo_coords_comp_param, b.geo_coords_comp_param);
  swap(a.geo_coords_type, b.geo_coords_type);
  swap(a.geo_coords_srid, b.geo_coords_srid);
  swap(a.sanitize_column_names, b.sanitize_column_names);
  swap(a.geo_layer_name, b.geo_layer_name);
  swap(a.s3_endpoint, b.s3_endpoint);
  swap(a.__isset, b.__isset);
}

TCopyParams::TCopyParams(const TCopyParams& other105) {
  delimiter = other105.delimiter;
  null_str = other105.null_str;
  has_header = other105.has_header;
  quoted = other105.quoted;
  quote = other105.quote;
  escape = other105.escape;
  line_delim = other105.line_delim;
  array_delim = other105.array_delim;
  array_begin = other105.array_begin;
  array_end = other105.array_end;
  threads = other105.threads;
  file_type = other105.file_type;
  s3_access_key = other105.s3_access_key;
  s3_secret_key = other105.s3_secret_key;
  s3_region = other105.s3_region;
  geo_coords_encoding = other105.geo_coords_encoding;
  geo_coords_comp_param = other105.geo_coords_comp_param;
  geo_coords_type = other105.geo_coords_type;
  geo_coords_srid = other105.geo_coords_srid;
  sanitize_column_names = other105.sanitize_column_names;
  geo_layer_name = other105.geo_layer_name;
  s3_endpoint = other105.s3_endpoint;
  __isset = other105.__isset;
}
TCopyParams& TCopyParams::operator=(const TCopyParams& other106) {
  delimiter = other106.delimiter;
  null_str = other106.null_str;
  has_header = other106.has_header;
  quoted = other106.quoted;
  quote = other106.quote;
  escape = other106.escape;
  line_delim = other106.line_delim;
  array_delim = other106.array_delim;
  array_begin = other106.array_begin;
  array_end = other106.array_end;
  threads = other106.threads;
  file_type = other106.file_type;
  s3_access_key = other106.s3_access_key;
  s3_secret_key = other106.s3_secret_key;
  s3_region = other106.s3_region;
  geo_coords_encoding = other106.geo_coords_encoding;
  geo_coords_comp_param = other106.geo_coords_comp_param;
  geo_coords_type = other106.geo_coords_type;
  geo_coords_srid = other106.geo_coords_srid;
  sanitize_column_names = other106.sanitize_column_names;
  geo_layer_name = other106.geo_layer_name;
  s3_endpoint = other106.s3_endpoint;
  __isset = other106.__isset;
  return *this;
}
void TCopyParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCopyParams(";
  out << "delimiter=" << to_string(delimiter);
  out << ", " << "null_str=" << to_string(null_str);
  out << ", " << "has_header=" << to_string(has_header);
  out << ", " << "quoted=" << to_string(quoted);
  out << ", " << "quote=" << to_string(quote);
  out << ", " << "escape=" << to_string(escape);
  out << ", " << "line_delim=" << to_string(line_delim);
  out << ", " << "array_delim=" << to_string(array_delim);
  out << ", " << "array_begin=" << to_string(array_begin);
  out << ", " << "array_end=" << to_string(array_end);
  out << ", " << "threads=" << to_string(threads);
  out << ", " << "file_type=" << to_string(file_type);
  out << ", " << "s3_access_key=" << to_string(s3_access_key);
  out << ", " << "s3_secret_key=" << to_string(s3_secret_key);
  out << ", " << "s3_region=" << to_string(s3_region);
  out << ", " << "geo_coords_encoding=" << to_string(geo_coords_encoding);
  out << ", " << "geo_coords_comp_param=" << to_string(geo_coords_comp_param);
  out << ", " << "geo_coords_type=" << to_string(geo_coords_type);
  out << ", " << "geo_coords_srid=" << to_string(geo_coords_srid);
  out << ", " << "sanitize_column_names=" << to_string(sanitize_column_names);
  out << ", " << "geo_layer_name=" << to_string(geo_layer_name);
  out << ", " << "s3_endpoint=" << to_string(s3_endpoint);
  out << ")";
}


TCreateParams::~TCreateParams() throw() {
}


void TCreateParams::__set_is_replicated(const bool val) {
  this->is_replicated = val;
}
std::ostream& operator<<(std::ostream& out, const TCreateParams& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCreateParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_replicated);
          this->__isset.is_replicated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCreateParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCreateParams");

  xfer += oprot->writeFieldBegin("is_replicated", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_replicated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCreateParams &a, TCreateParams &b) {
  using ::std::swap;
  swap(a.is_replicated, b.is_replicated);
  swap(a.__isset, b.__isset);
}

TCreateParams::TCreateParams(const TCreateParams& other107) {
  is_replicated = other107.is_replicated;
  __isset = other107.__isset;
}
TCreateParams& TCreateParams::operator=(const TCreateParams& other108) {
  is_replicated = other108.is_replicated;
  __isset = other108.__isset;
  return *this;
}
void TCreateParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCreateParams(";
  out << "is_replicated=" << to_string(is_replicated);
  out << ")";
}


TDetectResult::~TDetectResult() throw() {
}


void TDetectResult::__set_row_set(const TRowSet& val) {
  this->row_set = val;
}

void TDetectResult::__set_copy_params(const TCopyParams& val) {
  this->copy_params = val;
}
std::ostream& operator<<(std::ostream& out, const TDetectResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDetectResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_set.read(iprot);
          this->__isset.row_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->copy_params.read(iprot);
          this->__isset.copy_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDetectResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDetectResult");

  xfer += oprot->writeFieldBegin("row_set", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->row_set.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("copy_params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->copy_params.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDetectResult &a, TDetectResult &b) {
  using ::std::swap;
  swap(a.row_set, b.row_set);
  swap(a.copy_params, b.copy_params);
  swap(a.__isset, b.__isset);
}

TDetectResult::TDetectResult(const TDetectResult& other109) {
  row_set = other109.row_set;
  copy_params = other109.copy_params;
  __isset = other109.__isset;
}
TDetectResult& TDetectResult::operator=(const TDetectResult& other110) {
  row_set = other110.row_set;
  copy_params = other110.copy_params;
  __isset = other110.__isset;
  return *this;
}
void TDetectResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDetectResult(";
  out << "row_set=" << to_string(row_set);
  out << ", " << "copy_params=" << to_string(copy_params);
  out << ")";
}


TImportStatus::~TImportStatus() throw() {
}


void TImportStatus::__set_elapsed(const int64_t val) {
  this->elapsed = val;
}

void TImportStatus::__set_rows_completed(const int64_t val) {
  this->rows_completed = val;
}

void TImportStatus::__set_rows_estimated(const int64_t val) {
  this->rows_estimated = val;
}

void TImportStatus::__set_rows_rejected(const int64_t val) {
  this->rows_rejected = val;
}
std::ostream& operator<<(std::ostream& out, const TImportStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TImportStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->elapsed);
          this->__isset.elapsed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows_completed);
          this->__isset.rows_completed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows_estimated);
          this->__isset.rows_estimated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows_rejected);
          this->__isset.rows_rejected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TImportStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TImportStatus");

  xfer += oprot->writeFieldBegin("elapsed", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->elapsed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows_completed", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->rows_completed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows_estimated", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->rows_estimated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows_rejected", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->rows_rejected);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TImportStatus &a, TImportStatus &b) {
  using ::std::swap;
  swap(a.elapsed, b.elapsed);
  swap(a.rows_completed, b.rows_completed);
  swap(a.rows_estimated, b.rows_estimated);
  swap(a.rows_rejected, b.rows_rejected);
  swap(a.__isset, b.__isset);
}

TImportStatus::TImportStatus(const TImportStatus& other111) {
  elapsed = other111.elapsed;
  rows_completed = other111.rows_completed;
  rows_estimated = other111.rows_estimated;
  rows_rejected = other111.rows_rejected;
  __isset = other111.__isset;
}
TImportStatus& TImportStatus::operator=(const TImportStatus& other112) {
  elapsed = other112.elapsed;
  rows_completed = other112.rows_completed;
  rows_estimated = other112.rows_estimated;
  rows_rejected = other112.rows_rejected;
  __isset = other112.__isset;
  return *this;
}
void TImportStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TImportStatus(";
  out << "elapsed=" << to_string(elapsed);
  out << ", " << "rows_completed=" << to_string(rows_completed);
  out << ", " << "rows_estimated=" << to_string(rows_estimated);
  out << ", " << "rows_rejected=" << to_string(rows_rejected);
  out << ")";
}


TFrontendView::~TFrontendView() throw() {
}


void TFrontendView::__set_view_name(const std::string& val) {
  this->view_name = val;
}

void TFrontendView::__set_view_state(const std::string& val) {
  this->view_state = val;
}

void TFrontendView::__set_image_hash(const std::string& val) {
  this->image_hash = val;
}

void TFrontendView::__set_update_time(const std::string& val) {
  this->update_time = val;
}

void TFrontendView::__set_view_metadata(const std::string& val) {
  this->view_metadata = val;
}
std::ostream& operator<<(std::ostream& out, const TFrontendView& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TFrontendView::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_name);
          this->__isset.view_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_state);
          this->__isset.view_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->image_hash);
          this->__isset.image_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->update_time);
          this->__isset.update_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_metadata);
          this->__isset.view_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TFrontendView::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFrontendView");

  xfer += oprot->writeFieldBegin("view_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->view_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_state", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->view_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("image_hash", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->image_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_time", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->update_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_metadata", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->view_metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFrontendView &a, TFrontendView &b) {
  using ::std::swap;
  swap(a.view_name, b.view_name);
  swap(a.view_state, b.view_state);
  swap(a.image_hash, b.image_hash);
  swap(a.update_time, b.update_time);
  swap(a.view_metadata, b.view_metadata);
  swap(a.__isset, b.__isset);
}

TFrontendView::TFrontendView(const TFrontendView& other113) {
  view_name = other113.view_name;
  view_state = other113.view_state;
  image_hash = other113.image_hash;
  update_time = other113.update_time;
  view_metadata = other113.view_metadata;
  __isset = other113.__isset;
}
TFrontendView& TFrontendView::operator=(const TFrontendView& other114) {
  view_name = other114.view_name;
  view_state = other114.view_state;
  image_hash = other114.image_hash;
  update_time = other114.update_time;
  view_metadata = other114.view_metadata;
  __isset = other114.__isset;
  return *this;
}
void TFrontendView::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFrontendView(";
  out << "view_name=" << to_string(view_name);
  out << ", " << "view_state=" << to_string(view_state);
  out << ", " << "image_hash=" << to_string(image_hash);
  out << ", " << "update_time=" << to_string(update_time);
  out << ", " << "view_metadata=" << to_string(view_metadata);
  out << ")";
}


TDashboard::~TDashboard() throw() {
}


void TDashboard::__set_dashboard_name(const std::string& val) {
  this->dashboard_name = val;
}

void TDashboard::__set_dashboard_state(const std::string& val) {
  this->dashboard_state = val;
}

void TDashboard::__set_image_hash(const std::string& val) {
  this->image_hash = val;
}

void TDashboard::__set_update_time(const std::string& val) {
  this->update_time = val;
}

void TDashboard::__set_dashboard_metadata(const std::string& val) {
  this->dashboard_metadata = val;
}

void TDashboard::__set_dashboard_id(const int32_t val) {
  this->dashboard_id = val;
}

void TDashboard::__set_dashboard_owner(const std::string& val) {
  this->dashboard_owner = val;
}

void TDashboard::__set_is_dash_shared(const bool val) {
  this->is_dash_shared = val;
}
std::ostream& operator<<(std::ostream& out, const TDashboard& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDashboard::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_name);
          this->__isset.dashboard_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_state);
          this->__isset.dashboard_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->image_hash);
          this->__isset.image_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->update_time);
          this->__isset.update_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_metadata);
          this->__isset.dashboard_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dashboard_id);
          this->__isset.dashboard_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_owner);
          this->__isset.dashboard_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_dash_shared);
          this->__isset.is_dash_shared = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDashboard::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDashboard");

  xfer += oprot->writeFieldBegin("dashboard_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dashboard_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_state", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dashboard_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("image_hash", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->image_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_time", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->update_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_metadata", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->dashboard_metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_id", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->dashboard_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_owner", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->dashboard_owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_dash_shared", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->is_dash_shared);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDashboard &a, TDashboard &b) {
  using ::std::swap;
  swap(a.dashboard_name, b.dashboard_name);
  swap(a.dashboard_state, b.dashboard_state);
  swap(a.image_hash, b.image_hash);
  swap(a.update_time, b.update_time);
  swap(a.dashboard_metadata, b.dashboard_metadata);
  swap(a.dashboard_id, b.dashboard_id);
  swap(a.dashboard_owner, b.dashboard_owner);
  swap(a.is_dash_shared, b.is_dash_shared);
  swap(a.__isset, b.__isset);
}

TDashboard::TDashboard(const TDashboard& other115) {
  dashboard_name = other115.dashboard_name;
  dashboard_state = other115.dashboard_state;
  image_hash = other115.image_hash;
  update_time = other115.update_time;
  dashboard_metadata = other115.dashboard_metadata;
  dashboard_id = other115.dashboard_id;
  dashboard_owner = other115.dashboard_owner;
  is_dash_shared = other115.is_dash_shared;
  __isset = other115.__isset;
}
TDashboard& TDashboard::operator=(const TDashboard& other116) {
  dashboard_name = other116.dashboard_name;
  dashboard_state = other116.dashboard_state;
  image_hash = other116.image_hash;
  update_time = other116.update_time;
  dashboard_metadata = other116.dashboard_metadata;
  dashboard_id = other116.dashboard_id;
  dashboard_owner = other116.dashboard_owner;
  is_dash_shared = other116.is_dash_shared;
  __isset = other116.__isset;
  return *this;
}
void TDashboard::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDashboard(";
  out << "dashboard_name=" << to_string(dashboard_name);
  out << ", " << "dashboard_state=" << to_string(dashboard_state);
  out << ", " << "image_hash=" << to_string(image_hash);
  out << ", " << "update_time=" << to_string(update_time);
  out << ", " << "dashboard_metadata=" << to_string(dashboard_metadata);
  out << ", " << "dashboard_id=" << to_string(dashboard_id);
  out << ", " << "dashboard_owner=" << to_string(dashboard_owner);
  out << ", " << "is_dash_shared=" << to_string(is_dash_shared);
  out << ")";
}


TServerStatus::~TServerStatus() throw() {
}


void TServerStatus::__set_read_only(const bool val) {
  this->read_only = val;
}

void TServerStatus::__set_version(const std::string& val) {
  this->version = val;
}

void TServerStatus::__set_rendering_enabled(const bool val) {
  this->rendering_enabled = val;
}

void TServerStatus::__set_start_time(const int64_t val) {
  this->start_time = val;
}

void TServerStatus::__set_edition(const std::string& val) {
  this->edition = val;
}

void TServerStatus::__set_host_name(const std::string& val) {
  this->host_name = val;
}

void TServerStatus::__set_poly_rendering_enabled(const bool val) {
  this->poly_rendering_enabled = val;
}

void TServerStatus::__set_role(const TRole::type val) {
  this->role = val;
}
std::ostream& operator<<(std::ostream& out, const TServerStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TServerStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->read_only);
          this->__isset.read_only = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rendering_enabled);
          this->__isset.rendering_enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_time);
          this->__isset.start_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->edition);
          this->__isset.edition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->poly_rendering_enabled);
          this->__isset.poly_rendering_enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast117;
          xfer += iprot->readI32(ecast117);
          this->role = (TRole::type)ecast117;
          this->__isset.role = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TServerStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TServerStatus");

  xfer += oprot->writeFieldBegin("read_only", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->read_only);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rendering_enabled", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->rendering_enabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_time", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->start_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("edition", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->edition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->host_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("poly_rendering_enabled", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->poly_rendering_enabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("role", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32((int32_t)this->role);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TServerStatus &a, TServerStatus &b) {
  using ::std::swap;
  swap(a.read_only, b.read_only);
  swap(a.version, b.version);
  swap(a.rendering_enabled, b.rendering_enabled);
  swap(a.start_time, b.start_time);
  swap(a.edition, b.edition);
  swap(a.host_name, b.host_name);
  swap(a.poly_rendering_enabled, b.poly_rendering_enabled);
  swap(a.role, b.role);
  swap(a.__isset, b.__isset);
}

TServerStatus::TServerStatus(const TServerStatus& other118) {
  read_only = other118.read_only;
  version = other118.version;
  rendering_enabled = other118.rendering_enabled;
  start_time = other118.start_time;
  edition = other118.edition;
  host_name = other118.host_name;
  poly_rendering_enabled = other118.poly_rendering_enabled;
  role = other118.role;
  __isset = other118.__isset;
}
TServerStatus& TServerStatus::operator=(const TServerStatus& other119) {
  read_only = other119.read_only;
  version = other119.version;
  rendering_enabled = other119.rendering_enabled;
  start_time = other119.start_time;
  edition = other119.edition;
  host_name = other119.host_name;
  poly_rendering_enabled = other119.poly_rendering_enabled;
  role = other119.role;
  __isset = other119.__isset;
  return *this;
}
void TServerStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TServerStatus(";
  out << "read_only=" << to_string(read_only);
  out << ", " << "version=" << to_string(version);
  out << ", " << "rendering_enabled=" << to_string(rendering_enabled);
  out << ", " << "start_time=" << to_string(start_time);
  out << ", " << "edition=" << to_string(edition);
  out << ", " << "host_name=" << to_string(host_name);
  out << ", " << "poly_rendering_enabled=" << to_string(poly_rendering_enabled);
  out << ", " << "role=" << to_string(role);
  out << ")";
}


TPixel::~TPixel() throw() {
}


void TPixel::__set_x(const int64_t val) {
  this->x = val;
}

void TPixel::__set_y(const int64_t val) {
  this->y = val;
}
std::ostream& operator<<(std::ostream& out, const TPixel& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPixel::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPixel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPixel");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPixel &a, TPixel &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.__isset, b.__isset);
}

TPixel::TPixel(const TPixel& other120) {
  x = other120.x;
  y = other120.y;
  __isset = other120.__isset;
}
TPixel& TPixel::operator=(const TPixel& other121) {
  x = other121.x;
  y = other121.y;
  __isset = other121.__isset;
  return *this;
}
void TPixel::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPixel(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ")";
}


TPixelTableRowResult::~TPixelTableRowResult() throw() {
}


void TPixelTableRowResult::__set_pixel(const TPixel& val) {
  this->pixel = val;
}

void TPixelTableRowResult::__set_vega_table_name(const std::string& val) {
  this->vega_table_name = val;
}

void TPixelTableRowResult::__set_table_id(const std::vector<int64_t> & val) {
  this->table_id = val;
}

void TPixelTableRowResult::__set_row_id(const std::vector<int64_t> & val) {
  this->row_id = val;
}

void TPixelTableRowResult::__set_row_set(const TRowSet& val) {
  this->row_set = val;
}

void TPixelTableRowResult::__set_nonce(const std::string& val) {
  this->nonce = val;
}
std::ostream& operator<<(std::ostream& out, const TPixelTableRowResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPixelTableRowResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pixel.read(iprot);
          this->__isset.pixel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vega_table_name);
          this->__isset.vega_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->table_id.clear();
            uint32_t _size122;
            ::apache::thrift::protocol::TType _etype125;
            xfer += iprot->readListBegin(_etype125, _size122);
            this->table_id.resize(_size122);
            uint32_t _i126;
            for (_i126 = 0; _i126 < _size122; ++_i126)
            {
              xfer += iprot->readI64(this->table_id[_i126]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_id.clear();
            uint32_t _size127;
            ::apache::thrift::protocol::TType _etype130;
            xfer += iprot->readListBegin(_etype130, _size127);
            this->row_id.resize(_size127);
            uint32_t _i131;
            for (_i131 = 0; _i131 < _size127; ++_i131)
            {
              xfer += iprot->readI64(this->row_id[_i131]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_set.read(iprot);
          this->__isset.row_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          this->__isset.nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPixelTableRowResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPixelTableRowResult");

  xfer += oprot->writeFieldBegin("pixel", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pixel.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vega_table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->vega_table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->table_id.size()));
    std::vector<int64_t> ::const_iterator _iter132;
    for (_iter132 = this->table_id.begin(); _iter132 != this->table_id.end(); ++_iter132)
    {
      xfer += oprot->writeI64((*_iter132));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_id", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->row_id.size()));
    std::vector<int64_t> ::const_iterator _iter133;
    for (_iter133 = this->row_id.begin(); _iter133 != this->row_id.end(); ++_iter133)
    {
      xfer += oprot->writeI64((*_iter133));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_set", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->row_set.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPixelTableRowResult &a, TPixelTableRowResult &b) {
  using ::std::swap;
  swap(a.pixel, b.pixel);
  swap(a.vega_table_name, b.vega_table_name);
  swap(a.table_id, b.table_id);
  swap(a.row_id, b.row_id);
  swap(a.row_set, b.row_set);
  swap(a.nonce, b.nonce);
  swap(a.__isset, b.__isset);
}

TPixelTableRowResult::TPixelTableRowResult(const TPixelTableRowResult& other134) {
  pixel = other134.pixel;
  vega_table_name = other134.vega_table_name;
  table_id = other134.table_id;
  row_id = other134.row_id;
  row_set = other134.row_set;
  nonce = other134.nonce;
  __isset = other134.__isset;
}
TPixelTableRowResult& TPixelTableRowResult::operator=(const TPixelTableRowResult& other135) {
  pixel = other135.pixel;
  vega_table_name = other135.vega_table_name;
  table_id = other135.table_id;
  row_id = other135.row_id;
  row_set = other135.row_set;
  nonce = other135.nonce;
  __isset = other135.__isset;
  return *this;
}
void TPixelTableRowResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPixelTableRowResult(";
  out << "pixel=" << to_string(pixel);
  out << ", " << "vega_table_name=" << to_string(vega_table_name);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "row_id=" << to_string(row_id);
  out << ", " << "row_set=" << to_string(row_set);
  out << ", " << "nonce=" << to_string(nonce);
  out << ")";
}


TRenderResult::~TRenderResult() throw() {
}


void TRenderResult::__set_image(const std::string& val) {
  this->image = val;
}

void TRenderResult::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void TRenderResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TRenderResult::__set_render_time_ms(const int64_t val) {
  this->render_time_ms = val;
}

void TRenderResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}

void TRenderResult::__set_vega_metadata(const std::string& val) {
  this->vega_metadata = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->image);
          this->__isset.image = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          this->__isset.nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->render_time_ms);
          this->__isset.render_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vega_metadata);
          this->__isset.vega_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderResult");

  xfer += oprot->writeFieldBegin("image", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->image);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_time_ms", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->render_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vega_metadata", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->vega_metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderResult &a, TRenderResult &b) {
  using ::std::swap;
  swap(a.image, b.image);
  swap(a.nonce, b.nonce);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.render_time_ms, b.render_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.vega_metadata, b.vega_metadata);
  swap(a.__isset, b.__isset);
}

TRenderResult::TRenderResult(const TRenderResult& other136) {
  image = other136.image;
  nonce = other136.nonce;
  execution_time_ms = other136.execution_time_ms;
  render_time_ms = other136.render_time_ms;
  total_time_ms = other136.total_time_ms;
  vega_metadata = other136.vega_metadata;
  __isset = other136.__isset;
}
TRenderResult& TRenderResult::operator=(const TRenderResult& other137) {
  image = other137.image;
  nonce = other137.nonce;
  execution_time_ms = other137.execution_time_ms;
  render_time_ms = other137.render_time_ms;
  total_time_ms = other137.total_time_ms;
  vega_metadata = other137.vega_metadata;
  __isset = other137.__isset;
  return *this;
}
void TRenderResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderResult(";
  out << "image=" << to_string(image);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "render_time_ms=" << to_string(render_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ", " << "vega_metadata=" << to_string(vega_metadata);
  out << ")";
}


TGpuSpecification::~TGpuSpecification() throw() {
}


void TGpuSpecification::__set_num_sm(const int32_t val) {
  this->num_sm = val;
}

void TGpuSpecification::__set_clock_frequency_kHz(const int64_t val) {
  this->clock_frequency_kHz = val;
}

void TGpuSpecification::__set_memory(const int64_t val) {
  this->memory = val;
}

void TGpuSpecification::__set_compute_capability_major(const int16_t val) {
  this->compute_capability_major = val;
}

void TGpuSpecification::__set_compute_capability_minor(const int16_t val) {
  this->compute_capability_minor = val;
}
std::ostream& operator<<(std::ostream& out, const TGpuSpecification& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGpuSpecification::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_sm);
          this->__isset.num_sm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->clock_frequency_kHz);
          this->__isset.clock_frequency_kHz = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->memory);
          this->__isset.memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->compute_capability_major);
          this->__isset.compute_capability_major = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->compute_capability_minor);
          this->__isset.compute_capability_minor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGpuSpecification::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGpuSpecification");

  xfer += oprot->writeFieldBegin("num_sm", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num_sm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("clock_frequency_kHz", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->clock_frequency_kHz);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("memory", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->memory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compute_capability_major", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->compute_capability_major);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compute_capability_minor", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->compute_capability_minor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGpuSpecification &a, TGpuSpecification &b) {
  using ::std::swap;
  swap(a.num_sm, b.num_sm);
  swap(a.clock_frequency_kHz, b.clock_frequency_kHz);
  swap(a.memory, b.memory);
  swap(a.compute_capability_major, b.compute_capability_major);
  swap(a.compute_capability_minor, b.compute_capability_minor);
  swap(a.__isset, b.__isset);
}

TGpuSpecification::TGpuSpecification(const TGpuSpecification& other138) {
  num_sm = other138.num_sm;
  clock_frequency_kHz = other138.clock_frequency_kHz;
  memory = other138.memory;
  compute_capability_major = other138.compute_capability_major;
  compute_capability_minor = other138.compute_capability_minor;
  __isset = other138.__isset;
}
TGpuSpecification& TGpuSpecification::operator=(const TGpuSpecification& other139) {
  num_sm = other139.num_sm;
  clock_frequency_kHz = other139.clock_frequency_kHz;
  memory = other139.memory;
  compute_capability_major = other139.compute_capability_major;
  compute_capability_minor = other139.compute_capability_minor;
  __isset = other139.__isset;
  return *this;
}
void TGpuSpecification::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGpuSpecification(";
  out << "num_sm=" << to_string(num_sm);
  out << ", " << "clock_frequency_kHz=" << to_string(clock_frequency_kHz);
  out << ", " << "memory=" << to_string(memory);
  out << ", " << "compute_capability_major=" << to_string(compute_capability_major);
  out << ", " << "compute_capability_minor=" << to_string(compute_capability_minor);
  out << ")";
}


THardwareInfo::~THardwareInfo() throw() {
}


void THardwareInfo::__set_num_gpu_hw(const int16_t val) {
  this->num_gpu_hw = val;
}

void THardwareInfo::__set_num_cpu_hw(const int16_t val) {
  this->num_cpu_hw = val;
}

void THardwareInfo::__set_num_gpu_allocated(const int16_t val) {
  this->num_gpu_allocated = val;
}

void THardwareInfo::__set_start_gpu(const int16_t val) {
  this->start_gpu = val;
}

void THardwareInfo::__set_host_name(const std::string& val) {
  this->host_name = val;
}

void THardwareInfo::__set_gpu_info(const std::vector<TGpuSpecification> & val) {
  this->gpu_info = val;
}
std::ostream& operator<<(std::ostream& out, const THardwareInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t THardwareInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->num_gpu_hw);
          this->__isset.num_gpu_hw = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->num_cpu_hw);
          this->__isset.num_cpu_hw = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->num_gpu_allocated);
          this->__isset.num_gpu_allocated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->start_gpu);
          this->__isset.start_gpu = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->gpu_info.clear();
            uint32_t _size140;
            ::apache::thrift::protocol::TType _etype143;
            xfer += iprot->readListBegin(_etype143, _size140);
            this->gpu_info.resize(_size140);
            uint32_t _i144;
            for (_i144 = 0; _i144 < _size140; ++_i144)
            {
              xfer += this->gpu_info[_i144].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.gpu_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t THardwareInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THardwareInfo");

  xfer += oprot->writeFieldBegin("num_gpu_hw", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->num_gpu_hw);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_cpu_hw", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->num_cpu_hw);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_gpu_allocated", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->num_gpu_allocated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_gpu", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->start_gpu);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->host_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gpu_info", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->gpu_info.size()));
    std::vector<TGpuSpecification> ::const_iterator _iter145;
    for (_iter145 = this->gpu_info.begin(); _iter145 != this->gpu_info.end(); ++_iter145)
    {
      xfer += (*_iter145).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THardwareInfo &a, THardwareInfo &b) {
  using ::std::swap;
  swap(a.num_gpu_hw, b.num_gpu_hw);
  swap(a.num_cpu_hw, b.num_cpu_hw);
  swap(a.num_gpu_allocated, b.num_gpu_allocated);
  swap(a.start_gpu, b.start_gpu);
  swap(a.host_name, b.host_name);
  swap(a.gpu_info, b.gpu_info);
  swap(a.__isset, b.__isset);
}

THardwareInfo::THardwareInfo(const THardwareInfo& other146) {
  num_gpu_hw = other146.num_gpu_hw;
  num_cpu_hw = other146.num_cpu_hw;
  num_gpu_allocated = other146.num_gpu_allocated;
  start_gpu = other146.start_gpu;
  host_name = other146.host_name;
  gpu_info = other146.gpu_info;
  __isset = other146.__isset;
}
THardwareInfo& THardwareInfo::operator=(const THardwareInfo& other147) {
  num_gpu_hw = other147.num_gpu_hw;
  num_cpu_hw = other147.num_cpu_hw;
  num_gpu_allocated = other147.num_gpu_allocated;
  start_gpu = other147.start_gpu;
  host_name = other147.host_name;
  gpu_info = other147.gpu_info;
  __isset = other147.__isset;
  return *this;
}
void THardwareInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THardwareInfo(";
  out << "num_gpu_hw=" << to_string(num_gpu_hw);
  out << ", " << "num_cpu_hw=" << to_string(num_cpu_hw);
  out << ", " << "num_gpu_allocated=" << to_string(num_gpu_allocated);
  out << ", " << "start_gpu=" << to_string(start_gpu);
  out << ", " << "host_name=" << to_string(host_name);
  out << ", " << "gpu_info=" << to_string(gpu_info);
  out << ")";
}


TClusterHardwareInfo::~TClusterHardwareInfo() throw() {
}


void TClusterHardwareInfo::__set_hardware_info(const std::vector<THardwareInfo> & val) {
  this->hardware_info = val;
}
std::ostream& operator<<(std::ostream& out, const TClusterHardwareInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TClusterHardwareInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->hardware_info.clear();
            uint32_t _size148;
            ::apache::thrift::protocol::TType _etype151;
            xfer += iprot->readListBegin(_etype151, _size148);
            this->hardware_info.resize(_size148);
            uint32_t _i152;
            for (_i152 = 0; _i152 < _size148; ++_i152)
            {
              xfer += this->hardware_info[_i152].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.hardware_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TClusterHardwareInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TClusterHardwareInfo");

  xfer += oprot->writeFieldBegin("hardware_info", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->hardware_info.size()));
    std::vector<THardwareInfo> ::const_iterator _iter153;
    for (_iter153 = this->hardware_info.begin(); _iter153 != this->hardware_info.end(); ++_iter153)
    {
      xfer += (*_iter153).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TClusterHardwareInfo &a, TClusterHardwareInfo &b) {
  using ::std::swap;
  swap(a.hardware_info, b.hardware_info);
  swap(a.__isset, b.__isset);
}

TClusterHardwareInfo::TClusterHardwareInfo(const TClusterHardwareInfo& other154) {
  hardware_info = other154.hardware_info;
  __isset = other154.__isset;
}
TClusterHardwareInfo& TClusterHardwareInfo::operator=(const TClusterHardwareInfo& other155) {
  hardware_info = other155.hardware_info;
  __isset = other155.__isset;
  return *this;
}
void TClusterHardwareInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TClusterHardwareInfo(";
  out << "hardware_info=" << to_string(hardware_info);
  out << ")";
}


TMemoryData::~TMemoryData() throw() {
}


void TMemoryData::__set_slab(const int64_t val) {
  this->slab = val;
}

void TMemoryData::__set_start_page(const int32_t val) {
  this->start_page = val;
}

void TMemoryData::__set_num_pages(const int64_t val) {
  this->num_pages = val;
}

void TMemoryData::__set_touch(const int32_t val) {
  this->touch = val;
}

void TMemoryData::__set_chunk_key(const std::vector<int64_t> & val) {
  this->chunk_key = val;
}

void TMemoryData::__set_buffer_epoch(const int32_t val) {
  this->buffer_epoch = val;
}

void TMemoryData::__set_is_free(const bool val) {
  this->is_free = val;
}
std::ostream& operator<<(std::ostream& out, const TMemoryData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TMemoryData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->slab);
          this->__isset.slab = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->start_page);
          this->__isset.start_page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_pages);
          this->__isset.num_pages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->touch);
          this->__isset.touch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->chunk_key.clear();
            uint32_t _size156;
            ::apache::thrift::protocol::TType _etype159;
            xfer += iprot->readListBegin(_etype159, _size156);
            this->chunk_key.resize(_size156);
            uint32_t _i160;
            for (_i160 = 0; _i160 < _size156; ++_i160)
            {
              xfer += iprot->readI64(this->chunk_key[_i160]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.chunk_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->buffer_epoch);
          this->__isset.buffer_epoch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_free);
          this->__isset.is_free = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMemoryData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMemoryData");

  xfer += oprot->writeFieldBegin("slab", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->slab);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_page", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->start_page);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_pages", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->num_pages);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("touch", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->touch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("chunk_key", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->chunk_key.size()));
    std::vector<int64_t> ::const_iterator _iter161;
    for (_iter161 = this->chunk_key.begin(); _iter161 != this->chunk_key.end(); ++_iter161)
    {
      xfer += oprot->writeI64((*_iter161));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("buffer_epoch", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->buffer_epoch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_free", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->is_free);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMemoryData &a, TMemoryData &b) {
  using ::std::swap;
  swap(a.slab, b.slab);
  swap(a.start_page, b.start_page);
  swap(a.num_pages, b.num_pages);
  swap(a.touch, b.touch);
  swap(a.chunk_key, b.chunk_key);
  swap(a.buffer_epoch, b.buffer_epoch);
  swap(a.is_free, b.is_free);
  swap(a.__isset, b.__isset);
}

TMemoryData::TMemoryData(const TMemoryData& other162) {
  slab = other162.slab;
  start_page = other162.start_page;
  num_pages = other162.num_pages;
  touch = other162.touch;
  chunk_key = other162.chunk_key;
  buffer_epoch = other162.buffer_epoch;
  is_free = other162.is_free;
  __isset = other162.__isset;
}
TMemoryData& TMemoryData::operator=(const TMemoryData& other163) {
  slab = other163.slab;
  start_page = other163.start_page;
  num_pages = other163.num_pages;
  touch = other163.touch;
  chunk_key = other163.chunk_key;
  buffer_epoch = other163.buffer_epoch;
  is_free = other163.is_free;
  __isset = other163.__isset;
  return *this;
}
void TMemoryData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMemoryData(";
  out << "slab=" << to_string(slab);
  out << ", " << "start_page=" << to_string(start_page);
  out << ", " << "num_pages=" << to_string(num_pages);
  out << ", " << "touch=" << to_string(touch);
  out << ", " << "chunk_key=" << to_string(chunk_key);
  out << ", " << "buffer_epoch=" << to_string(buffer_epoch);
  out << ", " << "is_free=" << to_string(is_free);
  out << ")";
}


TNodeMemoryInfo::~TNodeMemoryInfo() throw() {
}


void TNodeMemoryInfo::__set_host_name(const std::string& val) {
  this->host_name = val;
}

void TNodeMemoryInfo::__set_page_size(const int64_t val) {
  this->page_size = val;
}

void TNodeMemoryInfo::__set_max_num_pages(const int64_t val) {
  this->max_num_pages = val;
}

void TNodeMemoryInfo::__set_num_pages_allocated(const int64_t val) {
  this->num_pages_allocated = val;
}

void TNodeMemoryInfo::__set_is_allocation_capped(const bool val) {
  this->is_allocation_capped = val;
}

void TNodeMemoryInfo::__set_node_memory_data(const std::vector<TMemoryData> & val) {
  this->node_memory_data = val;
}
std::ostream& operator<<(std::ostream& out, const TNodeMemoryInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TNodeMemoryInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->page_size);
          this->__isset.page_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_num_pages);
          this->__isset.max_num_pages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_pages_allocated);
          this->__isset.num_pages_allocated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_allocation_capped);
          this->__isset.is_allocation_capped = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->node_memory_data.clear();
            uint32_t _size164;
            ::apache::thrift::protocol::TType _etype167;
            xfer += iprot->readListBegin(_etype167, _size164);
            this->node_memory_data.resize(_size164);
            uint32_t _i168;
            for (_i168 = 0; _i168 < _size164; ++_i168)
            {
              xfer += this->node_memory_data[_i168].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.node_memory_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TNodeMemoryInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TNodeMemoryInfo");

  xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("page_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->page_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_num_pages", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->max_num_pages);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_pages_allocated", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->num_pages_allocated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_allocation_capped", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_allocation_capped);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_memory_data", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->node_memory_data.size()));
    std::vector<TMemoryData> ::const_iterator _iter169;
    for (_iter169 = this->node_memory_data.begin(); _iter169 != this->node_memory_data.end(); ++_iter169)
    {
      xfer += (*_iter169).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TNodeMemoryInfo &a, TNodeMemoryInfo &b) {
  using ::std::swap;
  swap(a.host_name, b.host_name);
  swap(a.page_size, b.page_size);
  swap(a.max_num_pages, b.max_num_pages);
  swap(a.num_pages_allocated, b.num_pages_allocated);
  swap(a.is_allocation_capped, b.is_allocation_capped);
  swap(a.node_memory_data, b.node_memory_data);
  swap(a.__isset, b.__isset);
}

TNodeMemoryInfo::TNodeMemoryInfo(const TNodeMemoryInfo& other170) {
  host_name = other170.host_name;
  page_size = other170.page_size;
  max_num_pages = other170.max_num_pages;
  num_pages_allocated = other170.num_pages_allocated;
  is_allocation_capped = other170.is_allocation_capped;
  node_memory_data = other170.node_memory_data;
  __isset = other170.__isset;
}
TNodeMemoryInfo& TNodeMemoryInfo::operator=(const TNodeMemoryInfo& other171) {
  host_name = other171.host_name;
  page_size = other171.page_size;
  max_num_pages = other171.max_num_pages;
  num_pages_allocated = other171.num_pages_allocated;
  is_allocation_capped = other171.is_allocation_capped;
  node_memory_data = other171.node_memory_data;
  __isset = other171.__isset;
  return *this;
}
void TNodeMemoryInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TNodeMemoryInfo(";
  out << "host_name=" << to_string(host_name);
  out << ", " << "page_size=" << to_string(page_size);
  out << ", " << "max_num_pages=" << to_string(max_num_pages);
  out << ", " << "num_pages_allocated=" << to_string(num_pages_allocated);
  out << ", " << "is_allocation_capped=" << to_string(is_allocation_capped);
  out << ", " << "node_memory_data=" << to_string(node_memory_data);
  out << ")";
}


TTableMeta::~TTableMeta() throw() {
}


void TTableMeta::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void TTableMeta::__set_num_cols(const int64_t val) {
  this->num_cols = val;
}

void TTableMeta::__set_col_datum_types(const std::vector< ::TDatumType::type> & val) {
  this->col_datum_types = val;
}

void TTableMeta::__set_is_view(const bool val) {
  this->is_view = val;
}

void TTableMeta::__set_is_replicated(const bool val) {
  this->is_replicated = val;
}

void TTableMeta::__set_shard_count(const int64_t val) {
  this->shard_count = val;
}

void TTableMeta::__set_max_rows(const int64_t val) {
  this->max_rows = val;
}

void TTableMeta::__set_table_id(const int64_t val) {
  this->table_id = val;
}

void TTableMeta::__set_max_table_id(const int64_t val) {
  this->max_table_id = val;
}
std::ostream& operator<<(std::ostream& out, const TTableMeta& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableMeta::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_cols);
          this->__isset.num_cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->col_datum_types.clear();
            uint32_t _size172;
            ::apache::thrift::protocol::TType _etype175;
            xfer += iprot->readListBegin(_etype175, _size172);
            this->col_datum_types.resize(_size172);
            uint32_t _i176;
            for (_i176 = 0; _i176 < _size172; ++_i176)
            {
              int32_t ecast177;
              xfer += iprot->readI32(ecast177);
              this->col_datum_types[_i176] = ( ::TDatumType::type)ecast177;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.col_datum_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_view);
          this->__isset.is_view = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_replicated);
          this->__isset.is_replicated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->shard_count);
          this->__isset.shard_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_rows);
          this->__isset.max_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_table_id);
          this->__isset.max_table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableMeta::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableMeta");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_cols", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->num_cols);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_datum_types", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->col_datum_types.size()));
    std::vector< ::TDatumType::type> ::const_iterator _iter178;
    for (_iter178 = this->col_datum_types.begin(); _iter178 != this->col_datum_types.end(); ++_iter178)
    {
      xfer += oprot->writeI32((int32_t)(*_iter178));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_view", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_view);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_replicated", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_replicated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shard_count", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->shard_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_rows", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->max_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_table_id", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->max_table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableMeta &a, TTableMeta &b) {
  using ::std::swap;
  swap(a.table_name, b.table_name);
  swap(a.num_cols, b.num_cols);
  swap(a.col_datum_types, b.col_datum_types);
  swap(a.is_view, b.is_view);
  swap(a.is_replicated, b.is_replicated);
  swap(a.shard_count, b.shard_count);
  swap(a.max_rows, b.max_rows);
  swap(a.table_id, b.table_id);
  swap(a.max_table_id, b.max_table_id);
  swap(a.__isset, b.__isset);
}

TTableMeta::TTableMeta(const TTableMeta& other179) {
  table_name = other179.table_name;
  num_cols = other179.num_cols;
  col_datum_types = other179.col_datum_types;
  is_view = other179.is_view;
  is_replicated = other179.is_replicated;
  shard_count = other179.shard_count;
  max_rows = other179.max_rows;
  table_id = other179.table_id;
  max_table_id = other179.max_table_id;
  __isset = other179.__isset;
}
TTableMeta& TTableMeta::operator=(const TTableMeta& other180) {
  table_name = other180.table_name;
  num_cols = other180.num_cols;
  col_datum_types = other180.col_datum_types;
  is_view = other180.is_view;
  is_replicated = other180.is_replicated;
  shard_count = other180.shard_count;
  max_rows = other180.max_rows;
  table_id = other180.table_id;
  max_table_id = other180.max_table_id;
  __isset = other180.__isset;
  return *this;
}
void TTableMeta::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableMeta(";
  out << "table_name=" << to_string(table_name);
  out << ", " << "num_cols=" << to_string(num_cols);
  out << ", " << "col_datum_types=" << to_string(col_datum_types);
  out << ", " << "is_view=" << to_string(is_view);
  out << ", " << "is_replicated=" << to_string(is_replicated);
  out << ", " << "shard_count=" << to_string(shard_count);
  out << ", " << "max_rows=" << to_string(max_rows);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "max_table_id=" << to_string(max_table_id);
  out << ")";
}


TTableDetails::~TTableDetails() throw() {
}


void TTableDetails::__set_row_desc(const TRowDescriptor& val) {
  this->row_desc = val;
}

void TTableDetails::__set_fragment_size(const int64_t val) {
  this->fragment_size = val;
}

void TTableDetails::__set_page_size(const int64_t val) {
  this->page_size = val;
}

void TTableDetails::__set_max_rows(const int64_t val) {
  this->max_rows = val;
}

void TTableDetails::__set_view_sql(const std::string& val) {
  this->view_sql = val;
}

void TTableDetails::__set_shard_count(const int64_t val) {
  this->shard_count = val;
}

void TTableDetails::__set_key_metainfo(const std::string& val) {
  this->key_metainfo = val;
}

void TTableDetails::__set_is_temporary(const bool val) {
  this->is_temporary = val;
}

void TTableDetails::__set_partition_detail(const TPartitionDetail::type val) {
  this->partition_detail = val;
}
std::ostream& operator<<(std::ostream& out, const TTableDetails& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableDetails::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_desc.clear();
            uint32_t _size181;
            ::apache::thrift::protocol::TType _etype184;
            xfer += iprot->readListBegin(_etype184, _size181);
            this->row_desc.resize(_size181);
            uint32_t _i185;
            for (_i185 = 0; _i185 < _size181; ++_i185)
            {
              xfer += this->row_desc[_i185].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->fragment_size);
          this->__isset.fragment_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->page_size);
          this->__isset.page_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_rows);
          this->__isset.max_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_sql);
          this->__isset.view_sql = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->shard_count);
          this->__isset.shard_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key_metainfo);
          this->__isset.key_metainfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_temporary);
          this->__isset.is_temporary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast186;
          xfer += iprot->readI32(ecast186);
          this->partition_detail = (TPartitionDetail::type)ecast186;
          this->__isset.partition_detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableDetails::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableDetails");

  xfer += oprot->writeFieldBegin("row_desc", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row_desc.size()));
    std::vector<TColumnType> ::const_iterator _iter187;
    for (_iter187 = this->row_desc.begin(); _iter187 != this->row_desc.end(); ++_iter187)
    {
      xfer += (*_iter187).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fragment_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->fragment_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("page_size", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->page_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_rows", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->max_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_sql", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->view_sql);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shard_count", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->shard_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_metainfo", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->key_metainfo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_temporary", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->is_temporary);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partition_detail", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32((int32_t)this->partition_detail);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableDetails &a, TTableDetails &b) {
  using ::std::swap;
  swap(a.row_desc, b.row_desc);
  swap(a.fragment_size, b.fragment_size);
  swap(a.page_size, b.page_size);
  swap(a.max_rows, b.max_rows);
  swap(a.view_sql, b.view_sql);
  swap(a.shard_count, b.shard_count);
  swap(a.key_metainfo, b.key_metainfo);
  swap(a.is_temporary, b.is_temporary);
  swap(a.partition_detail, b.partition_detail);
  swap(a.__isset, b.__isset);
}

TTableDetails::TTableDetails(const TTableDetails& other188) {
  row_desc = other188.row_desc;
  fragment_size = other188.fragment_size;
  page_size = other188.page_size;
  max_rows = other188.max_rows;
  view_sql = other188.view_sql;
  shard_count = other188.shard_count;
  key_metainfo = other188.key_metainfo;
  is_temporary = other188.is_temporary;
  partition_detail = other188.partition_detail;
  __isset = other188.__isset;
}
TTableDetails& TTableDetails::operator=(const TTableDetails& other189) {
  row_desc = other189.row_desc;
  fragment_size = other189.fragment_size;
  page_size = other189.page_size;
  max_rows = other189.max_rows;
  view_sql = other189.view_sql;
  shard_count = other189.shard_count;
  key_metainfo = other189.key_metainfo;
  is_temporary = other189.is_temporary;
  partition_detail = other189.partition_detail;
  __isset = other189.__isset;
  return *this;
}
void TTableDetails::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableDetails(";
  out << "row_desc=" << to_string(row_desc);
  out << ", " << "fragment_size=" << to_string(fragment_size);
  out << ", " << "page_size=" << to_string(page_size);
  out << ", " << "max_rows=" << to_string(max_rows);
  out << ", " << "view_sql=" << to_string(view_sql);
  out << ", " << "shard_count=" << to_string(shard_count);
  out << ", " << "key_metainfo=" << to_string(key_metainfo);
  out << ", " << "is_temporary=" << to_string(is_temporary);
  out << ", " << "partition_detail=" << to_string(partition_detail);
  out << ")";
}


TColumnRange::~TColumnRange() throw() {
}


void TColumnRange::__set_type(const TExpressionRangeType::type val) {
  this->type = val;
}

void TColumnRange::__set_col_id(const int32_t val) {
  this->col_id = val;
}

void TColumnRange::__set_table_id(const int32_t val) {
  this->table_id = val;
}

void TColumnRange::__set_has_nulls(const bool val) {
  this->has_nulls = val;
}

void TColumnRange::__set_int_min(const int64_t val) {
  this->int_min = val;
}

void TColumnRange::__set_int_max(const int64_t val) {
  this->int_max = val;
}

void TColumnRange::__set_bucket(const int64_t val) {
  this->bucket = val;
}

void TColumnRange::__set_fp_min(const double val) {
  this->fp_min = val;
}

void TColumnRange::__set_fp_max(const double val) {
  this->fp_max = val;
}
std::ostream& operator<<(std::ostream& out, const TColumnRange& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast190;
          xfer += iprot->readI32(ecast190);
          this->type = (TExpressionRangeType::type)ecast190;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->col_id);
          this->__isset.col_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_nulls);
          this->__isset.has_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->int_min);
          this->__isset.int_min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->int_max);
          this->__isset.int_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bucket);
          this->__isset.bucket = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fp_min);
          this->__isset.fp_min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fp_max);
          this->__isset.fp_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnRange");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->col_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_nulls", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->has_nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("int_min", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->int_min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("int_max", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->int_max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bucket", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->bucket);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fp_min", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->fp_min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fp_max", ::apache::thrift::protocol::T_DOUBLE, 9);
  xfer += oprot->writeDouble(this->fp_max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnRange &a, TColumnRange &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.col_id, b.col_id);
  swap(a.table_id, b.table_id);
  swap(a.has_nulls, b.has_nulls);
  swap(a.int_min, b.int_min);
  swap(a.int_max, b.int_max);
  swap(a.bucket, b.bucket);
  swap(a.fp_min, b.fp_min);
  swap(a.fp_max, b.fp_max);
  swap(a.__isset, b.__isset);
}

TColumnRange::TColumnRange(const TColumnRange& other191) {
  type = other191.type;
  col_id = other191.col_id;
  table_id = other191.table_id;
  has_nulls = other191.has_nulls;
  int_min = other191.int_min;
  int_max = other191.int_max;
  bucket = other191.bucket;
  fp_min = other191.fp_min;
  fp_max = other191.fp_max;
  __isset = other191.__isset;
}
TColumnRange& TColumnRange::operator=(const TColumnRange& other192) {
  type = other192.type;
  col_id = other192.col_id;
  table_id = other192.table_id;
  has_nulls = other192.has_nulls;
  int_min = other192.int_min;
  int_max = other192.int_max;
  bucket = other192.bucket;
  fp_min = other192.fp_min;
  fp_max = other192.fp_max;
  __isset = other192.__isset;
  return *this;
}
void TColumnRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnRange(";
  out << "type=" << to_string(type);
  out << ", " << "col_id=" << to_string(col_id);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "has_nulls=" << to_string(has_nulls);
  out << ", " << "int_min=" << to_string(int_min);
  out << ", " << "int_max=" << to_string(int_max);
  out << ", " << "bucket=" << to_string(bucket);
  out << ", " << "fp_min=" << to_string(fp_min);
  out << ", " << "fp_max=" << to_string(fp_max);
  out << ")";
}


TDictionaryGeneration::~TDictionaryGeneration() throw() {
}


void TDictionaryGeneration::__set_dict_id(const int32_t val) {
  this->dict_id = val;
}

void TDictionaryGeneration::__set_entry_count(const int64_t val) {
  this->entry_count = val;
}
std::ostream& operator<<(std::ostream& out, const TDictionaryGeneration& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDictionaryGeneration::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dict_id);
          this->__isset.dict_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->entry_count);
          this->__isset.entry_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDictionaryGeneration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDictionaryGeneration");

  xfer += oprot->writeFieldBegin("dict_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->dict_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entry_count", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->entry_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDictionaryGeneration &a, TDictionaryGeneration &b) {
  using ::std::swap;
  swap(a.dict_id, b.dict_id);
  swap(a.entry_count, b.entry_count);
  swap(a.__isset, b.__isset);
}

TDictionaryGeneration::TDictionaryGeneration(const TDictionaryGeneration& other193) {
  dict_id = other193.dict_id;
  entry_count = other193.entry_count;
  __isset = other193.__isset;
}
TDictionaryGeneration& TDictionaryGeneration::operator=(const TDictionaryGeneration& other194) {
  dict_id = other194.dict_id;
  entry_count = other194.entry_count;
  __isset = other194.__isset;
  return *this;
}
void TDictionaryGeneration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDictionaryGeneration(";
  out << "dict_id=" << to_string(dict_id);
  out << ", " << "entry_count=" << to_string(entry_count);
  out << ")";
}


TTableGeneration::~TTableGeneration() throw() {
}


void TTableGeneration::__set_table_id(const int32_t val) {
  this->table_id = val;
}

void TTableGeneration::__set_tuple_count(const int64_t val) {
  this->tuple_count = val;
}

void TTableGeneration::__set_start_rowid(const int64_t val) {
  this->start_rowid = val;
}
std::ostream& operator<<(std::ostream& out, const TTableGeneration& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableGeneration::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tuple_count);
          this->__isset.tuple_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_rowid);
          this->__isset.start_rowid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableGeneration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableGeneration");

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tuple_count", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->tuple_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_rowid", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->start_rowid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableGeneration &a, TTableGeneration &b) {
  using ::std::swap;
  swap(a.table_id, b.table_id);
  swap(a.tuple_count, b.tuple_count);
  swap(a.start_rowid, b.start_rowid);
  swap(a.__isset, b.__isset);
}

TTableGeneration::TTableGeneration(const TTableGeneration& other195) {
  table_id = other195.table_id;
  tuple_count = other195.tuple_count;
  start_rowid = other195.start_rowid;
  __isset = other195.__isset;
}
TTableGeneration& TTableGeneration::operator=(const TTableGeneration& other196) {
  table_id = other196.table_id;
  tuple_count = other196.tuple_count;
  start_rowid = other196.start_rowid;
  __isset = other196.__isset;
  return *this;
}
void TTableGeneration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableGeneration(";
  out << "table_id=" << to_string(table_id);
  out << ", " << "tuple_count=" << to_string(tuple_count);
  out << ", " << "start_rowid=" << to_string(start_rowid);
  out << ")";
}


TPendingQuery::~TPendingQuery() throw() {
}


void TPendingQuery::__set_id(const TQueryId val) {
  this->id = val;
}

void TPendingQuery::__set_column_ranges(const std::vector<TColumnRange> & val) {
  this->column_ranges = val;
}

void TPendingQuery::__set_dictionary_generations(const std::vector<TDictionaryGeneration> & val) {
  this->dictionary_generations = val;
}

void TPendingQuery::__set_table_generations(const std::vector<TTableGeneration> & val) {
  this->table_generations = val;
}
std::ostream& operator<<(std::ostream& out, const TPendingQuery& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPendingQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_ranges.clear();
            uint32_t _size197;
            ::apache::thrift::protocol::TType _etype200;
            xfer += iprot->readListBegin(_etype200, _size197);
            this->column_ranges.resize(_size197);
            uint32_t _i201;
            for (_i201 = 0; _i201 < _size197; ++_i201)
            {
              xfer += this->column_ranges[_i201].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dictionary_generations.clear();
            uint32_t _size202;
            ::apache::thrift::protocol::TType _etype205;
            xfer += iprot->readListBegin(_etype205, _size202);
            this->dictionary_generations.resize(_size202);
            uint32_t _i206;
            for (_i206 = 0; _i206 < _size202; ++_i206)
            {
              xfer += this->dictionary_generations[_i206].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dictionary_generations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->table_generations.clear();
            uint32_t _size207;
            ::apache::thrift::protocol::TType _etype210;
            xfer += iprot->readListBegin(_etype210, _size207);
            this->table_generations.resize(_size207);
            uint32_t _i211;
            for (_i211 = 0; _i211 < _size207; ++_i211)
            {
              xfer += this->table_generations[_i211].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.table_generations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPendingQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPendingQuery");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_ranges", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_ranges.size()));
    std::vector<TColumnRange> ::const_iterator _iter212;
    for (_iter212 = this->column_ranges.begin(); _iter212 != this->column_ranges.end(); ++_iter212)
    {
      xfer += (*_iter212).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dictionary_generations", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dictionary_generations.size()));
    std::vector<TDictionaryGeneration> ::const_iterator _iter213;
    for (_iter213 = this->dictionary_generations.begin(); _iter213 != this->dictionary_generations.end(); ++_iter213)
    {
      xfer += (*_iter213).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_generations", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->table_generations.size()));
    std::vector<TTableGeneration> ::const_iterator _iter214;
    for (_iter214 = this->table_generations.begin(); _iter214 != this->table_generations.end(); ++_iter214)
    {
      xfer += (*_iter214).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPendingQuery &a, TPendingQuery &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.column_ranges, b.column_ranges);
  swap(a.dictionary_generations, b.dictionary_generations);
  swap(a.table_generations, b.table_generations);
  swap(a.__isset, b.__isset);
}

TPendingQuery::TPendingQuery(const TPendingQuery& other215) {
  id = other215.id;
  column_ranges = other215.column_ranges;
  dictionary_generations = other215.dictionary_generations;
  table_generations = other215.table_generations;
  __isset = other215.__isset;
}
TPendingQuery& TPendingQuery::operator=(const TPendingQuery& other216) {
  id = other216.id;
  column_ranges = other216.column_ranges;
  dictionary_generations = other216.dictionary_generations;
  table_generations = other216.table_generations;
  __isset = other216.__isset;
  return *this;
}
void TPendingQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPendingQuery(";
  out << "id=" << to_string(id);
  out << ", " << "column_ranges=" << to_string(column_ranges);
  out << ", " << "dictionary_generations=" << to_string(dictionary_generations);
  out << ", " << "table_generations=" << to_string(table_generations);
  out << ")";
}


TVarLen::~TVarLen() throw() {
}


void TVarLen::__set_payload(const std::string& val) {
  this->payload = val;
}

void TVarLen::__set_is_null(const bool val) {
  this->is_null = val;
}
std::ostream& operator<<(std::ostream& out, const TVarLen& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TVarLen::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->payload);
          this->__isset.payload = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_null);
          this->__isset.is_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TVarLen::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TVarLen");

  xfer += oprot->writeFieldBegin("payload", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->payload);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_null", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TVarLen &a, TVarLen &b) {
  using ::std::swap;
  swap(a.payload, b.payload);
  swap(a.is_null, b.is_null);
  swap(a.__isset, b.__isset);
}

TVarLen::TVarLen(const TVarLen& other217) {
  payload = other217.payload;
  is_null = other217.is_null;
  __isset = other217.__isset;
}
TVarLen& TVarLen::operator=(const TVarLen& other218) {
  payload = other218.payload;
  is_null = other218.is_null;
  __isset = other218.__isset;
  return *this;
}
void TVarLen::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TVarLen(";
  out << "payload=" << to_string(payload);
  out << ", " << "is_null=" << to_string(is_null);
  out << ")";
}


TDataBlockPtr::~TDataBlockPtr() throw() {
}


void TDataBlockPtr::__set_fixed_len_data(const std::string& val) {
  this->fixed_len_data = val;
__isset.fixed_len_data = true;
}

void TDataBlockPtr::__set_var_len_data(const std::vector<TVarLen> & val) {
  this->var_len_data = val;
__isset.var_len_data = true;
}
std::ostream& operator<<(std::ostream& out, const TDataBlockPtr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDataBlockPtr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->fixed_len_data);
          this->__isset.fixed_len_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->var_len_data.clear();
            uint32_t _size219;
            ::apache::thrift::protocol::TType _etype222;
            xfer += iprot->readListBegin(_etype222, _size219);
            this->var_len_data.resize(_size219);
            uint32_t _i223;
            for (_i223 = 0; _i223 < _size219; ++_i223)
            {
              xfer += this->var_len_data[_i223].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.var_len_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDataBlockPtr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataBlockPtr");

  if (this->__isset.fixed_len_data) {
    xfer += oprot->writeFieldBegin("fixed_len_data", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->fixed_len_data);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.var_len_data) {
    xfer += oprot->writeFieldBegin("var_len_data", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->var_len_data.size()));
      std::vector<TVarLen> ::const_iterator _iter224;
      for (_iter224 = this->var_len_data.begin(); _iter224 != this->var_len_data.end(); ++_iter224)
      {
        xfer += (*_iter224).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDataBlockPtr &a, TDataBlockPtr &b) {
  using ::std::swap;
  swap(a.fixed_len_data, b.fixed_len_data);
  swap(a.var_len_data, b.var_len_data);
  swap(a.__isset, b.__isset);
}

TDataBlockPtr::TDataBlockPtr(const TDataBlockPtr& other225) {
  fixed_len_data = other225.fixed_len_data;
  var_len_data = other225.var_len_data;
  __isset = other225.__isset;
}
TDataBlockPtr& TDataBlockPtr::operator=(const TDataBlockPtr& other226) {
  fixed_len_data = other226.fixed_len_data;
  var_len_data = other226.var_len_data;
  __isset = other226.__isset;
  return *this;
}
void TDataBlockPtr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDataBlockPtr(";
  out << "fixed_len_data="; (__isset.fixed_len_data ? (out << to_string(fixed_len_data)) : (out << "<null>"));
  out << ", " << "var_len_data="; (__isset.var_len_data ? (out << to_string(var_len_data)) : (out << "<null>"));
  out << ")";
}


TInsertData::~TInsertData() throw() {
}


void TInsertData::__set_db_id(const int32_t val) {
  this->db_id = val;
}

void TInsertData::__set_table_id(const int32_t val) {
  this->table_id = val;
}

void TInsertData::__set_column_ids(const std::vector<int32_t> & val) {
  this->column_ids = val;
}

void TInsertData::__set_data(const std::vector<TDataBlockPtr> & val) {
  this->data = val;
}

void TInsertData::__set_num_rows(const int64_t val) {
  this->num_rows = val;
}
std::ostream& operator<<(std::ostream& out, const TInsertData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TInsertData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->db_id);
          this->__isset.db_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_ids.clear();
            uint32_t _size227;
            ::apache::thrift::protocol::TType _etype230;
            xfer += iprot->readListBegin(_etype230, _size227);
            this->column_ids.resize(_size227);
            uint32_t _i231;
            for (_i231 = 0; _i231 < _size227; ++_i231)
            {
              xfer += iprot->readI32(this->column_ids[_i231]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size232;
            ::apache::thrift::protocol::TType _etype235;
            xfer += iprot->readListBegin(_etype235, _size232);
            this->data.resize(_size232);
            uint32_t _i236;
            for (_i236 = 0; _i236 < _size232; ++_i236)
            {
              xfer += this->data[_i236].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_rows);
          this->__isset.num_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TInsertData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TInsertData");

  xfer += oprot->writeFieldBegin("db_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->db_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_ids", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->column_ids.size()));
    std::vector<int32_t> ::const_iterator _iter237;
    for (_iter237 = this->column_ids.begin(); _iter237 != this->column_ids.end(); ++_iter237)
    {
      xfer += oprot->writeI32((*_iter237));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->data.size()));
    std::vector<TDataBlockPtr> ::const_iterator _iter238;
    for (_iter238 = this->data.begin(); _iter238 != this->data.end(); ++_iter238)
    {
      xfer += (*_iter238).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_rows", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->num_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TInsertData &a, TInsertData &b) {
  using ::std::swap;
  swap(a.db_id, b.db_id);
  swap(a.table_id, b.table_id);
  swap(a.column_ids, b.column_ids);
  swap(a.data, b.data);
  swap(a.num_rows, b.num_rows);
  swap(a.__isset, b.__isset);
}

TInsertData::TInsertData(const TInsertData& other239) {
  db_id = other239.db_id;
  table_id = other239.table_id;
  column_ids = other239.column_ids;
  data = other239.data;
  num_rows = other239.num_rows;
  __isset = other239.__isset;
}
TInsertData& TInsertData::operator=(const TInsertData& other240) {
  db_id = other240.db_id;
  table_id = other240.table_id;
  column_ids = other240.column_ids;
  data = other240.data;
  num_rows = other240.num_rows;
  __isset = other240.__isset;
  return *this;
}
void TInsertData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TInsertData(";
  out << "db_id=" << to_string(db_id);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "column_ids=" << to_string(column_ids);
  out << ", " << "data=" << to_string(data);
  out << ", " << "num_rows=" << to_string(num_rows);
  out << ")";
}


TPendingRenderQuery::~TPendingRenderQuery() throw() {
}


void TPendingRenderQuery::__set_id(const TQueryId val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const TPendingRenderQuery& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPendingRenderQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPendingRenderQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPendingRenderQuery");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPendingRenderQuery &a, TPendingRenderQuery &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

TPendingRenderQuery::TPendingRenderQuery(const TPendingRenderQuery& other241) {
  id = other241.id;
  __isset = other241.__isset;
}
TPendingRenderQuery& TPendingRenderQuery::operator=(const TPendingRenderQuery& other242) {
  id = other242.id;
  __isset = other242.__isset;
  return *this;
}
void TPendingRenderQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPendingRenderQuery(";
  out << "id=" << to_string(id);
  out << ")";
}


TRenderParseResult::~TRenderParseResult() throw() {
}


void TRenderParseResult::__set_merge_type(const TMergeType::type val) {
  this->merge_type = val;
}

void TRenderParseResult::__set_node_id(const int32_t val) {
  this->node_id = val;
}

void TRenderParseResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TRenderParseResult::__set_render_time_ms(const int64_t val) {
  this->render_time_ms = val;
}

void TRenderParseResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderParseResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderParseResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast243;
          xfer += iprot->readI32(ecast243);
          this->merge_type = (TMergeType::type)ecast243;
          this->__isset.merge_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->render_time_ms);
          this->__isset.render_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderParseResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderParseResult");

  xfer += oprot->writeFieldBegin("merge_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->merge_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_time_ms", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->render_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderParseResult &a, TRenderParseResult &b) {
  using ::std::swap;
  swap(a.merge_type, b.merge_type);
  swap(a.node_id, b.node_id);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.render_time_ms, b.render_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.__isset, b.__isset);
}

TRenderParseResult::TRenderParseResult(const TRenderParseResult& other244) {
  merge_type = other244.merge_type;
  node_id = other244.node_id;
  execution_time_ms = other244.execution_time_ms;
  render_time_ms = other244.render_time_ms;
  total_time_ms = other244.total_time_ms;
  __isset = other244.__isset;
}
TRenderParseResult& TRenderParseResult::operator=(const TRenderParseResult& other245) {
  merge_type = other245.merge_type;
  node_id = other245.node_id;
  execution_time_ms = other245.execution_time_ms;
  render_time_ms = other245.render_time_ms;
  total_time_ms = other245.total_time_ms;
  __isset = other245.__isset;
  return *this;
}
void TRenderParseResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderParseResult(";
  out << "merge_type=" << to_string(merge_type);
  out << ", " << "node_id=" << to_string(node_id);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "render_time_ms=" << to_string(render_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ")";
}


TRawRenderPassDataResult::~TRawRenderPassDataResult() throw() {
}


void TRawRenderPassDataResult::__set_num_pixel_channels(const int32_t val) {
  this->num_pixel_channels = val;
}

void TRawRenderPassDataResult::__set_num_pixel_samples(const int32_t val) {
  this->num_pixel_samples = val;
}

void TRawRenderPassDataResult::__set_pixels(const std::string& val) {
  this->pixels = val;
}

void TRawRenderPassDataResult::__set_row_ids_A(const std::string& val) {
  this->row_ids_A = val;
}

void TRawRenderPassDataResult::__set_row_ids_B(const std::string& val) {
  this->row_ids_B = val;
}

void TRawRenderPassDataResult::__set_table_ids(const std::string& val) {
  this->table_ids = val;
}

void TRawRenderPassDataResult::__set_accum_data(const std::string& val) {
  this->accum_data = val;
}
std::ostream& operator<<(std::ostream& out, const TRawRenderPassDataResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRawRenderPassDataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_pixel_channels);
          this->__isset.num_pixel_channels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_pixel_samples);
          this->__isset.num_pixel_samples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pixels);
          this->__isset.pixels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row_ids_A);
          this->__isset.row_ids_A = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row_ids_B);
          this->__isset.row_ids_B = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->table_ids);
          this->__isset.table_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->accum_data);
          this->__isset.accum_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRawRenderPassDataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRawRenderPassDataResult");

  xfer += oprot->writeFieldBegin("num_pixel_channels", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num_pixel_channels);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_pixel_samples", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num_pixel_samples);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pixels", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->pixels);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_ids_A", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->row_ids_A);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_ids_B", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->row_ids_B);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_ids", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->table_ids);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("accum_data", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeBinary(this->accum_data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRawRenderPassDataResult &a, TRawRenderPassDataResult &b) {
  using ::std::swap;
  swap(a.num_pixel_channels, b.num_pixel_channels);
  swap(a.num_pixel_samples, b.num_pixel_samples);
  swap(a.pixels, b.pixels);
  swap(a.row_ids_A, b.row_ids_A);
  swap(a.row_ids_B, b.row_ids_B);
  swap(a.table_ids, b.table_ids);
  swap(a.accum_data, b.accum_data);
  swap(a.__isset, b.__isset);
}

TRawRenderPassDataResult::TRawRenderPassDataResult(const TRawRenderPassDataResult& other246) {
  num_pixel_channels = other246.num_pixel_channels;
  num_pixel_samples = other246.num_pixel_samples;
  pixels = other246.pixels;
  row_ids_A = other246.row_ids_A;
  row_ids_B = other246.row_ids_B;
  table_ids = other246.table_ids;
  accum_data = other246.accum_data;
  __isset = other246.__isset;
}
TRawRenderPassDataResult& TRawRenderPassDataResult::operator=(const TRawRenderPassDataResult& other247) {
  num_pixel_channels = other247.num_pixel_channels;
  num_pixel_samples = other247.num_pixel_samples;
  pixels = other247.pixels;
  row_ids_A = other247.row_ids_A;
  row_ids_B = other247.row_ids_B;
  table_ids = other247.table_ids;
  accum_data = other247.accum_data;
  __isset = other247.__isset;
  return *this;
}
void TRawRenderPassDataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRawRenderPassDataResult(";
  out << "num_pixel_channels=" << to_string(num_pixel_channels);
  out << ", " << "num_pixel_samples=" << to_string(num_pixel_samples);
  out << ", " << "pixels=" << to_string(pixels);
  out << ", " << "row_ids_A=" << to_string(row_ids_A);
  out << ", " << "row_ids_B=" << to_string(row_ids_B);
  out << ", " << "table_ids=" << to_string(table_ids);
  out << ", " << "accum_data=" << to_string(accum_data);
  out << ")";
}


TRawPixelData::~TRawPixelData() throw() {
}


void TRawPixelData::__set_width(const int32_t val) {
  this->width = val;
}

void TRawPixelData::__set_height(const int32_t val) {
  this->height = val;
}

void TRawPixelData::__set_render_pass_map(const TRenderPassMap& val) {
  this->render_pass_map = val;
}
std::ostream& operator<<(std::ostream& out, const TRawPixelData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRawPixelData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->width);
          this->__isset.width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->height);
          this->__isset.height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->render_pass_map.clear();
            uint32_t _size248;
            ::apache::thrift::protocol::TType _ktype249;
            ::apache::thrift::protocol::TType _vtype250;
            xfer += iprot->readMapBegin(_ktype249, _vtype250, _size248);
            uint32_t _i252;
            for (_i252 = 0; _i252 < _size248; ++_i252)
            {
              int32_t _key253;
              xfer += iprot->readI32(_key253);
              TRawRenderPassDataResult& _val254 = this->render_pass_map[_key253];
              xfer += _val254.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.render_pass_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRawPixelData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRawPixelData");

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_pass_map", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->render_pass_map.size()));
    std::map<int32_t, TRawRenderPassDataResult> ::const_iterator _iter255;
    for (_iter255 = this->render_pass_map.begin(); _iter255 != this->render_pass_map.end(); ++_iter255)
    {
      xfer += oprot->writeI32(_iter255->first);
      xfer += _iter255->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRawPixelData &a, TRawPixelData &b) {
  using ::std::swap;
  swap(a.width, b.width);
  swap(a.height, b.height);
  swap(a.render_pass_map, b.render_pass_map);
  swap(a.__isset, b.__isset);
}

TRawPixelData::TRawPixelData(const TRawPixelData& other256) {
  width = other256.width;
  height = other256.height;
  render_pass_map = other256.render_pass_map;
  __isset = other256.__isset;
}
TRawPixelData& TRawPixelData::operator=(const TRawPixelData& other257) {
  width = other257.width;
  height = other257.height;
  render_pass_map = other257.render_pass_map;
  __isset = other257.__isset;
  return *this;
}
void TRawPixelData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRawPixelData(";
  out << "width=" << to_string(width);
  out << ", " << "height=" << to_string(height);
  out << ", " << "render_pass_map=" << to_string(render_pass_map);
  out << ")";
}


TRenderDatum::~TRenderDatum() throw() {
}


void TRenderDatum::__set_type(const  ::TDatumType::type val) {
  this->type = val;
}

void TRenderDatum::__set_cnt(const int32_t val) {
  this->cnt = val;
}

void TRenderDatum::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderDatum& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderDatum::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast258;
          xfer += iprot->readI32(ecast258);
          this->type = ( ::TDatumType::type)ecast258;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cnt);
          this->__isset.cnt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderDatum::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderDatum");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cnt", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->cnt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderDatum &a, TRenderDatum &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.cnt, b.cnt);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TRenderDatum::TRenderDatum(const TRenderDatum& other259) {
  type = other259.type;
  cnt = other259.cnt;
  value = other259.value;
  __isset = other259.__isset;
}
TRenderDatum& TRenderDatum::operator=(const TRenderDatum& other260) {
  type = other260.type;
  cnt = other260.cnt;
  value = other260.value;
  __isset = other260.__isset;
  return *this;
}
void TRenderDatum::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderDatum(";
  out << "type=" << to_string(type);
  out << ", " << "cnt=" << to_string(cnt);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


TRenderStepResult::~TRenderStepResult() throw() {
}


void TRenderStepResult::__set_merge_data(const TRenderAggDataMap& val) {
  this->merge_data = val;
}

void TRenderStepResult::__set_raw_pixel_data(const TRawPixelData& val) {
  this->raw_pixel_data = val;
}

void TRenderStepResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TRenderStepResult::__set_render_time_ms(const int64_t val) {
  this->render_time_ms = val;
}

void TRenderStepResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderStepResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderStepResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->merge_data.clear();
            uint32_t _size261;
            ::apache::thrift::protocol::TType _ktype262;
            ::apache::thrift::protocol::TType _vtype263;
            xfer += iprot->readMapBegin(_ktype262, _vtype263, _size261);
            uint32_t _i265;
            for (_i265 = 0; _i265 < _size261; ++_i265)
            {
              std::string _key266;
              xfer += iprot->readString(_key266);
              std::map<std::string, std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > > & _val267 = this->merge_data[_key266];
              {
                _val267.clear();
                uint32_t _size268;
                ::apache::thrift::protocol::TType _ktype269;
                ::apache::thrift::protocol::TType _vtype270;
                xfer += iprot->readMapBegin(_ktype269, _vtype270, _size268);
                uint32_t _i272;
                for (_i272 = 0; _i272 < _size268; ++_i272)
                {
                  std::string _key273;
                  xfer += iprot->readString(_key273);
                  std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > & _val274 = _val267[_key273];
                  {
                    _val274.clear();
                    uint32_t _size275;
                    ::apache::thrift::protocol::TType _ktype276;
                    ::apache::thrift::protocol::TType _vtype277;
                    xfer += iprot->readMapBegin(_ktype276, _vtype277, _size275);
                    uint32_t _i279;
                    for (_i279 = 0; _i279 < _size275; ++_i279)
                    {
                      std::string _key280;
                      xfer += iprot->readString(_key280);
                      std::map<std::string, std::vector<TRenderDatum> > & _val281 = _val274[_key280];
                      {
                        _val281.clear();
                        uint32_t _size282;
                        ::apache::thrift::protocol::TType _ktype283;
                        ::apache::thrift::protocol::TType _vtype284;
                        xfer += iprot->readMapBegin(_ktype283, _vtype284, _size282);
                        uint32_t _i286;
                        for (_i286 = 0; _i286 < _size282; ++_i286)
                        {
                          std::string _key287;
                          xfer += iprot->readString(_key287);
                          std::vector<TRenderDatum> & _val288 = _val281[_key287];
                          {
                            _val288.clear();
                            uint32_t _size289;
                            ::apache::thrift::protocol::TType _etype292;
                            xfer += iprot->readListBegin(_etype292, _size289);
                            _val288.resize(_size289);
                            uint32_t _i293;
                            for (_i293 = 0; _i293 < _size289; ++_i293)
                            {
                              xfer += _val288[_i293].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                          }
                        }
                        xfer += iprot->readMapEnd();
                      }
                    }
                    xfer += iprot->readMapEnd();
                  }
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.merge_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->raw_pixel_data.read(iprot);
          this->__isset.raw_pixel_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->render_time_ms);
          this->__isset.render_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderStepResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderStepResult");

  xfer += oprot->writeFieldBegin("merge_data", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->merge_data.size()));
    std::map<std::string, std::map<std::string, std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > > > ::const_iterator _iter294;
    for (_iter294 = this->merge_data.begin(); _iter294 != this->merge_data.end(); ++_iter294)
    {
      xfer += oprot->writeString(_iter294->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(_iter294->second.size()));
        std::map<std::string, std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > > ::const_iterator _iter295;
        for (_iter295 = _iter294->second.begin(); _iter295 != _iter294->second.end(); ++_iter295)
        {
          xfer += oprot->writeString(_iter295->first);
          {
            xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(_iter295->second.size()));
            std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > ::const_iterator _iter296;
            for (_iter296 = _iter295->second.begin(); _iter296 != _iter295->second.end(); ++_iter296)
            {
              xfer += oprot->writeString(_iter296->first);
              {
                xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(_iter296->second.size()));
                std::map<std::string, std::vector<TRenderDatum> > ::const_iterator _iter297;
                for (_iter297 = _iter296->second.begin(); _iter297 != _iter296->second.end(); ++_iter297)
                {
                  xfer += oprot->writeString(_iter297->first);
                  {
                    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter297->second.size()));
                    std::vector<TRenderDatum> ::const_iterator _iter298;
                    for (_iter298 = _iter297->second.begin(); _iter298 != _iter297->second.end(); ++_iter298)
                    {
                      xfer += (*_iter298).write(oprot);
                    }
                    xfer += oprot->writeListEnd();
                  }
                }
                xfer += oprot->writeMapEnd();
              }
            }
            xfer += oprot->writeMapEnd();
          }
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("raw_pixel_data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->raw_pixel_data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_time_ms", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->render_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderStepResult &a, TRenderStepResult &b) {
  using ::std::swap;
  swap(a.merge_data, b.merge_data);
  swap(a.raw_pixel_data, b.raw_pixel_data);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.render_time_ms, b.render_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.__isset, b.__isset);
}

TRenderStepResult::TRenderStepResult(const TRenderStepResult& other299) {
  merge_data = other299.merge_data;
  raw_pixel_data = other299.raw_pixel_data;
  execution_time_ms = other299.execution_time_ms;
  render_time_ms = other299.render_time_ms;
  total_time_ms = other299.total_time_ms;
  __isset = other299.__isset;
}
TRenderStepResult& TRenderStepResult::operator=(const TRenderStepResult& other300) {
  merge_data = other300.merge_data;
  raw_pixel_data = other300.raw_pixel_data;
  execution_time_ms = other300.execution_time_ms;
  render_time_ms = other300.render_time_ms;
  total_time_ms = other300.total_time_ms;
  __isset = other300.__isset;
  return *this;
}
void TRenderStepResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderStepResult(";
  out << "merge_data=" << to_string(merge_data);
  out << ", " << "raw_pixel_data=" << to_string(raw_pixel_data);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "render_time_ms=" << to_string(render_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ")";
}


TDatabasePermissions::~TDatabasePermissions() throw() {
}


void TDatabasePermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TDatabasePermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}

void TDatabasePermissions::__set_view_sql_editor_(const bool val) {
  this->view_sql_editor_ = val;
}

void TDatabasePermissions::__set_access_(const bool val) {
  this->access_ = val;
}
std::ostream& operator<<(std::ostream& out, const TDatabasePermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDatabasePermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->view_sql_editor_);
          this->__isset.view_sql_editor_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->access_);
          this->__isset.access_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDatabasePermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDatabasePermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_sql_editor_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->view_sql_editor_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("access_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->access_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDatabasePermissions &a, TDatabasePermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.delete_, b.delete_);
  swap(a.view_sql_editor_, b.view_sql_editor_);
  swap(a.access_, b.access_);
  swap(a.__isset, b.__isset);
}

TDatabasePermissions::TDatabasePermissions(const TDatabasePermissions& other301) {
  create_ = other301.create_;
  delete_ = other301.delete_;
  view_sql_editor_ = other301.view_sql_editor_;
  access_ = other301.access_;
  __isset = other301.__isset;
}
TDatabasePermissions& TDatabasePermissions::operator=(const TDatabasePermissions& other302) {
  create_ = other302.create_;
  delete_ = other302.delete_;
  view_sql_editor_ = other302.view_sql_editor_;
  access_ = other302.access_;
  __isset = other302.__isset;
  return *this;
}
void TDatabasePermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDatabasePermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ", " << "view_sql_editor_=" << to_string(view_sql_editor_);
  out << ", " << "access_=" << to_string(access_);
  out << ")";
}


TTablePermissions::~TTablePermissions() throw() {
}


void TTablePermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TTablePermissions::__set_drop_(const bool val) {
  this->drop_ = val;
}

void TTablePermissions::__set_select_(const bool val) {
  this->select_ = val;
}

void TTablePermissions::__set_insert_(const bool val) {
  this->insert_ = val;
}

void TTablePermissions::__set_update_(const bool val) {
  this->update_ = val;
}

void TTablePermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}

void TTablePermissions::__set_truncate_(const bool val) {
  this->truncate_ = val;
}

void TTablePermissions::__set_alter_(const bool val) {
  this->alter_ = val;
}
std::ostream& operator<<(std::ostream& out, const TTablePermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTablePermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->drop_);
          this->__isset.drop_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->select_);
          this->__isset.select_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->insert_);
          this->__isset.insert_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->update_);
          this->__isset.update_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->truncate_);
          this->__isset.truncate_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->alter_);
          this->__isset.alter_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTablePermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTablePermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("drop_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->drop_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("select_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->select_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("insert_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->insert_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->update_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("truncate_", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->truncate_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("alter_", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->alter_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTablePermissions &a, TTablePermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.drop_, b.drop_);
  swap(a.select_, b.select_);
  swap(a.insert_, b.insert_);
  swap(a.update_, b.update_);
  swap(a.delete_, b.delete_);
  swap(a.truncate_, b.truncate_);
  swap(a.alter_, b.alter_);
  swap(a.__isset, b.__isset);
}

TTablePermissions::TTablePermissions(const TTablePermissions& other303) {
  create_ = other303.create_;
  drop_ = other303.drop_;
  select_ = other303.select_;
  insert_ = other303.insert_;
  update_ = other303.update_;
  delete_ = other303.delete_;
  truncate_ = other303.truncate_;
  alter_ = other303.alter_;
  __isset = other303.__isset;
}
TTablePermissions& TTablePermissions::operator=(const TTablePermissions& other304) {
  create_ = other304.create_;
  drop_ = other304.drop_;
  select_ = other304.select_;
  insert_ = other304.insert_;
  update_ = other304.update_;
  delete_ = other304.delete_;
  truncate_ = other304.truncate_;
  alter_ = other304.alter_;
  __isset = other304.__isset;
  return *this;
}
void TTablePermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTablePermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "drop_=" << to_string(drop_);
  out << ", " << "select_=" << to_string(select_);
  out << ", " << "insert_=" << to_string(insert_);
  out << ", " << "update_=" << to_string(update_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ", " << "truncate_=" << to_string(truncate_);
  out << ", " << "alter_=" << to_string(alter_);
  out << ")";
}


TDashboardPermissions::~TDashboardPermissions() throw() {
}


void TDashboardPermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TDashboardPermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}

void TDashboardPermissions::__set_view_(const bool val) {
  this->view_ = val;
}

void TDashboardPermissions::__set_edit_(const bool val) {
  this->edit_ = val;
}
std::ostream& operator<<(std::ostream& out, const TDashboardPermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDashboardPermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->view_);
          this->__isset.view_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->edit_);
          this->__isset.edit_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDashboardPermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDashboardPermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->view_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("edit_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->edit_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDashboardPermissions &a, TDashboardPermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.delete_, b.delete_);
  swap(a.view_, b.view_);
  swap(a.edit_, b.edit_);
  swap(a.__isset, b.__isset);
}

TDashboardPermissions::TDashboardPermissions(const TDashboardPermissions& other305) {
  create_ = other305.create_;
  delete_ = other305.delete_;
  view_ = other305.view_;
  edit_ = other305.edit_;
  __isset = other305.__isset;
}
TDashboardPermissions& TDashboardPermissions::operator=(const TDashboardPermissions& other306) {
  create_ = other306.create_;
  delete_ = other306.delete_;
  view_ = other306.view_;
  edit_ = other306.edit_;
  __isset = other306.__isset;
  return *this;
}
void TDashboardPermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDashboardPermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ", " << "view_=" << to_string(view_);
  out << ", " << "edit_=" << to_string(edit_);
  out << ")";
}


TViewPermissions::~TViewPermissions() throw() {
}


void TViewPermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TViewPermissions::__set_drop_(const bool val) {
  this->drop_ = val;
}

void TViewPermissions::__set_select_(const bool val) {
  this->select_ = val;
}

void TViewPermissions::__set_insert_(const bool val) {
  this->insert_ = val;
}

void TViewPermissions::__set_update_(const bool val) {
  this->update_ = val;
}

void TViewPermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}
std::ostream& operator<<(std::ostream& out, const TViewPermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TViewPermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->drop_);
          this->__isset.drop_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->select_);
          this->__isset.select_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->insert_);
          this->__isset.insert_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->update_);
          this->__isset.update_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TViewPermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TViewPermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("drop_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->drop_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("select_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->select_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("insert_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->insert_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->update_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TViewPermissions &a, TViewPermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.drop_, b.drop_);
  swap(a.select_, b.select_);
  swap(a.insert_, b.insert_);
  swap(a.update_, b.update_);
  swap(a.delete_, b.delete_);
  swap(a.__isset, b.__isset);
}

TViewPermissions::TViewPermissions(const TViewPermissions& other307) {
  create_ = other307.create_;
  drop_ = other307.drop_;
  select_ = other307.select_;
  insert_ = other307.insert_;
  update_ = other307.update_;
  delete_ = other307.delete_;
  __isset = other307.__isset;
}
TViewPermissions& TViewPermissions::operator=(const TViewPermissions& other308) {
  create_ = other308.create_;
  drop_ = other308.drop_;
  select_ = other308.select_;
  insert_ = other308.insert_;
  update_ = other308.update_;
  delete_ = other308.delete_;
  __isset = other308.__isset;
  return *this;
}
void TViewPermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TViewPermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "drop_=" << to_string(drop_);
  out << ", " << "select_=" << to_string(select_);
  out << ", " << "insert_=" << to_string(insert_);
  out << ", " << "update_=" << to_string(update_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ")";
}


TDBObjectPermissions::~TDBObjectPermissions() throw() {
}


void TDBObjectPermissions::__set_database_permissions_(const TDatabasePermissions& val) {
  this->database_permissions_ = val;
__isset.database_permissions_ = true;
}

void TDBObjectPermissions::__set_table_permissions_(const TTablePermissions& val) {
  this->table_permissions_ = val;
__isset.table_permissions_ = true;
}

void TDBObjectPermissions::__set_dashboard_permissions_(const TDashboardPermissions& val) {
  this->dashboard_permissions_ = val;
__isset.dashboard_permissions_ = true;
}

void TDBObjectPermissions::__set_view_permissions_(const TViewPermissions& val) {
  this->view_permissions_ = val;
__isset.view_permissions_ = true;
}
std::ostream& operator<<(std::ostream& out, const TDBObjectPermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDBObjectPermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->database_permissions_.read(iprot);
          this->__isset.database_permissions_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_permissions_.read(iprot);
          this->__isset.table_permissions_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dashboard_permissions_.read(iprot);
          this->__isset.dashboard_permissions_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->view_permissions_.read(iprot);
          this->__isset.view_permissions_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDBObjectPermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDBObjectPermissions");

  if (this->__isset.database_permissions_) {
    xfer += oprot->writeFieldBegin("database_permissions_", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->database_permissions_.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_permissions_) {
    xfer += oprot->writeFieldBegin("table_permissions_", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->table_permissions_.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dashboard_permissions_) {
    xfer += oprot->writeFieldBegin("dashboard_permissions_", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->dashboard_permissions_.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.view_permissions_) {
    xfer += oprot->writeFieldBegin("view_permissions_", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->view_permissions_.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDBObjectPermissions &a, TDBObjectPermissions &b) {
  using ::std::swap;
  swap(a.database_permissions_, b.database_permissions_);
  swap(a.table_permissions_, b.table_permissions_);
  swap(a.dashboard_permissions_, b.dashboard_permissions_);
  swap(a.view_permissions_, b.view_permissions_);
  swap(a.__isset, b.__isset);
}

TDBObjectPermissions::TDBObjectPermissions(const TDBObjectPermissions& other309) {
  database_permissions_ = other309.database_permissions_;
  table_permissions_ = other309.table_permissions_;
  dashboard_permissions_ = other309.dashboard_permissions_;
  view_permissions_ = other309.view_permissions_;
  __isset = other309.__isset;
}
TDBObjectPermissions& TDBObjectPermissions::operator=(const TDBObjectPermissions& other310) {
  database_permissions_ = other310.database_permissions_;
  table_permissions_ = other310.table_permissions_;
  dashboard_permissions_ = other310.dashboard_permissions_;
  view_permissions_ = other310.view_permissions_;
  __isset = other310.__isset;
  return *this;
}
void TDBObjectPermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDBObjectPermissions(";
  out << "database_permissions_="; (__isset.database_permissions_ ? (out << to_string(database_permissions_)) : (out << "<null>"));
  out << ", " << "table_permissions_="; (__isset.table_permissions_ ? (out << to_string(table_permissions_)) : (out << "<null>"));
  out << ", " << "dashboard_permissions_="; (__isset.dashboard_permissions_ ? (out << to_string(dashboard_permissions_)) : (out << "<null>"));
  out << ", " << "view_permissions_="; (__isset.view_permissions_ ? (out << to_string(view_permissions_)) : (out << "<null>"));
  out << ")";
}


TDBObject::~TDBObject() throw() {
}


void TDBObject::__set_objectName(const std::string& val) {
  this->objectName = val;
}

void TDBObject::__set_objectType(const TDBObjectType::type val) {
  this->objectType = val;
}

void TDBObject::__set_privs(const std::vector<bool> & val) {
  this->privs = val;
}

void TDBObject::__set_grantee(const std::string& val) {
  this->grantee = val;
}
std::ostream& operator<<(std::ostream& out, const TDBObject& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDBObject::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->objectName);
          this->__isset.objectName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast311;
          xfer += iprot->readI32(ecast311);
          this->objectType = (TDBObjectType::type)ecast311;
          this->__isset.objectType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->privs.clear();
            uint32_t _size312;
            ::apache::thrift::protocol::TType _etype315;
            xfer += iprot->readListBegin(_etype315, _size312);
            this->privs.resize(_size312);
            uint32_t _i316;
            for (_i316 = 0; _i316 < _size312; ++_i316)
            {
              xfer += iprot->readBool(this->privs[_i316]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.privs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->grantee);
          this->__isset.grantee = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDBObject::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDBObject");

  xfer += oprot->writeFieldBegin("objectName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->objectName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("objectType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->objectType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("privs", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->privs.size()));
    std::vector<bool> ::const_iterator _iter317;
    for (_iter317 = this->privs.begin(); _iter317 != this->privs.end(); ++_iter317)
    {
      xfer += oprot->writeBool((*_iter317));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantee", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->grantee);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDBObject &a, TDBObject &b) {
  using ::std::swap;
  swap(a.objectName, b.objectName);
  swap(a.objectType, b.objectType);
  swap(a.privs, b.privs);
  swap(a.grantee, b.grantee);
  swap(a.__isset, b.__isset);
}

TDBObject::TDBObject(const TDBObject& other318) {
  objectName = other318.objectName;
  objectType = other318.objectType;
  privs = other318.privs;
  grantee = other318.grantee;
  __isset = other318.__isset;
}
TDBObject& TDBObject::operator=(const TDBObject& other319) {
  objectName = other319.objectName;
  objectType = other319.objectType;
  privs = other319.privs;
  grantee = other319.grantee;
  __isset = other319.__isset;
  return *this;
}
void TDBObject::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDBObject(";
  out << "objectName=" << to_string(objectName);
  out << ", " << "objectType=" << to_string(objectType);
  out << ", " << "privs=" << to_string(privs);
  out << ", " << "grantee=" << to_string(grantee);
  out << ")";
}


TDashboardGrantees::~TDashboardGrantees() throw() {
}


void TDashboardGrantees::__set_name(const std::string& val) {
  this->name = val;
}

void TDashboardGrantees::__set_is_user(const bool val) {
  this->is_user = val;
}

void TDashboardGrantees::__set_permissions(const TDashboardPermissions& val) {
  this->permissions = val;
}
std::ostream& operator<<(std::ostream& out, const TDashboardGrantees& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDashboardGrantees::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_user);
          this->__isset.is_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->permissions.read(iprot);
          this->__isset.permissions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDashboardGrantees::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDashboardGrantees");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_user", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("permissions", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->permissions.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDashboardGrantees &a, TDashboardGrantees &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.is_user, b.is_user);
  swap(a.permissions, b.permissions);
  swap(a.__isset, b.__isset);
}

TDashboardGrantees::TDashboardGrantees(const TDashboardGrantees& other320) {
  name = other320.name;
  is_user = other320.is_user;
  permissions = other320.permissions;
  __isset = other320.__isset;
}
TDashboardGrantees& TDashboardGrantees::operator=(const TDashboardGrantees& other321) {
  name = other321.name;
  is_user = other321.is_user;
  permissions = other321.permissions;
  __isset = other321.__isset;
  return *this;
}
void TDashboardGrantees::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDashboardGrantees(";
  out << "name=" << to_string(name);
  out << ", " << "is_user=" << to_string(is_user);
  out << ", " << "permissions=" << to_string(permissions);
  out << ")";
}


TLicenseInfo::~TLicenseInfo() throw() {
}


void TLicenseInfo::__set_claims(const std::vector<std::string> & val) {
  this->claims = val;
}
std::ostream& operator<<(std::ostream& out, const TLicenseInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TLicenseInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->claims.clear();
            uint32_t _size322;
            ::apache::thrift::protocol::TType _etype325;
            xfer += iprot->readListBegin(_etype325, _size322);
            this->claims.resize(_size322);
            uint32_t _i326;
            for (_i326 = 0; _i326 < _size322; ++_i326)
            {
              xfer += iprot->readString(this->claims[_i326]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.claims = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TLicenseInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLicenseInfo");

  xfer += oprot->writeFieldBegin("claims", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->claims.size()));
    std::vector<std::string> ::const_iterator _iter327;
    for (_iter327 = this->claims.begin(); _iter327 != this->claims.end(); ++_iter327)
    {
      xfer += oprot->writeString((*_iter327));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLicenseInfo &a, TLicenseInfo &b) {
  using ::std::swap;
  swap(a.claims, b.claims);
  swap(a.__isset, b.__isset);
}

TLicenseInfo::TLicenseInfo(const TLicenseInfo& other328) {
  claims = other328.claims;
  __isset = other328.__isset;
}
TLicenseInfo& TLicenseInfo::operator=(const TLicenseInfo& other329) {
  claims = other329.claims;
  __isset = other329.__isset;
  return *this;
}
void TLicenseInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLicenseInfo(";
  out << "claims=" << to_string(claims);
  out << ")";
}


TSessionInfo::~TSessionInfo() throw() {
}


void TSessionInfo::__set_user(const std::string& val) {
  this->user = val;
}

void TSessionInfo::__set_database(const std::string& val) {
  this->database = val;
}

void TSessionInfo::__set_start_time(const int64_t val) {
  this->start_time = val;
}
std::ostream& operator<<(std::ostream& out, const TSessionInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSessionInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->database);
          this->__isset.database = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_time);
          this->__isset.start_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TSessionInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSessionInfo");

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("database", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->database);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_time", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->start_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSessionInfo &a, TSessionInfo &b) {
  using ::std::swap;
  swap(a.user, b.user);
  swap(a.database, b.database);
  swap(a.start_time, b.start_time);
  swap(a.__isset, b.__isset);
}

TSessionInfo::TSessionInfo(const TSessionInfo& other330) {
  user = other330.user;
  database = other330.database;
  start_time = other330.start_time;
  __isset = other330.__isset;
}
TSessionInfo& TSessionInfo::operator=(const TSessionInfo& other331) {
  user = other331.user;
  database = other331.database;
  start_time = other331.start_time;
  __isset = other331.__isset;
  return *this;
}
void TSessionInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSessionInfo(";
  out << "user=" << to_string(user);
  out << ", " << "database=" << to_string(database);
  out << ", " << "start_time=" << to_string(start_time);
  out << ")";
}


TGeoFileLayerInfo::~TGeoFileLayerInfo() throw() {
}


void TGeoFileLayerInfo::__set_name(const std::string& val) {
  this->name = val;
}

void TGeoFileLayerInfo::__set_contents(const TGeoFileLayerContents::type val) {
  this->contents = val;
}
std::ostream& operator<<(std::ostream& out, const TGeoFileLayerInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGeoFileLayerInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast332;
          xfer += iprot->readI32(ecast332);
          this->contents = (TGeoFileLayerContents::type)ecast332;
          this->__isset.contents = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGeoFileLayerInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGeoFileLayerInfo");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contents", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->contents);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGeoFileLayerInfo &a, TGeoFileLayerInfo &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.contents, b.contents);
  swap(a.__isset, b.__isset);
}

TGeoFileLayerInfo::TGeoFileLayerInfo(const TGeoFileLayerInfo& other333) {
  name = other333.name;
  contents = other333.contents;
  __isset = other333.__isset;
}
TGeoFileLayerInfo& TGeoFileLayerInfo::operator=(const TGeoFileLayerInfo& other334) {
  name = other334.name;
  contents = other334.contents;
  __isset = other334.__isset;
  return *this;
}
void TGeoFileLayerInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGeoFileLayerInfo(";
  out << "name=" << to_string(name);
  out << ", " << "contents=" << to_string(contents);
  out << ")";
}


