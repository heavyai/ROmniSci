/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "mapd_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kTExecuteModeValues[] = {
  TExecuteMode::GPU,
  TExecuteMode::CPU
};
const char* _kTExecuteModeNames[] = {
  "GPU",
  "CPU"
};
const std::map<int, const char*> _TExecuteMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTExecuteModeValues, _kTExecuteModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TExecuteMode::type& val) {
  std::map<int, const char*>::const_iterator it = _TExecuteMode_VALUES_TO_NAMES.find(val);
  if (it != _TExecuteMode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTFileTypeValues[] = {
  TFileType::DELIMITED,
  TFileType::POLYGON,
  TFileType::PARQUET
};
const char* _kTFileTypeNames[] = {
  "DELIMITED",
  "POLYGON",
  "PARQUET"
};
const std::map<int, const char*> _TFileType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTFileTypeValues, _kTFileTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TFileType::type& val) {
  std::map<int, const char*>::const_iterator it = _TFileType_VALUES_TO_NAMES.find(val);
  if (it != _TFileType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTPartitionDetailValues[] = {
  TPartitionDetail::DEFAULT,
  TPartitionDetail::REPLICATED,
  TPartitionDetail::SHARDED,
  TPartitionDetail::OTHER
};
const char* _kTPartitionDetailNames[] = {
  "DEFAULT",
  "REPLICATED",
  "SHARDED",
  "OTHER"
};
const std::map<int, const char*> _TPartitionDetail_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTPartitionDetailValues, _kTPartitionDetailNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TPartitionDetail::type& val) {
  std::map<int, const char*>::const_iterator it = _TPartitionDetail_VALUES_TO_NAMES.find(val);
  if (it != _TPartitionDetail_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTGeoFileLayerContentsValues[] = {
  TGeoFileLayerContents::EMPTY,
  TGeoFileLayerContents::GEO,
  TGeoFileLayerContents::NON_GEO,
  TGeoFileLayerContents::UNSUPPORTED_GEO
};
const char* _kTGeoFileLayerContentsNames[] = {
  "EMPTY",
  "GEO",
  "NON_GEO",
  "UNSUPPORTED_GEO"
};
const std::map<int, const char*> _TGeoFileLayerContents_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTGeoFileLayerContentsValues, _kTGeoFileLayerContentsNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TGeoFileLayerContents::type& val) {
  std::map<int, const char*>::const_iterator it = _TGeoFileLayerContents_VALUES_TO_NAMES.find(val);
  if (it != _TGeoFileLayerContents_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTImportHeaderRowValues[] = {
  TImportHeaderRow::AUTODETECT,
  TImportHeaderRow::NO_HEADER,
  TImportHeaderRow::HAS_HEADER
};
const char* _kTImportHeaderRowNames[] = {
  "AUTODETECT",
  "NO_HEADER",
  "HAS_HEADER"
};
const std::map<int, const char*> _TImportHeaderRow_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTImportHeaderRowValues, _kTImportHeaderRowNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TImportHeaderRow::type& val) {
  std::map<int, const char*>::const_iterator it = _TImportHeaderRow_VALUES_TO_NAMES.find(val);
  if (it != _TImportHeaderRow_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTRoleValues[] = {
  TRole::SERVER,
  TRole::AGGREGATOR,
  TRole::LEAF,
  TRole::STRING_DICTIONARY
};
const char* _kTRoleNames[] = {
  "SERVER",
  "AGGREGATOR",
  "LEAF",
  "STRING_DICTIONARY"
};
const std::map<int, const char*> _TRole_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTRoleValues, _kTRoleNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TRole::type& val) {
  std::map<int, const char*>::const_iterator it = _TRole_VALUES_TO_NAMES.find(val);
  if (it != _TRole_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTMergeTypeValues[] = {
  TMergeType::UNION,
  TMergeType::REDUCE
};
const char* _kTMergeTypeNames[] = {
  "UNION",
  "REDUCE"
};
const std::map<int, const char*> _TMergeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTMergeTypeValues, _kTMergeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TMergeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TMergeType_VALUES_TO_NAMES.find(val);
  if (it != _TMergeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTExpressionRangeTypeValues[] = {
  TExpressionRangeType::INVALID,
  TExpressionRangeType::INTEGER,
  TExpressionRangeType::FLOAT,
  TExpressionRangeType::DOUBLE
};
const char* _kTExpressionRangeTypeNames[] = {
  "INVALID",
  "INTEGER",
  "FLOAT",
  "DOUBLE"
};
const std::map<int, const char*> _TExpressionRangeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTExpressionRangeTypeValues, _kTExpressionRangeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TExpressionRangeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TExpressionRangeType_VALUES_TO_NAMES.find(val);
  if (it != _TExpressionRangeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTDBObjectTypeValues[] = {
  TDBObjectType::AbstractDBObjectType,
  TDBObjectType::DatabaseDBObjectType,
  TDBObjectType::TableDBObjectType,
  TDBObjectType::DashboardDBObjectType,
  TDBObjectType::ViewDBObjectType
};
const char* _kTDBObjectTypeNames[] = {
  "AbstractDBObjectType",
  "DatabaseDBObjectType",
  "TableDBObjectType",
  "DashboardDBObjectType",
  "ViewDBObjectType"
};
const std::map<int, const char*> _TDBObjectType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTDBObjectTypeValues, _kTDBObjectTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TDBObjectType::type& val) {
  std::map<int, const char*>::const_iterator it = _TDBObjectType_VALUES_TO_NAMES.find(val);
  if (it != _TDBObjectType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


TDatumVal::~TDatumVal() throw() {
}


void TDatumVal::__set_int_val(const int64_t val) {
  this->int_val = val;
}

void TDatumVal::__set_real_val(const double val) {
  this->real_val = val;
}

void TDatumVal::__set_str_val(const std::string& val) {
  this->str_val = val;
}

void TDatumVal::__set_arr_val(const std::vector<TDatum> & val) {
  this->arr_val = val;
}
std::ostream& operator<<(std::ostream& out, const TDatumVal& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDatumVal::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->int_val);
          this->__isset.int_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->real_val);
          this->__isset.real_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->str_val);
          this->__isset.str_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arr_val.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->arr_val.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->arr_val[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arr_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDatumVal::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDatumVal");

  xfer += oprot->writeFieldBegin("int_val", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->int_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("real_val", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->real_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("str_val", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->str_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arr_val", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arr_val.size()));
    std::vector<TDatum> ::const_iterator _iter5;
    for (_iter5 = this->arr_val.begin(); _iter5 != this->arr_val.end(); ++_iter5)
    {
      xfer += (*_iter5).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDatumVal &a, TDatumVal &b) {
  using ::std::swap;
  swap(a.int_val, b.int_val);
  swap(a.real_val, b.real_val);
  swap(a.str_val, b.str_val);
  swap(a.arr_val, b.arr_val);
  swap(a.__isset, b.__isset);
}

TDatumVal::TDatumVal(const TDatumVal& other6) {
  int_val = other6.int_val;
  real_val = other6.real_val;
  str_val = other6.str_val;
  arr_val = other6.arr_val;
  __isset = other6.__isset;
}
TDatumVal& TDatumVal::operator=(const TDatumVal& other7) {
  int_val = other7.int_val;
  real_val = other7.real_val;
  str_val = other7.str_val;
  arr_val = other7.arr_val;
  __isset = other7.__isset;
  return *this;
}
void TDatumVal::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDatumVal(";
  out << "int_val=" << to_string(int_val);
  out << ", " << "real_val=" << to_string(real_val);
  out << ", " << "str_val=" << to_string(str_val);
  out << ", " << "arr_val=" << to_string(arr_val);
  out << ")";
}


TDatum::~TDatum() throw() {
}


void TDatum::__set_val(const TDatumVal& val) {
  this->val = val;
}

void TDatum::__set_is_null(const bool val) {
  this->is_null = val;
}
std::ostream& operator<<(std::ostream& out, const TDatum& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDatum::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->val.read(iprot);
          this->__isset.val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_null);
          this->__isset.is_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDatum::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDatum");

  xfer += oprot->writeFieldBegin("val", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->val.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_null", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDatum &a, TDatum &b) {
  using ::std::swap;
  swap(a.val, b.val);
  swap(a.is_null, b.is_null);
  swap(a.__isset, b.__isset);
}

TDatum::TDatum(const TDatum& other8) {
  val = other8.val;
  is_null = other8.is_null;
  __isset = other8.__isset;
}
TDatum& TDatum::operator=(const TDatum& other9) {
  val = other9.val;
  is_null = other9.is_null;
  __isset = other9.__isset;
  return *this;
}
void TDatum::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDatum(";
  out << "val=" << to_string(val);
  out << ", " << "is_null=" << to_string(is_null);
  out << ")";
}


TStringValue::~TStringValue() throw() {
}


void TStringValue::__set_str_val(const std::string& val) {
  this->str_val = val;
}

void TStringValue::__set_is_null(const bool val) {
  this->is_null = val;
}
std::ostream& operator<<(std::ostream& out, const TStringValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStringValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->str_val);
          this->__isset.str_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_null);
          this->__isset.is_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringValue");

  xfer += oprot->writeFieldBegin("str_val", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->str_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_null", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStringValue &a, TStringValue &b) {
  using ::std::swap;
  swap(a.str_val, b.str_val);
  swap(a.is_null, b.is_null);
  swap(a.__isset, b.__isset);
}

TStringValue::TStringValue(const TStringValue& other10) {
  str_val = other10.str_val;
  is_null = other10.is_null;
  __isset = other10.__isset;
}
TStringValue& TStringValue::operator=(const TStringValue& other11) {
  str_val = other11.str_val;
  is_null = other11.is_null;
  __isset = other11.__isset;
  return *this;
}
void TStringValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStringValue(";
  out << "str_val=" << to_string(str_val);
  out << ", " << "is_null=" << to_string(is_null);
  out << ")";
}


TColumnType::~TColumnType() throw() {
}


void TColumnType::__set_col_name(const std::string& val) {
  this->col_name = val;
}

void TColumnType::__set_col_type(const  ::TTypeInfo& val) {
  this->col_type = val;
}

void TColumnType::__set_is_reserved_keyword(const bool val) {
  this->is_reserved_keyword = val;
}

void TColumnType::__set_src_name(const std::string& val) {
  this->src_name = val;
}

void TColumnType::__set_is_system(const bool val) {
  this->is_system = val;
}

void TColumnType::__set_is_physical(const bool val) {
  this->is_physical = val;
}

void TColumnType::__set_col_id(const int64_t val) {
  this->col_id = val;
}
std::ostream& operator<<(std::ostream& out, const TColumnType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col_name);
          this->__isset.col_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->col_type.read(iprot);
          this->__isset.col_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_reserved_keyword);
          this->__isset.is_reserved_keyword = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->src_name);
          this->__isset.src_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_system);
          this->__isset.is_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_physical);
          this->__isset.is_physical = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->col_id);
          this->__isset.col_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnType");

  xfer += oprot->writeFieldBegin("col_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->col_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_type", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->col_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_reserved_keyword", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_reserved_keyword);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->src_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_system", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_system);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_physical", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->is_physical);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_id", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->col_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnType &a, TColumnType &b) {
  using ::std::swap;
  swap(a.col_name, b.col_name);
  swap(a.col_type, b.col_type);
  swap(a.is_reserved_keyword, b.is_reserved_keyword);
  swap(a.src_name, b.src_name);
  swap(a.is_system, b.is_system);
  swap(a.is_physical, b.is_physical);
  swap(a.col_id, b.col_id);
  swap(a.__isset, b.__isset);
}

TColumnType::TColumnType(const TColumnType& other12) {
  col_name = other12.col_name;
  col_type = other12.col_type;
  is_reserved_keyword = other12.is_reserved_keyword;
  src_name = other12.src_name;
  is_system = other12.is_system;
  is_physical = other12.is_physical;
  col_id = other12.col_id;
  __isset = other12.__isset;
}
TColumnType& TColumnType::operator=(const TColumnType& other13) {
  col_name = other13.col_name;
  col_type = other13.col_type;
  is_reserved_keyword = other13.is_reserved_keyword;
  src_name = other13.src_name;
  is_system = other13.is_system;
  is_physical = other13.is_physical;
  col_id = other13.col_id;
  __isset = other13.__isset;
  return *this;
}
void TColumnType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnType(";
  out << "col_name=" << to_string(col_name);
  out << ", " << "col_type=" << to_string(col_type);
  out << ", " << "is_reserved_keyword=" << to_string(is_reserved_keyword);
  out << ", " << "src_name=" << to_string(src_name);
  out << ", " << "is_system=" << to_string(is_system);
  out << ", " << "is_physical=" << to_string(is_physical);
  out << ", " << "col_id=" << to_string(col_id);
  out << ")";
}


TRow::~TRow() throw() {
}


void TRow::__set_cols(const std::vector<TDatum> & val) {
  this->cols = val;
}
std::ostream& operator<<(std::ostream& out, const TRow& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRow::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cols.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->cols.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += this->cols[_i18].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRow");

  xfer += oprot->writeFieldBegin("cols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cols.size()));
    std::vector<TDatum> ::const_iterator _iter19;
    for (_iter19 = this->cols.begin(); _iter19 != this->cols.end(); ++_iter19)
    {
      xfer += (*_iter19).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRow &a, TRow &b) {
  using ::std::swap;
  swap(a.cols, b.cols);
  swap(a.__isset, b.__isset);
}

TRow::TRow(const TRow& other20) {
  cols = other20.cols;
  __isset = other20.__isset;
}
TRow& TRow::operator=(const TRow& other21) {
  cols = other21.cols;
  __isset = other21.__isset;
  return *this;
}
void TRow::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRow(";
  out << "cols=" << to_string(cols);
  out << ")";
}


TColumnData::~TColumnData() throw() {
}


void TColumnData::__set_int_col(const std::vector<int64_t> & val) {
  this->int_col = val;
}

void TColumnData::__set_real_col(const std::vector<double> & val) {
  this->real_col = val;
}

void TColumnData::__set_str_col(const std::vector<std::string> & val) {
  this->str_col = val;
}

void TColumnData::__set_arr_col(const std::vector<TColumn> & val) {
  this->arr_col = val;
}
std::ostream& operator<<(std::ostream& out, const TColumnData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->int_col.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->int_col.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += iprot->readI64(this->int_col[_i26]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.int_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->real_col.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->real_col.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += iprot->readDouble(this->real_col[_i31]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.real_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->str_col.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->str_col.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += iprot->readString(this->str_col[_i36]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.str_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arr_col.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->arr_col.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += this->arr_col[_i41].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arr_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnData");

  xfer += oprot->writeFieldBegin("int_col", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->int_col.size()));
    std::vector<int64_t> ::const_iterator _iter42;
    for (_iter42 = this->int_col.begin(); _iter42 != this->int_col.end(); ++_iter42)
    {
      xfer += oprot->writeI64((*_iter42));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("real_col", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->real_col.size()));
    std::vector<double> ::const_iterator _iter43;
    for (_iter43 = this->real_col.begin(); _iter43 != this->real_col.end(); ++_iter43)
    {
      xfer += oprot->writeDouble((*_iter43));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("str_col", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->str_col.size()));
    std::vector<std::string> ::const_iterator _iter44;
    for (_iter44 = this->str_col.begin(); _iter44 != this->str_col.end(); ++_iter44)
    {
      xfer += oprot->writeString((*_iter44));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arr_col", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arr_col.size()));
    std::vector<TColumn> ::const_iterator _iter45;
    for (_iter45 = this->arr_col.begin(); _iter45 != this->arr_col.end(); ++_iter45)
    {
      xfer += (*_iter45).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnData &a, TColumnData &b) {
  using ::std::swap;
  swap(a.int_col, b.int_col);
  swap(a.real_col, b.real_col);
  swap(a.str_col, b.str_col);
  swap(a.arr_col, b.arr_col);
  swap(a.__isset, b.__isset);
}

TColumnData::TColumnData(const TColumnData& other46) {
  int_col = other46.int_col;
  real_col = other46.real_col;
  str_col = other46.str_col;
  arr_col = other46.arr_col;
  __isset = other46.__isset;
}
TColumnData& TColumnData::operator=(const TColumnData& other47) {
  int_col = other47.int_col;
  real_col = other47.real_col;
  str_col = other47.str_col;
  arr_col = other47.arr_col;
  __isset = other47.__isset;
  return *this;
}
void TColumnData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnData(";
  out << "int_col=" << to_string(int_col);
  out << ", " << "real_col=" << to_string(real_col);
  out << ", " << "str_col=" << to_string(str_col);
  out << ", " << "arr_col=" << to_string(arr_col);
  out << ")";
}


TColumn::~TColumn() throw() {
}


void TColumn::__set_data(const TColumnData& val) {
  this->data = val;
}

void TColumn::__set_nulls(const std::vector<bool> & val) {
  this->nulls = val;
}
std::ostream& operator<<(std::ostream& out, const TColumn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nulls.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->nulls.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += iprot->readBool(this->nulls[_i52]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumn");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->nulls.size()));
    std::vector<bool> ::const_iterator _iter53;
    for (_iter53 = this->nulls.begin(); _iter53 != this->nulls.end(); ++_iter53)
    {
      xfer += oprot->writeBool((*_iter53));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumn &a, TColumn &b) {
  using ::std::swap;
  swap(a.data, b.data);
  swap(a.nulls, b.nulls);
  swap(a.__isset, b.__isset);
}

TColumn::TColumn(const TColumn& other54) {
  data = other54.data;
  nulls = other54.nulls;
  __isset = other54.__isset;
}
TColumn& TColumn::operator=(const TColumn& other55) {
  data = other55.data;
  nulls = other55.nulls;
  __isset = other55.__isset;
  return *this;
}
void TColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumn(";
  out << "data=" << to_string(data);
  out << ", " << "nulls=" << to_string(nulls);
  out << ")";
}


TStringRow::~TStringRow() throw() {
}


void TStringRow::__set_cols(const std::vector<TStringValue> & val) {
  this->cols = val;
}
std::ostream& operator<<(std::ostream& out, const TStringRow& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStringRow::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cols.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _etype59;
            xfer += iprot->readListBegin(_etype59, _size56);
            this->cols.resize(_size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              xfer += this->cols[_i60].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringRow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringRow");

  xfer += oprot->writeFieldBegin("cols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cols.size()));
    std::vector<TStringValue> ::const_iterator _iter61;
    for (_iter61 = this->cols.begin(); _iter61 != this->cols.end(); ++_iter61)
    {
      xfer += (*_iter61).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStringRow &a, TStringRow &b) {
  using ::std::swap;
  swap(a.cols, b.cols);
  swap(a.__isset, b.__isset);
}

TStringRow::TStringRow(const TStringRow& other62) {
  cols = other62.cols;
  __isset = other62.__isset;
}
TStringRow& TStringRow::operator=(const TStringRow& other63) {
  cols = other63.cols;
  __isset = other63.__isset;
  return *this;
}
void TStringRow::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStringRow(";
  out << "cols=" << to_string(cols);
  out << ")";
}


TStepResult::~TStepResult() throw() {
}


void TStepResult::__set_serialized_rows(const  ::TSerializedRows& val) {
  this->serialized_rows = val;
}

void TStepResult::__set_execution_finished(const bool val) {
  this->execution_finished = val;
}

void TStepResult::__set_merge_type(const TMergeType::type val) {
  this->merge_type = val;
}

void TStepResult::__set_sharded(const bool val) {
  this->sharded = val;
}

void TStepResult::__set_row_desc(const TRowDescriptor& val) {
  this->row_desc = val;
}

void TStepResult::__set_node_id(const int32_t val) {
  this->node_id = val;
}
std::ostream& operator<<(std::ostream& out, const TStepResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStepResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serialized_rows.read(iprot);
          this->__isset.serialized_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->execution_finished);
          this->__isset.execution_finished = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast64;
          xfer += iprot->readI32(ecast64);
          this->merge_type = (TMergeType::type)ecast64;
          this->__isset.merge_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sharded);
          this->__isset.sharded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_desc.clear();
            uint32_t _size65;
            ::apache::thrift::protocol::TType _etype68;
            xfer += iprot->readListBegin(_etype68, _size65);
            this->row_desc.resize(_size65);
            uint32_t _i69;
            for (_i69 = 0; _i69 < _size65; ++_i69)
            {
              xfer += this->row_desc[_i69].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStepResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStepResult");

  xfer += oprot->writeFieldBegin("serialized_rows", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->serialized_rows.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_finished", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->execution_finished);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("merge_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->merge_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sharded", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->sharded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_desc", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row_desc.size()));
    std::vector<TColumnType> ::const_iterator _iter70;
    for (_iter70 = this->row_desc.begin(); _iter70 != this->row_desc.end(); ++_iter70)
    {
      xfer += (*_iter70).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStepResult &a, TStepResult &b) {
  using ::std::swap;
  swap(a.serialized_rows, b.serialized_rows);
  swap(a.execution_finished, b.execution_finished);
  swap(a.merge_type, b.merge_type);
  swap(a.sharded, b.sharded);
  swap(a.row_desc, b.row_desc);
  swap(a.node_id, b.node_id);
  swap(a.__isset, b.__isset);
}

TStepResult::TStepResult(const TStepResult& other71) {
  serialized_rows = other71.serialized_rows;
  execution_finished = other71.execution_finished;
  merge_type = other71.merge_type;
  sharded = other71.sharded;
  row_desc = other71.row_desc;
  node_id = other71.node_id;
  __isset = other71.__isset;
}
TStepResult& TStepResult::operator=(const TStepResult& other72) {
  serialized_rows = other72.serialized_rows;
  execution_finished = other72.execution_finished;
  merge_type = other72.merge_type;
  sharded = other72.sharded;
  row_desc = other72.row_desc;
  node_id = other72.node_id;
  __isset = other72.__isset;
  return *this;
}
void TStepResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStepResult(";
  out << "serialized_rows=" << to_string(serialized_rows);
  out << ", " << "execution_finished=" << to_string(execution_finished);
  out << ", " << "merge_type=" << to_string(merge_type);
  out << ", " << "sharded=" << to_string(sharded);
  out << ", " << "row_desc=" << to_string(row_desc);
  out << ", " << "node_id=" << to_string(node_id);
  out << ")";
}


TRowSet::~TRowSet() throw() {
}


void TRowSet::__set_row_desc(const TRowDescriptor& val) {
  this->row_desc = val;
}

void TRowSet::__set_rows(const std::vector<TRow> & val) {
  this->rows = val;
}

void TRowSet::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
}

void TRowSet::__set_is_columnar(const bool val) {
  this->is_columnar = val;
}
std::ostream& operator<<(std::ostream& out, const TRowSet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRowSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_desc.clear();
            uint32_t _size73;
            ::apache::thrift::protocol::TType _etype76;
            xfer += iprot->readListBegin(_etype76, _size73);
            this->row_desc.resize(_size73);
            uint32_t _i77;
            for (_i77 = 0; _i77 < _size73; ++_i77)
            {
              xfer += this->row_desc[_i77].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rows.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->rows.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += this->rows[_i82].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size83;
            ::apache::thrift::protocol::TType _etype86;
            xfer += iprot->readListBegin(_etype86, _size83);
            this->columns.resize(_size83);
            uint32_t _i87;
            for (_i87 = 0; _i87 < _size83; ++_i87)
            {
              xfer += this->columns[_i87].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_columnar);
          this->__isset.is_columnar = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRowSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRowSet");

  xfer += oprot->writeFieldBegin("row_desc", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row_desc.size()));
    std::vector<TColumnType> ::const_iterator _iter88;
    for (_iter88 = this->row_desc.begin(); _iter88 != this->row_desc.end(); ++_iter88)
    {
      xfer += (*_iter88).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rows.size()));
    std::vector<TRow> ::const_iterator _iter89;
    for (_iter89 = this->rows.begin(); _iter89 != this->rows.end(); ++_iter89)
    {
      xfer += (*_iter89).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumn> ::const_iterator _iter90;
    for (_iter90 = this->columns.begin(); _iter90 != this->columns.end(); ++_iter90)
    {
      xfer += (*_iter90).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_columnar", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_columnar);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRowSet &a, TRowSet &b) {
  using ::std::swap;
  swap(a.row_desc, b.row_desc);
  swap(a.rows, b.rows);
  swap(a.columns, b.columns);
  swap(a.is_columnar, b.is_columnar);
  swap(a.__isset, b.__isset);
}

TRowSet::TRowSet(const TRowSet& other91) {
  row_desc = other91.row_desc;
  rows = other91.rows;
  columns = other91.columns;
  is_columnar = other91.is_columnar;
  __isset = other91.__isset;
}
TRowSet& TRowSet::operator=(const TRowSet& other92) {
  row_desc = other92.row_desc;
  rows = other92.rows;
  columns = other92.columns;
  is_columnar = other92.is_columnar;
  __isset = other92.__isset;
  return *this;
}
void TRowSet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRowSet(";
  out << "row_desc=" << to_string(row_desc);
  out << ", " << "rows=" << to_string(rows);
  out << ", " << "columns=" << to_string(columns);
  out << ", " << "is_columnar=" << to_string(is_columnar);
  out << ")";
}


TQueryResult::~TQueryResult() throw() {
}


void TQueryResult::__set_row_set(const TRowSet& val) {
  this->row_set = val;
}

void TQueryResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TQueryResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}

void TQueryResult::__set_nonce(const std::string& val) {
  this->nonce = val;
}
std::ostream& operator<<(std::ostream& out, const TQueryResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TQueryResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_set.read(iprot);
          this->__isset.row_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          this->__isset.nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TQueryResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TQueryResult");

  xfer += oprot->writeFieldBegin("row_set", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->row_set.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TQueryResult &a, TQueryResult &b) {
  using ::std::swap;
  swap(a.row_set, b.row_set);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.nonce, b.nonce);
  swap(a.__isset, b.__isset);
}

TQueryResult::TQueryResult(const TQueryResult& other93) {
  row_set = other93.row_set;
  execution_time_ms = other93.execution_time_ms;
  total_time_ms = other93.total_time_ms;
  nonce = other93.nonce;
  __isset = other93.__isset;
}
TQueryResult& TQueryResult::operator=(const TQueryResult& other94) {
  row_set = other94.row_set;
  execution_time_ms = other94.execution_time_ms;
  total_time_ms = other94.total_time_ms;
  nonce = other94.nonce;
  __isset = other94.__isset;
  return *this;
}
void TQueryResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TQueryResult(";
  out << "row_set=" << to_string(row_set);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ", " << "nonce=" << to_string(nonce);
  out << ")";
}


TDataFrame::~TDataFrame() throw() {
}


void TDataFrame::__set_sm_handle(const std::string& val) {
  this->sm_handle = val;
}

void TDataFrame::__set_sm_size(const int64_t val) {
  this->sm_size = val;
}

void TDataFrame::__set_df_handle(const std::string& val) {
  this->df_handle = val;
}

void TDataFrame::__set_df_size(const int64_t val) {
  this->df_size = val;
}
std::ostream& operator<<(std::ostream& out, const TDataFrame& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDataFrame::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->sm_handle);
          this->__isset.sm_handle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sm_size);
          this->__isset.sm_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->df_handle);
          this->__isset.df_handle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->df_size);
          this->__isset.df_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDataFrame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataFrame");

  xfer += oprot->writeFieldBegin("sm_handle", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->sm_handle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sm_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->sm_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("df_handle", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->df_handle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("df_size", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->df_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDataFrame &a, TDataFrame &b) {
  using ::std::swap;
  swap(a.sm_handle, b.sm_handle);
  swap(a.sm_size, b.sm_size);
  swap(a.df_handle, b.df_handle);
  swap(a.df_size, b.df_size);
  swap(a.__isset, b.__isset);
}

TDataFrame::TDataFrame(const TDataFrame& other95) {
  sm_handle = other95.sm_handle;
  sm_size = other95.sm_size;
  df_handle = other95.df_handle;
  df_size = other95.df_size;
  __isset = other95.__isset;
}
TDataFrame& TDataFrame::operator=(const TDataFrame& other96) {
  sm_handle = other96.sm_handle;
  sm_size = other96.sm_size;
  df_handle = other96.df_handle;
  df_size = other96.df_size;
  __isset = other96.__isset;
  return *this;
}
void TDataFrame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDataFrame(";
  out << "sm_handle=" << to_string(sm_handle);
  out << ", " << "sm_size=" << to_string(sm_size);
  out << ", " << "df_handle=" << to_string(df_handle);
  out << ", " << "df_size=" << to_string(df_size);
  out << ")";
}


TDBInfo::~TDBInfo() throw() {
}


void TDBInfo::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void TDBInfo::__set_db_owner(const std::string& val) {
  this->db_owner = val;
}
std::ostream& operator<<(std::ostream& out, const TDBInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDBInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_owner);
          this->__isset.db_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDBInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDBInfo");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_owner", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDBInfo &a, TDBInfo &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.db_owner, b.db_owner);
  swap(a.__isset, b.__isset);
}

TDBInfo::TDBInfo(const TDBInfo& other97) {
  db_name = other97.db_name;
  db_owner = other97.db_owner;
  __isset = other97.__isset;
}
TDBInfo& TDBInfo::operator=(const TDBInfo& other98) {
  db_name = other98.db_name;
  db_owner = other98.db_owner;
  __isset = other98.__isset;
  return *this;
}
void TDBInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDBInfo(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "db_owner=" << to_string(db_owner);
  out << ")";
}


TMapDException::~TMapDException() throw() {
}


void TMapDException::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}
std::ostream& operator<<(std::ostream& out, const TMapDException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TMapDException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMapDException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMapDException");

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMapDException &a, TMapDException &b) {
  using ::std::swap;
  swap(a.error_msg, b.error_msg);
  swap(a.__isset, b.__isset);
}

TMapDException::TMapDException(const TMapDException& other99) : TException() {
  error_msg = other99.error_msg;
  __isset = other99.__isset;
}
TMapDException& TMapDException::operator=(const TMapDException& other100) {
  error_msg = other100.error_msg;
  __isset = other100.__isset;
  return *this;
}
void TMapDException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMapDException(";
  out << "error_msg=" << to_string(error_msg);
  out << ")";
}

const char* TMapDException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TMapDException";
  }
}


TCopyParams::~TCopyParams() throw() {
}


void TCopyParams::__set_delimiter(const std::string& val) {
  this->delimiter = val;
}

void TCopyParams::__set_null_str(const std::string& val) {
  this->null_str = val;
}

void TCopyParams::__set_has_header(const TImportHeaderRow::type val) {
  this->has_header = val;
}

void TCopyParams::__set_quoted(const bool val) {
  this->quoted = val;
}

void TCopyParams::__set_quote(const std::string& val) {
  this->quote = val;
}

void TCopyParams::__set_escape(const std::string& val) {
  this->escape = val;
}

void TCopyParams::__set_line_delim(const std::string& val) {
  this->line_delim = val;
}

void TCopyParams::__set_array_delim(const std::string& val) {
  this->array_delim = val;
}

void TCopyParams::__set_array_begin(const std::string& val) {
  this->array_begin = val;
}

void TCopyParams::__set_array_end(const std::string& val) {
  this->array_end = val;
}

void TCopyParams::__set_threads(const int32_t val) {
  this->threads = val;
}

void TCopyParams::__set_file_type(const TFileType::type val) {
  this->file_type = val;
}

void TCopyParams::__set_s3_access_key(const std::string& val) {
  this->s3_access_key = val;
}

void TCopyParams::__set_s3_secret_key(const std::string& val) {
  this->s3_secret_key = val;
}

void TCopyParams::__set_s3_region(const std::string& val) {
  this->s3_region = val;
}

void TCopyParams::__set_geo_coords_encoding(const  ::TEncodingType::type val) {
  this->geo_coords_encoding = val;
}

void TCopyParams::__set_geo_coords_comp_param(const int32_t val) {
  this->geo_coords_comp_param = val;
}

void TCopyParams::__set_geo_coords_type(const  ::TDatumType::type val) {
  this->geo_coords_type = val;
}

void TCopyParams::__set_geo_coords_srid(const int32_t val) {
  this->geo_coords_srid = val;
}

void TCopyParams::__set_sanitize_column_names(const bool val) {
  this->sanitize_column_names = val;
}

void TCopyParams::__set_geo_layer_name(const std::string& val) {
  this->geo_layer_name = val;
}

void TCopyParams::__set_s3_endpoint(const std::string& val) {
  this->s3_endpoint = val;
}
std::ostream& operator<<(std::ostream& out, const TCopyParams& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCopyParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->delimiter);
          this->__isset.delimiter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->null_str);
          this->__isset.null_str = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast101;
          xfer += iprot->readI32(ecast101);
          this->has_header = (TImportHeaderRow::type)ecast101;
          this->__isset.has_header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->quoted);
          this->__isset.quoted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->quote);
          this->__isset.quote = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->escape);
          this->__isset.escape = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->line_delim);
          this->__isset.line_delim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->array_delim);
          this->__isset.array_delim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->array_begin);
          this->__isset.array_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->array_end);
          this->__isset.array_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->threads);
          this->__isset.threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast102;
          xfer += iprot->readI32(ecast102);
          this->file_type = (TFileType::type)ecast102;
          this->__isset.file_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_access_key);
          this->__isset.s3_access_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_secret_key);
          this->__isset.s3_secret_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_region);
          this->__isset.s3_region = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast103;
          xfer += iprot->readI32(ecast103);
          this->geo_coords_encoding = ( ::TEncodingType::type)ecast103;
          this->__isset.geo_coords_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->geo_coords_comp_param);
          this->__isset.geo_coords_comp_param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast104;
          xfer += iprot->readI32(ecast104);
          this->geo_coords_type = ( ::TDatumType::type)ecast104;
          this->__isset.geo_coords_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->geo_coords_srid);
          this->__isset.geo_coords_srid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sanitize_column_names);
          this->__isset.sanitize_column_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->geo_layer_name);
          this->__isset.geo_layer_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_endpoint);
          this->__isset.s3_endpoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCopyParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCopyParams");

  xfer += oprot->writeFieldBegin("delimiter", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->delimiter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("null_str", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->null_str);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_header", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->has_header);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quoted", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->quoted);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quote", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->quote);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("escape", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->escape);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("line_delim", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->line_delim);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("array_delim", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->array_delim);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("array_begin", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->array_begin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("array_end", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->array_end);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("threads", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->threads);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("file_type", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32((int32_t)this->file_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_access_key", ::apache::thrift::protocol::T_STRING, 13);
  xfer += oprot->writeString(this->s3_access_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_secret_key", ::apache::thrift::protocol::T_STRING, 14);
  xfer += oprot->writeString(this->s3_secret_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_region", ::apache::thrift::protocol::T_STRING, 15);
  xfer += oprot->writeString(this->s3_region);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_encoding", ::apache::thrift::protocol::T_I32, 16);
  xfer += oprot->writeI32((int32_t)this->geo_coords_encoding);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_comp_param", ::apache::thrift::protocol::T_I32, 17);
  xfer += oprot->writeI32(this->geo_coords_comp_param);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_type", ::apache::thrift::protocol::T_I32, 18);
  xfer += oprot->writeI32((int32_t)this->geo_coords_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_srid", ::apache::thrift::protocol::T_I32, 19);
  xfer += oprot->writeI32(this->geo_coords_srid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sanitize_column_names", ::apache::thrift::protocol::T_BOOL, 20);
  xfer += oprot->writeBool(this->sanitize_column_names);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_layer_name", ::apache::thrift::protocol::T_STRING, 21);
  xfer += oprot->writeString(this->geo_layer_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_endpoint", ::apache::thrift::protocol::T_STRING, 22);
  xfer += oprot->writeString(this->s3_endpoint);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCopyParams &a, TCopyParams &b) {
  using ::std::swap;
  swap(a.delimiter, b.delimiter);
  swap(a.null_str, b.null_str);
  swap(a.has_header, b.has_header);
  swap(a.quoted, b.quoted);
  swap(a.quote, b.quote);
  swap(a.escape, b.escape);
  swap(a.line_delim, b.line_delim);
  swap(a.array_delim, b.array_delim);
  swap(a.array_begin, b.array_begin);
  swap(a.array_end, b.array_end);
  swap(a.threads, b.threads);
  swap(a.file_type, b.file_type);
  swap(a.s3_access_key, b.s3_access_key);
  swap(a.s3_secret_key, b.s3_secret_key);
  swap(a.s3_region, b.s3_region);
  swap(a.geo_coords_encoding, b.geo_coords_encoding);
  swap(a.geo_coords_comp_param, b.geo_coords_comp_param);
  swap(a.geo_coords_type, b.geo_coords_type);
  swap(a.geo_coords_srid, b.geo_coords_srid);
  swap(a.sanitize_column_names, b.sanitize_column_names);
  swap(a.geo_layer_name, b.geo_layer_name);
  swap(a.s3_endpoint, b.s3_endpoint);
  swap(a.__isset, b.__isset);
}

TCopyParams::TCopyParams(const TCopyParams& other105) {
  delimiter = other105.delimiter;
  null_str = other105.null_str;
  has_header = other105.has_header;
  quoted = other105.quoted;
  quote = other105.quote;
  escape = other105.escape;
  line_delim = other105.line_delim;
  array_delim = other105.array_delim;
  array_begin = other105.array_begin;
  array_end = other105.array_end;
  threads = other105.threads;
  file_type = other105.file_type;
  s3_access_key = other105.s3_access_key;
  s3_secret_key = other105.s3_secret_key;
  s3_region = other105.s3_region;
  geo_coords_encoding = other105.geo_coords_encoding;
  geo_coords_comp_param = other105.geo_coords_comp_param;
  geo_coords_type = other105.geo_coords_type;
  geo_coords_srid = other105.geo_coords_srid;
  sanitize_column_names = other105.sanitize_column_names;
  geo_layer_name = other105.geo_layer_name;
  s3_endpoint = other105.s3_endpoint;
  __isset = other105.__isset;
}
TCopyParams& TCopyParams::operator=(const TCopyParams& other106) {
  delimiter = other106.delimiter;
  null_str = other106.null_str;
  has_header = other106.has_header;
  quoted = other106.quoted;
  quote = other106.quote;
  escape = other106.escape;
  line_delim = other106.line_delim;
  array_delim = other106.array_delim;
  array_begin = other106.array_begin;
  array_end = other106.array_end;
  threads = other106.threads;
  file_type = other106.file_type;
  s3_access_key = other106.s3_access_key;
  s3_secret_key = other106.s3_secret_key;
  s3_region = other106.s3_region;
  geo_coords_encoding = other106.geo_coords_encoding;
  geo_coords_comp_param = other106.geo_coords_comp_param;
  geo_coords_type = other106.geo_coords_type;
  geo_coords_srid = other106.geo_coords_srid;
  sanitize_column_names = other106.sanitize_column_names;
  geo_layer_name = other106.geo_layer_name;
  s3_endpoint = other106.s3_endpoint;
  __isset = other106.__isset;
  return *this;
}
void TCopyParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCopyParams(";
  out << "delimiter=" << to_string(delimiter);
  out << ", " << "null_str=" << to_string(null_str);
  out << ", " << "has_header=" << to_string(has_header);
  out << ", " << "quoted=" << to_string(quoted);
  out << ", " << "quote=" << to_string(quote);
  out << ", " << "escape=" << to_string(escape);
  out << ", " << "line_delim=" << to_string(line_delim);
  out << ", " << "array_delim=" << to_string(array_delim);
  out << ", " << "array_begin=" << to_string(array_begin);
  out << ", " << "array_end=" << to_string(array_end);
  out << ", " << "threads=" << to_string(threads);
  out << ", " << "file_type=" << to_string(file_type);
  out << ", " << "s3_access_key=" << to_string(s3_access_key);
  out << ", " << "s3_secret_key=" << to_string(s3_secret_key);
  out << ", " << "s3_region=" << to_string(s3_region);
  out << ", " << "geo_coords_encoding=" << to_string(geo_coords_encoding);
  out << ", " << "geo_coords_comp_param=" << to_string(geo_coords_comp_param);
  out << ", " << "geo_coords_type=" << to_string(geo_coords_type);
  out << ", " << "geo_coords_srid=" << to_string(geo_coords_srid);
  out << ", " << "sanitize_column_names=" << to_string(sanitize_column_names);
  out << ", " << "geo_layer_name=" << to_string(geo_layer_name);
  out << ", " << "s3_endpoint=" << to_string(s3_endpoint);
  out << ")";
}


TCreateParams::~TCreateParams() throw() {
}


void TCreateParams::__set_is_replicated(const bool val) {
  this->is_replicated = val;
}
std::ostream& operator<<(std::ostream& out, const TCreateParams& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCreateParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_replicated);
          this->__isset.is_replicated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCreateParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCreateParams");

  xfer += oprot->writeFieldBegin("is_replicated", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_replicated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCreateParams &a, TCreateParams &b) {
  using ::std::swap;
  swap(a.is_replicated, b.is_replicated);
  swap(a.__isset, b.__isset);
}

TCreateParams::TCreateParams(const TCreateParams& other107) {
  is_replicated = other107.is_replicated;
  __isset = other107.__isset;
}
TCreateParams& TCreateParams::operator=(const TCreateParams& other108) {
  is_replicated = other108.is_replicated;
  __isset = other108.__isset;
  return *this;
}
void TCreateParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCreateParams(";
  out << "is_replicated=" << to_string(is_replicated);
  out << ")";
}


TDetectResult::~TDetectResult() throw() {
}


void TDetectResult::__set_row_set(const TRowSet& val) {
  this->row_set = val;
}

void TDetectResult::__set_copy_params(const TCopyParams& val) {
  this->copy_params = val;
}
std::ostream& operator<<(std::ostream& out, const TDetectResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDetectResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_set.read(iprot);
          this->__isset.row_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->copy_params.read(iprot);
          this->__isset.copy_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDetectResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDetectResult");

  xfer += oprot->writeFieldBegin("row_set", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->row_set.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("copy_params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->copy_params.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDetectResult &a, TDetectResult &b) {
  using ::std::swap;
  swap(a.row_set, b.row_set);
  swap(a.copy_params, b.copy_params);
  swap(a.__isset, b.__isset);
}

TDetectResult::TDetectResult(const TDetectResult& other109) {
  row_set = other109.row_set;
  copy_params = other109.copy_params;
  __isset = other109.__isset;
}
TDetectResult& TDetectResult::operator=(const TDetectResult& other110) {
  row_set = other110.row_set;
  copy_params = other110.copy_params;
  __isset = other110.__isset;
  return *this;
}
void TDetectResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDetectResult(";
  out << "row_set=" << to_string(row_set);
  out << ", " << "copy_params=" << to_string(copy_params);
  out << ")";
}


TImportStatus::~TImportStatus() throw() {
}


void TImportStatus::__set_elapsed(const int64_t val) {
  this->elapsed = val;
}

void TImportStatus::__set_rows_completed(const int64_t val) {
  this->rows_completed = val;
}

void TImportStatus::__set_rows_estimated(const int64_t val) {
  this->rows_estimated = val;
}

void TImportStatus::__set_rows_rejected(const int64_t val) {
  this->rows_rejected = val;
}
std::ostream& operator<<(std::ostream& out, const TImportStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TImportStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->elapsed);
          this->__isset.elapsed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows_completed);
          this->__isset.rows_completed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows_estimated);
          this->__isset.rows_estimated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows_rejected);
          this->__isset.rows_rejected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TImportStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TImportStatus");

  xfer += oprot->writeFieldBegin("elapsed", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->elapsed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows_completed", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->rows_completed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows_estimated", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->rows_estimated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows_rejected", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->rows_rejected);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TImportStatus &a, TImportStatus &b) {
  using ::std::swap;
  swap(a.elapsed, b.elapsed);
  swap(a.rows_completed, b.rows_completed);
  swap(a.rows_estimated, b.rows_estimated);
  swap(a.rows_rejected, b.rows_rejected);
  swap(a.__isset, b.__isset);
}

TImportStatus::TImportStatus(const TImportStatus& other111) {
  elapsed = other111.elapsed;
  rows_completed = other111.rows_completed;
  rows_estimated = other111.rows_estimated;
  rows_rejected = other111.rows_rejected;
  __isset = other111.__isset;
}
TImportStatus& TImportStatus::operator=(const TImportStatus& other112) {
  elapsed = other112.elapsed;
  rows_completed = other112.rows_completed;
  rows_estimated = other112.rows_estimated;
  rows_rejected = other112.rows_rejected;
  __isset = other112.__isset;
  return *this;
}
void TImportStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TImportStatus(";
  out << "elapsed=" << to_string(elapsed);
  out << ", " << "rows_completed=" << to_string(rows_completed);
  out << ", " << "rows_estimated=" << to_string(rows_estimated);
  out << ", " << "rows_rejected=" << to_string(rows_rejected);
  out << ")";
}


TFrontendView::~TFrontendView() throw() {
}


void TFrontendView::__set_view_name(const std::string& val) {
  this->view_name = val;
}

void TFrontendView::__set_view_state(const std::string& val) {
  this->view_state = val;
}

void TFrontendView::__set_image_hash(const std::string& val) {
  this->image_hash = val;
}

void TFrontendView::__set_update_time(const std::string& val) {
  this->update_time = val;
}

void TFrontendView::__set_view_metadata(const std::string& val) {
  this->view_metadata = val;
}
std::ostream& operator<<(std::ostream& out, const TFrontendView& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TFrontendView::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_name);
          this->__isset.view_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_state);
          this->__isset.view_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->image_hash);
          this->__isset.image_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->update_time);
          this->__isset.update_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_metadata);
          this->__isset.view_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TFrontendView::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFrontendView");

  xfer += oprot->writeFieldBegin("view_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->view_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_state", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->view_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("image_hash", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->image_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_time", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->update_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_metadata", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->view_metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFrontendView &a, TFrontendView &b) {
  using ::std::swap;
  swap(a.view_name, b.view_name);
  swap(a.view_state, b.view_state);
  swap(a.image_hash, b.image_hash);
  swap(a.update_time, b.update_time);
  swap(a.view_metadata, b.view_metadata);
  swap(a.__isset, b.__isset);
}

TFrontendView::TFrontendView(const TFrontendView& other113) {
  view_name = other113.view_name;
  view_state = other113.view_state;
  image_hash = other113.image_hash;
  update_time = other113.update_time;
  view_metadata = other113.view_metadata;
  __isset = other113.__isset;
}
TFrontendView& TFrontendView::operator=(const TFrontendView& other114) {
  view_name = other114.view_name;
  view_state = other114.view_state;
  image_hash = other114.image_hash;
  update_time = other114.update_time;
  view_metadata = other114.view_metadata;
  __isset = other114.__isset;
  return *this;
}
void TFrontendView::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFrontendView(";
  out << "view_name=" << to_string(view_name);
  out << ", " << "view_state=" << to_string(view_state);
  out << ", " << "image_hash=" << to_string(image_hash);
  out << ", " << "update_time=" << to_string(update_time);
  out << ", " << "view_metadata=" << to_string(view_metadata);
  out << ")";
}


TDashboard::~TDashboard() throw() {
}


void TDashboard::__set_dashboard_name(const std::string& val) {
  this->dashboard_name = val;
}

void TDashboard::__set_dashboard_state(const std::string& val) {
  this->dashboard_state = val;
}

void TDashboard::__set_image_hash(const std::string& val) {
  this->image_hash = val;
}

void TDashboard::__set_update_time(const std::string& val) {
  this->update_time = val;
}

void TDashboard::__set_dashboard_metadata(const std::string& val) {
  this->dashboard_metadata = val;
}

void TDashboard::__set_dashboard_id(const int32_t val) {
  this->dashboard_id = val;
}

void TDashboard::__set_dashboard_owner(const std::string& val) {
  this->dashboard_owner = val;
}

void TDashboard::__set_is_dash_shared(const bool val) {
  this->is_dash_shared = val;
}
std::ostream& operator<<(std::ostream& out, const TDashboard& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDashboard::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_name);
          this->__isset.dashboard_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_state);
          this->__isset.dashboard_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->image_hash);
          this->__isset.image_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->update_time);
          this->__isset.update_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_metadata);
          this->__isset.dashboard_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dashboard_id);
          this->__isset.dashboard_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_owner);
          this->__isset.dashboard_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_dash_shared);
          this->__isset.is_dash_shared = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDashboard::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDashboard");

  xfer += oprot->writeFieldBegin("dashboard_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dashboard_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_state", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dashboard_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("image_hash", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->image_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_time", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->update_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_metadata", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->dashboard_metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_id", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->dashboard_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_owner", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->dashboard_owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_dash_shared", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->is_dash_shared);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDashboard &a, TDashboard &b) {
  using ::std::swap;
  swap(a.dashboard_name, b.dashboard_name);
  swap(a.dashboard_state, b.dashboard_state);
  swap(a.image_hash, b.image_hash);
  swap(a.update_time, b.update_time);
  swap(a.dashboard_metadata, b.dashboard_metadata);
  swap(a.dashboard_id, b.dashboard_id);
  swap(a.dashboard_owner, b.dashboard_owner);
  swap(a.is_dash_shared, b.is_dash_shared);
  swap(a.__isset, b.__isset);
}

TDashboard::TDashboard(const TDashboard& other115) {
  dashboard_name = other115.dashboard_name;
  dashboard_state = other115.dashboard_state;
  image_hash = other115.image_hash;
  update_time = other115.update_time;
  dashboard_metadata = other115.dashboard_metadata;
  dashboard_id = other115.dashboard_id;
  dashboard_owner = other115.dashboard_owner;
  is_dash_shared = other115.is_dash_shared;
  __isset = other115.__isset;
}
TDashboard& TDashboard::operator=(const TDashboard& other116) {
  dashboard_name = other116.dashboard_name;
  dashboard_state = other116.dashboard_state;
  image_hash = other116.image_hash;
  update_time = other116.update_time;
  dashboard_metadata = other116.dashboard_metadata;
  dashboard_id = other116.dashboard_id;
  dashboard_owner = other116.dashboard_owner;
  is_dash_shared = other116.is_dash_shared;
  __isset = other116.__isset;
  return *this;
}
void TDashboard::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDashboard(";
  out << "dashboard_name=" << to_string(dashboard_name);
  out << ", " << "dashboard_state=" << to_string(dashboard_state);
  out << ", " << "image_hash=" << to_string(image_hash);
  out << ", " << "update_time=" << to_string(update_time);
  out << ", " << "dashboard_metadata=" << to_string(dashboard_metadata);
  out << ", " << "dashboard_id=" << to_string(dashboard_id);
  out << ", " << "dashboard_owner=" << to_string(dashboard_owner);
  out << ", " << "is_dash_shared=" << to_string(is_dash_shared);
  out << ")";
}


TServerStatus::~TServerStatus() throw() {
}


void TServerStatus::__set_read_only(const bool val) {
  this->read_only = val;
}

void TServerStatus::__set_version(const std::string& val) {
  this->version = val;
}

void TServerStatus::__set_rendering_enabled(const bool val) {
  this->rendering_enabled = val;
}

void TServerStatus::__set_start_time(const int64_t val) {
  this->start_time = val;
}

void TServerStatus::__set_edition(const std::string& val) {
  this->edition = val;
}

void TServerStatus::__set_host_name(const std::string& val) {
  this->host_name = val;
}

void TServerStatus::__set_poly_rendering_enabled(const bool val) {
  this->poly_rendering_enabled = val;
}

void TServerStatus::__set_role(const TRole::type val) {
  this->role = val;
}
std::ostream& operator<<(std::ostream& out, const TServerStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TServerStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->read_only);
          this->__isset.read_only = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rendering_enabled);
          this->__isset.rendering_enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_time);
          this->__isset.start_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->edition);
          this->__isset.edition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->poly_rendering_enabled);
          this->__isset.poly_rendering_enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast117;
          xfer += iprot->readI32(ecast117);
          this->role = (TRole::type)ecast117;
          this->__isset.role = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TServerStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TServerStatus");

  xfer += oprot->writeFieldBegin("read_only", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->read_only);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rendering_enabled", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->rendering_enabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_time", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->start_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("edition", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->edition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->host_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("poly_rendering_enabled", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->poly_rendering_enabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("role", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32((int32_t)this->role);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TServerStatus &a, TServerStatus &b) {
  using ::std::swap;
  swap(a.read_only, b.read_only);
  swap(a.version, b.version);
  swap(a.rendering_enabled, b.rendering_enabled);
  swap(a.start_time, b.start_time);
  swap(a.edition, b.edition);
  swap(a.host_name, b.host_name);
  swap(a.poly_rendering_enabled, b.poly_rendering_enabled);
  swap(a.role, b.role);
  swap(a.__isset, b.__isset);
}

TServerStatus::TServerStatus(const TServerStatus& other118) {
  read_only = other118.read_only;
  version = other118.version;
  rendering_enabled = other118.rendering_enabled;
  start_time = other118.start_time;
  edition = other118.edition;
  host_name = other118.host_name;
  poly_rendering_enabled = other118.poly_rendering_enabled;
  role = other118.role;
  __isset = other118.__isset;
}
TServerStatus& TServerStatus::operator=(const TServerStatus& other119) {
  read_only = other119.read_only;
  version = other119.version;
  rendering_enabled = other119.rendering_enabled;
  start_time = other119.start_time;
  edition = other119.edition;
  host_name = other119.host_name;
  poly_rendering_enabled = other119.poly_rendering_enabled;
  role = other119.role;
  __isset = other119.__isset;
  return *this;
}
void TServerStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TServerStatus(";
  out << "read_only=" << to_string(read_only);
  out << ", " << "version=" << to_string(version);
  out << ", " << "rendering_enabled=" << to_string(rendering_enabled);
  out << ", " << "start_time=" << to_string(start_time);
  out << ", " << "edition=" << to_string(edition);
  out << ", " << "host_name=" << to_string(host_name);
  out << ", " << "poly_rendering_enabled=" << to_string(poly_rendering_enabled);
  out << ", " << "role=" << to_string(role);
  out << ")";
}


TPixel::~TPixel() throw() {
}


void TPixel::__set_x(const int64_t val) {
  this->x = val;
}

void TPixel::__set_y(const int64_t val) {
  this->y = val;
}
std::ostream& operator<<(std::ostream& out, const TPixel& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPixel::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPixel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPixel");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPixel &a, TPixel &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.__isset, b.__isset);
}

TPixel::TPixel(const TPixel& other120) {
  x = other120.x;
  y = other120.y;
  __isset = other120.__isset;
}
TPixel& TPixel::operator=(const TPixel& other121) {
  x = other121.x;
  y = other121.y;
  __isset = other121.__isset;
  return *this;
}
void TPixel::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPixel(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ")";
}


TPixelTableRowResult::~TPixelTableRowResult() throw() {
}


void TPixelTableRowResult::__set_pixel(const TPixel& val) {
  this->pixel = val;
}

void TPixelTableRowResult::__set_vega_table_name(const std::string& val) {
  this->vega_table_name = val;
}

void TPixelTableRowResult::__set_table_id(const std::vector<int64_t> & val) {
  this->table_id = val;
}

void TPixelTableRowResult::__set_row_id(const std::vector<int64_t> & val) {
  this->row_id = val;
}

void TPixelTableRowResult::__set_row_set(const TRowSet& val) {
  this->row_set = val;
}

void TPixelTableRowResult::__set_nonce(const std::string& val) {
  this->nonce = val;
}
std::ostream& operator<<(std::ostream& out, const TPixelTableRowResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPixelTableRowResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pixel.read(iprot);
          this->__isset.pixel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vega_table_name);
          this->__isset.vega_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->table_id.clear();
            uint32_t _size122;
            ::apache::thrift::protocol::TType _etype125;
            xfer += iprot->readListBegin(_etype125, _size122);
            this->table_id.resize(_size122);
            uint32_t _i126;
            for (_i126 = 0; _i126 < _size122; ++_i126)
            {
              xfer += iprot->readI64(this->table_id[_i126]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_id.clear();
            uint32_t _size127;
            ::apache::thrift::protocol::TType _etype130;
            xfer += iprot->readListBegin(_etype130, _size127);
            this->row_id.resize(_size127);
            uint32_t _i131;
            for (_i131 = 0; _i131 < _size127; ++_i131)
            {
              xfer += iprot->readI64(this->row_id[_i131]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_set.read(iprot);
          this->__isset.row_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          this->__isset.nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPixelTableRowResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPixelTableRowResult");

  xfer += oprot->writeFieldBegin("pixel", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pixel.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vega_table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->vega_table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->table_id.size()));
    std::vector<int64_t> ::const_iterator _iter132;
    for (_iter132 = this->table_id.begin(); _iter132 != this->table_id.end(); ++_iter132)
    {
      xfer += oprot->writeI64((*_iter132));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_id", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->row_id.size()));
    std::vector<int64_t> ::const_iterator _iter133;
    for (_iter133 = this->row_id.begin(); _iter133 != this->row_id.end(); ++_iter133)
    {
      xfer += oprot->writeI64((*_iter133));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_set", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->row_set.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPixelTableRowResult &a, TPixelTableRowResult &b) {
  using ::std::swap;
  swap(a.pixel, b.pixel);
  swap(a.vega_table_name, b.vega_table_name);
  swap(a.table_id, b.table_id);
  swap(a.row_id, b.row_id);
  swap(a.row_set, b.row_set);
  swap(a.nonce, b.nonce);
  swap(a.__isset, b.__isset);
}

TPixelTableRowResult::TPixelTableRowResult(const TPixelTableRowResult& other134) {
  pixel = other134.pixel;
  vega_table_name = other134.vega_table_name;
  table_id = other134.table_id;
  row_id = other134.row_id;
  row_set = other134.row_set;
  nonce = other134.nonce;
  __isset = other134.__isset;
}
TPixelTableRowResult& TPixelTableRowResult::operator=(const TPixelTableRowResult& other135) {
  pixel = other135.pixel;
  vega_table_name = other135.vega_table_name;
  table_id = other135.table_id;
  row_id = other135.row_id;
  row_set = other135.row_set;
  nonce = other135.nonce;
  __isset = other135.__isset;
  return *this;
}
void TPixelTableRowResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPixelTableRowResult(";
  out << "pixel=" << to_string(pixel);
  out << ", " << "vega_table_name=" << to_string(vega_table_name);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "row_id=" << to_string(row_id);
  out << ", " << "row_set=" << to_string(row_set);
  out << ", " << "nonce=" << to_string(nonce);
  out << ")";
}


TRenderResult::~TRenderResult() throw() {
}


void TRenderResult::__set_image(const std::string& val) {
  this->image = val;
}

void TRenderResult::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void TRenderResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TRenderResult::__set_render_time_ms(const int64_t val) {
  this->render_time_ms = val;
}

void TRenderResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}

void TRenderResult::__set_vega_metadata(const std::string& val) {
  this->vega_metadata = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->image);
          this->__isset.image = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          this->__isset.nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->render_time_ms);
          this->__isset.render_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vega_metadata);
          this->__isset.vega_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderResult");

  xfer += oprot->writeFieldBegin("image", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->image);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_time_ms", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->render_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vega_metadata", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->vega_metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderResult &a, TRenderResult &b) {
  using ::std::swap;
  swap(a.image, b.image);
  swap(a.nonce, b.nonce);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.render_time_ms, b.render_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.vega_metadata, b.vega_metadata);
  swap(a.__isset, b.__isset);
}

TRenderResult::TRenderResult(const TRenderResult& other136) {
  image = other136.image;
  nonce = other136.nonce;
  execution_time_ms = other136.execution_time_ms;
  render_time_ms = other136.render_time_ms;
  total_time_ms = other136.total_time_ms;
  vega_metadata = other136.vega_metadata;
  __isset = other136.__isset;
}
TRenderResult& TRenderResult::operator=(const TRenderResult& other137) {
  image = other137.image;
  nonce = other137.nonce;
  execution_time_ms = other137.execution_time_ms;
  render_time_ms = other137.render_time_ms;
  total_time_ms = other137.total_time_ms;
  vega_metadata = other137.vega_metadata;
  __isset = other137.__isset;
  return *this;
}
void TRenderResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderResult(";
  out << "image=" << to_string(image);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "render_time_ms=" << to_string(render_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ", " << "vega_metadata=" << to_string(vega_metadata);
  out << ")";
}


TGpuSpecification::~TGpuSpecification() throw() {
}


void TGpuSpecification::__set_num_sm(const int32_t val) {
  this->num_sm = val;
}

void TGpuSpecification::__set_clock_frequency_kHz(const int64_t val) {
  this->clock_frequency_kHz = val;
}

void TGpuSpecification::__set_memory(const int64_t val) {
  this->memory = val;
}

void TGpuSpecification::__set_compute_capability_major(const int16_t val) {
  this->compute_capability_major = val;
}

void TGpuSpecification::__set_compute_capability_minor(const int16_t val) {
  this->compute_capability_minor = val;
}
std::ostream& operator<<(std::ostream& out, const TGpuSpecification& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGpuSpecification::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_sm);
          this->__isset.num_sm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->clock_frequency_kHz);
          this->__isset.clock_frequency_kHz = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->memory);
          this->__isset.memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->compute_capability_major);
          this->__isset.compute_capability_major = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->compute_capability_minor);
          this->__isset.compute_capability_minor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGpuSpecification::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGpuSpecification");

  xfer += oprot->writeFieldBegin("num_sm", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num_sm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("clock_frequency_kHz", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->clock_frequency_kHz);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("memory", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->memory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compute_capability_major", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->compute_capability_major);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compute_capability_minor", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->compute_capability_minor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGpuSpecification &a, TGpuSpecification &b) {
  using ::std::swap;
  swap(a.num_sm, b.num_sm);
  swap(a.clock_frequency_kHz, b.clock_frequency_kHz);
  swap(a.memory, b.memory);
  swap(a.compute_capability_major, b.compute_capability_major);
  swap(a.compute_capability_minor, b.compute_capability_minor);
  swap(a.__isset, b.__isset);
}

TGpuSpecification::TGpuSpecification(const TGpuSpecification& other138) {
  num_sm = other138.num_sm;
  clock_frequency_kHz = other138.clock_frequency_kHz;
  memory = other138.memory;
  compute_capability_major = other138.compute_capability_major;
  compute_capability_minor = other138.compute_capability_minor;
  __isset = other138.__isset;
}
TGpuSpecification& TGpuSpecification::operator=(const TGpuSpecification& other139) {
  num_sm = other139.num_sm;
  clock_frequency_kHz = other139.clock_frequency_kHz;
  memory = other139.memory;
  compute_capability_major = other139.compute_capability_major;
  compute_capability_minor = other139.compute_capability_minor;
  __isset = other139.__isset;
  return *this;
}
void TGpuSpecification::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGpuSpecification(";
  out << "num_sm=" << to_string(num_sm);
  out << ", " << "clock_frequency_kHz=" << to_string(clock_frequency_kHz);
  out << ", " << "memory=" << to_string(memory);
  out << ", " << "compute_capability_major=" << to_string(compute_capability_major);
  out << ", " << "compute_capability_minor=" << to_string(compute_capability_minor);
  out << ")";
}


THardwareInfo::~THardwareInfo() throw() {
}


void THardwareInfo::__set_num_gpu_hw(const int16_t val) {
  this->num_gpu_hw = val;
}

void THardwareInfo::__set_num_cpu_hw(const int16_t val) {
  this->num_cpu_hw = val;
}

void THardwareInfo::__set_num_gpu_allocated(const int16_t val) {
  this->num_gpu_allocated = val;
}

void THardwareInfo::__set_start_gpu(const int16_t val) {
  this->start_gpu = val;
}

void THardwareInfo::__set_host_name(const std::string& val) {
  this->host_name = val;
}

void THardwareInfo::__set_gpu_info(const std::vector<TGpuSpecification> & val) {
  this->gpu_info = val;
}
std::ostream& operator<<(std::ostream& out, const THardwareInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t THardwareInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->num_gpu_hw);
          this->__isset.num_gpu_hw = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->num_cpu_hw);
          this->__isset.num_cpu_hw = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->num_gpu_allocated);
          this->__isset.num_gpu_allocated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->start_gpu);
          this->__isset.start_gpu = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->gpu_info.clear();
            uint32_t _size140;
            ::apache::thrift::protocol::TType _etype143;
            xfer += iprot->readListBegin(_etype143, _size140);
            this->gpu_info.resize(_size140);
            uint32_t _i144;
            for (_i144 = 0; _i144 < _size140; ++_i144)
            {
              xfer += this->gpu_info[_i144].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.gpu_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t THardwareInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THardwareInfo");

  xfer += oprot->writeFieldBegin("num_gpu_hw", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->num_gpu_hw);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_cpu_hw", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->num_cpu_hw);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_gpu_allocated", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->num_gpu_allocated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_gpu", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->start_gpu);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->host_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gpu_info", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->gpu_info.size()));
    std::vector<TGpuSpecification> ::const_iterator _iter145;
    for (_iter145 = this->gpu_info.begin(); _iter145 != this->gpu_info.end(); ++_iter145)
    {
      xfer += (*_iter145).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THardwareInfo &a, THardwareInfo &b) {
  using ::std::swap;
  swap(a.num_gpu_hw, b.num_gpu_hw);
  swap(a.num_cpu_hw, b.num_cpu_hw);
  swap(a.num_gpu_allocated, b.num_gpu_allocated);
  swap(a.start_gpu, b.start_gpu);
  swap(a.host_name, b.host_name);
  swap(a.gpu_info, b.gpu_info);
  swap(a.__isset, b.__isset);
}

THardwareInfo::THardwareInfo(const THardwareInfo& other146) {
  num_gpu_hw = other146.num_gpu_hw;
  num_cpu_hw = other146.num_cpu_hw;
  num_gpu_allocated = other146.num_gpu_allocated;
  start_gpu = other146.start_gpu;
  host_name = other146.host_name;
  gpu_info = other146.gpu_info;
  __isset = other146.__isset;
}
THardwareInfo& THardwareInfo::operator=(const THardwareInfo& other147) {
  num_gpu_hw = other147.num_gpu_hw;
  num_cpu_hw = other147.num_cpu_hw;
  num_gpu_allocated = other147.num_gpu_allocated;
  start_gpu = other147.start_gpu;
  host_name = other147.host_name;
  gpu_info = other147.gpu_info;
  __isset = other147.__isset;
  return *this;
}
void THardwareInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THardwareInfo(";
  out << "num_gpu_hw=" << to_string(num_gpu_hw);
  out << ", " << "num_cpu_hw=" << to_string(num_cpu_hw);
  out << ", " << "num_gpu_allocated=" << to_string(num_gpu_allocated);
  out << ", " << "start_gpu=" << to_string(start_gpu);
  out << ", " << "host_name=" << to_string(host_name);
  out << ", " << "gpu_info=" << to_string(gpu_info);
  out << ")";
}


TClusterHardwareInfo::~TClusterHardwareInfo() throw() {
}


void TClusterHardwareInfo::__set_hardware_info(const std::vector<THardwareInfo> & val) {
  this->hardware_info = val;
}
std::ostream& operator<<(std::ostream& out, const TClusterHardwareInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TClusterHardwareInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->hardware_info.clear();
            uint32_t _size148;
            ::apache::thrift::protocol::TType _etype151;
            xfer += iprot->readListBegin(_etype151, _size148);
            this->hardware_info.resize(_size148);
            uint32_t _i152;
            for (_i152 = 0; _i152 < _size148; ++_i152)
            {
              xfer += this->hardware_info[_i152].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.hardware_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TClusterHardwareInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TClusterHardwareInfo");

  xfer += oprot->writeFieldBegin("hardware_info", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->hardware_info.size()));
    std::vector<THardwareInfo> ::const_iterator _iter153;
    for (_iter153 = this->hardware_info.begin(); _iter153 != this->hardware_info.end(); ++_iter153)
    {
      xfer += (*_iter153).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TClusterHardwareInfo &a, TClusterHardwareInfo &b) {
  using ::std::swap;
  swap(a.hardware_info, b.hardware_info);
  swap(a.__isset, b.__isset);
}

TClusterHardwareInfo::TClusterHardwareInfo(const TClusterHardwareInfo& other154) {
  hardware_info = other154.hardware_info;
  __isset = other154.__isset;
}
TClusterHardwareInfo& TClusterHardwareInfo::operator=(const TClusterHardwareInfo& other155) {
  hardware_info = other155.hardware_info;
  __isset = other155.__isset;
  return *this;
}
void TClusterHardwareInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TClusterHardwareInfo(";
  out << "hardware_info=" << to_string(hardware_info);
  out << ")";
}


TMemoryData::~TMemoryData() throw() {
}


void TMemoryData::__set_slab(const int64_t val) {
  this->slab = val;
}

void TMemoryData::__set_start_page(const int32_t val) {
  this->start_page = val;
}

void TMemoryData::__set_num_pages(const int64_t val) {
  this->num_pages = val;
}

void TMemoryData::__set_touch(const int32_t val) {
  this->touch = val;
}

void TMemoryData::__set_chunk_key(const std::vector<int64_t> & val) {
  this->chunk_key = val;
}

void TMemoryData::__set_buffer_epoch(const int32_t val) {
  this->buffer_epoch = val;
}

void TMemoryData::__set_is_free(const bool val) {
  this->is_free = val;
}
std::ostream& operator<<(std::ostream& out, const TMemoryData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TMemoryData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->slab);
          this->__isset.slab = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->start_page);
          this->__isset.start_page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_pages);
          this->__isset.num_pages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->touch);
          this->__isset.touch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->chunk_key.clear();
            uint32_t _size156;
            ::apache::thrift::protocol::TType _etype159;
            xfer += iprot->readListBegin(_etype159, _size156);
            this->chunk_key.resize(_size156);
            uint32_t _i160;
            for (_i160 = 0; _i160 < _size156; ++_i160)
            {
              xfer += iprot->readI64(this->chunk_key[_i160]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.chunk_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->buffer_epoch);
          this->__isset.buffer_epoch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_free);
          this->__isset.is_free = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMemoryData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMemoryData");

  xfer += oprot->writeFieldBegin("slab", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->slab);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_page", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->start_page);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_pages", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->num_pages);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("touch", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->touch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("chunk_key", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->chunk_key.size()));
    std::vector<int64_t> ::const_iterator _iter161;
    for (_iter161 = this->chunk_key.begin(); _iter161 != this->chunk_key.end(); ++_iter161)
    {
      xfer += oprot->writeI64((*_iter161));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("buffer_epoch", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->buffer_epoch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_free", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->is_free);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMemoryData &a, TMemoryData &b) {
  using ::std::swap;
  swap(a.slab, b.slab);
  swap(a.start_page, b.start_page);
  swap(a.num_pages, b.num_pages);
  swap(a.touch, b.touch);
  swap(a.chunk_key, b.chunk_key);
  swap(a.buffer_epoch, b.buffer_epoch);
  swap(a.is_free, b.is_free);
  swap(a.__isset, b.__isset);
}

TMemoryData::TMemoryData(const TMemoryData& other162) {
  slab = other162.slab;
  start_page = other162.start_page;
  num_pages = other162.num_pages;
  touch = other162.touch;
  chunk_key = other162.chunk_key;
  buffer_epoch = other162.buffer_epoch;
  is_free = other162.is_free;
  __isset = other162.__isset;
}
TMemoryData& TMemoryData::operator=(const TMemoryData& other163) {
  slab = other163.slab;
  start_page = other163.start_page;
  num_pages = other163.num_pages;
  touch = other163.touch;
  chunk_key = other163.chunk_key;
  buffer_epoch = other163.buffer_epoch;
  is_free = other163.is_free;
  __isset = other163.__isset;
  return *this;
}
void TMemoryData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMemoryData(";
  out << "slab=" << to_string(slab);
  out << ", " << "start_page=" << to_string(start_page);
  out << ", " << "num_pages=" << to_string(num_pages);
  out << ", " << "touch=" << to_string(touch);
  out << ", " << "chunk_key=" << to_string(chunk_key);
  out << ", " << "buffer_epoch=" << to_string(buffer_epoch);
  out << ", " << "is_free=" << to_string(is_free);
  out << ")";
}


TNodeMemoryInfo::~TNodeMemoryInfo() throw() {
}


void TNodeMemoryInfo::__set_host_name(const std::string& val) {
  this->host_name = val;
}

void TNodeMemoryInfo::__set_page_size(const int64_t val) {
  this->page_size = val;
}

void TNodeMemoryInfo::__set_max_num_pages(const int64_t val) {
  this->max_num_pages = val;
}

void TNodeMemoryInfo::__set_num_pages_allocated(const int64_t val) {
  this->num_pages_allocated = val;
}

void TNodeMemoryInfo::__set_is_allocation_capped(const bool val) {
  this->is_allocation_capped = val;
}

void TNodeMemoryInfo::__set_node_memory_data(const std::vector<TMemoryData> & val) {
  this->node_memory_data = val;
}
std::ostream& operator<<(std::ostream& out, const TNodeMemoryInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TNodeMemoryInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->page_size);
          this->__isset.page_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_num_pages);
          this->__isset.max_num_pages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_pages_allocated);
          this->__isset.num_pages_allocated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_allocation_capped);
          this->__isset.is_allocation_capped = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->node_memory_data.clear();
            uint32_t _size164;
            ::apache::thrift::protocol::TType _etype167;
            xfer += iprot->readListBegin(_etype167, _size164);
            this->node_memory_data.resize(_size164);
            uint32_t _i168;
            for (_i168 = 0; _i168 < _size164; ++_i168)
            {
              xfer += this->node_memory_data[_i168].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.node_memory_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TNodeMemoryInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TNodeMemoryInfo");

  xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("page_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->page_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_num_pages", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->max_num_pages);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_pages_allocated", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->num_pages_allocated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_allocation_capped", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_allocation_capped);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_memory_data", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->node_memory_data.size()));
    std::vector<TMemoryData> ::const_iterator _iter169;
    for (_iter169 = this->node_memory_data.begin(); _iter169 != this->node_memory_data.end(); ++_iter169)
    {
      xfer += (*_iter169).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TNodeMemoryInfo &a, TNodeMemoryInfo &b) {
  using ::std::swap;
  swap(a.host_name, b.host_name);
  swap(a.page_size, b.page_size);
  swap(a.max_num_pages, b.max_num_pages);
  swap(a.num_pages_allocated, b.num_pages_allocated);
  swap(a.is_allocation_capped, b.is_allocation_capped);
  swap(a.node_memory_data, b.node_memory_data);
  swap(a.__isset, b.__isset);
}

TNodeMemoryInfo::TNodeMemoryInfo(const TNodeMemoryInfo& other170) {
  host_name = other170.host_name;
  page_size = other170.page_size;
  max_num_pages = other170.max_num_pages;
  num_pages_allocated = other170.num_pages_allocated;
  is_allocation_capped = other170.is_allocation_capped;
  node_memory_data = other170.node_memory_data;
  __isset = other170.__isset;
}
TNodeMemoryInfo& TNodeMemoryInfo::operator=(const TNodeMemoryInfo& other171) {
  host_name = other171.host_name;
  page_size = other171.page_size;
  max_num_pages = other171.max_num_pages;
  num_pages_allocated = other171.num_pages_allocated;
  is_allocation_capped = other171.is_allocation_capped;
  node_memory_data = other171.node_memory_data;
  __isset = other171.__isset;
  return *this;
}
void TNodeMemoryInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TNodeMemoryInfo(";
  out << "host_name=" << to_string(host_name);
  out << ", " << "page_size=" << to_string(page_size);
  out << ", " << "max_num_pages=" << to_string(max_num_pages);
  out << ", " << "num_pages_allocated=" << to_string(num_pages_allocated);
  out << ", " << "is_allocation_capped=" << to_string(is_allocation_capped);
  out << ", " << "node_memory_data=" << to_string(node_memory_data);
  out << ")";
}


TTableMeta::~TTableMeta() throw() {
}


void TTableMeta::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void TTableMeta::__set_num_cols(const int64_t val) {
  this->num_cols = val;
}

void TTableMeta::__set_is_view(const bool val) {
  this->is_view = val;
}

void TTableMeta::__set_is_replicated(const bool val) {
  this->is_replicated = val;
}

void TTableMeta::__set_shard_count(const int64_t val) {
  this->shard_count = val;
}

void TTableMeta::__set_max_rows(const int64_t val) {
  this->max_rows = val;
}

void TTableMeta::__set_table_id(const int64_t val) {
  this->table_id = val;
}

void TTableMeta::__set_max_table_id(const int64_t val) {
  this->max_table_id = val;
}

void TTableMeta::__set_col_types(const std::vector< ::TTypeInfo> & val) {
  this->col_types = val;
}

void TTableMeta::__set_col_names(const std::vector<std::string> & val) {
  this->col_names = val;
}
std::ostream& operator<<(std::ostream& out, const TTableMeta& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableMeta::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_cols);
          this->__isset.num_cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_view);
          this->__isset.is_view = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_replicated);
          this->__isset.is_replicated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->shard_count);
          this->__isset.shard_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_rows);
          this->__isset.max_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_table_id);
          this->__isset.max_table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->col_types.clear();
            uint32_t _size172;
            ::apache::thrift::protocol::TType _etype175;
            xfer += iprot->readListBegin(_etype175, _size172);
            this->col_types.resize(_size172);
            uint32_t _i176;
            for (_i176 = 0; _i176 < _size172; ++_i176)
            {
              xfer += this->col_types[_i176].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.col_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->col_names.clear();
            uint32_t _size177;
            ::apache::thrift::protocol::TType _etype180;
            xfer += iprot->readListBegin(_etype180, _size177);
            this->col_names.resize(_size177);
            uint32_t _i181;
            for (_i181 = 0; _i181 < _size177; ++_i181)
            {
              xfer += iprot->readString(this->col_names[_i181]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.col_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableMeta::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableMeta");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_cols", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->num_cols);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_view", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_view);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_replicated", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_replicated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shard_count", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->shard_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_rows", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->max_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_table_id", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->max_table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_types", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->col_types.size()));
    std::vector< ::TTypeInfo> ::const_iterator _iter182;
    for (_iter182 = this->col_types.begin(); _iter182 != this->col_types.end(); ++_iter182)
    {
      xfer += (*_iter182).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_names", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->col_names.size()));
    std::vector<std::string> ::const_iterator _iter183;
    for (_iter183 = this->col_names.begin(); _iter183 != this->col_names.end(); ++_iter183)
    {
      xfer += oprot->writeString((*_iter183));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableMeta &a, TTableMeta &b) {
  using ::std::swap;
  swap(a.table_name, b.table_name);
  swap(a.num_cols, b.num_cols);
  swap(a.is_view, b.is_view);
  swap(a.is_replicated, b.is_replicated);
  swap(a.shard_count, b.shard_count);
  swap(a.max_rows, b.max_rows);
  swap(a.table_id, b.table_id);
  swap(a.max_table_id, b.max_table_id);
  swap(a.col_types, b.col_types);
  swap(a.col_names, b.col_names);
  swap(a.__isset, b.__isset);
}

TTableMeta::TTableMeta(const TTableMeta& other184) {
  table_name = other184.table_name;
  num_cols = other184.num_cols;
  is_view = other184.is_view;
  is_replicated = other184.is_replicated;
  shard_count = other184.shard_count;
  max_rows = other184.max_rows;
  table_id = other184.table_id;
  max_table_id = other184.max_table_id;
  col_types = other184.col_types;
  col_names = other184.col_names;
  __isset = other184.__isset;
}
TTableMeta& TTableMeta::operator=(const TTableMeta& other185) {
  table_name = other185.table_name;
  num_cols = other185.num_cols;
  is_view = other185.is_view;
  is_replicated = other185.is_replicated;
  shard_count = other185.shard_count;
  max_rows = other185.max_rows;
  table_id = other185.table_id;
  max_table_id = other185.max_table_id;
  col_types = other185.col_types;
  col_names = other185.col_names;
  __isset = other185.__isset;
  return *this;
}
void TTableMeta::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableMeta(";
  out << "table_name=" << to_string(table_name);
  out << ", " << "num_cols=" << to_string(num_cols);
  out << ", " << "is_view=" << to_string(is_view);
  out << ", " << "is_replicated=" << to_string(is_replicated);
  out << ", " << "shard_count=" << to_string(shard_count);
  out << ", " << "max_rows=" << to_string(max_rows);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "max_table_id=" << to_string(max_table_id);
  out << ", " << "col_types=" << to_string(col_types);
  out << ", " << "col_names=" << to_string(col_names);
  out << ")";
}


TTableDetails::~TTableDetails() throw() {
}


void TTableDetails::__set_row_desc(const TRowDescriptor& val) {
  this->row_desc = val;
}

void TTableDetails::__set_fragment_size(const int64_t val) {
  this->fragment_size = val;
}

void TTableDetails::__set_page_size(const int64_t val) {
  this->page_size = val;
}

void TTableDetails::__set_max_rows(const int64_t val) {
  this->max_rows = val;
}

void TTableDetails::__set_view_sql(const std::string& val) {
  this->view_sql = val;
}

void TTableDetails::__set_shard_count(const int64_t val) {
  this->shard_count = val;
}

void TTableDetails::__set_key_metainfo(const std::string& val) {
  this->key_metainfo = val;
}

void TTableDetails::__set_is_temporary(const bool val) {
  this->is_temporary = val;
}

void TTableDetails::__set_partition_detail(const TPartitionDetail::type val) {
  this->partition_detail = val;
}
std::ostream& operator<<(std::ostream& out, const TTableDetails& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableDetails::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_desc.clear();
            uint32_t _size186;
            ::apache::thrift::protocol::TType _etype189;
            xfer += iprot->readListBegin(_etype189, _size186);
            this->row_desc.resize(_size186);
            uint32_t _i190;
            for (_i190 = 0; _i190 < _size186; ++_i190)
            {
              xfer += this->row_desc[_i190].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->fragment_size);
          this->__isset.fragment_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->page_size);
          this->__isset.page_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_rows);
          this->__isset.max_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_sql);
          this->__isset.view_sql = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->shard_count);
          this->__isset.shard_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key_metainfo);
          this->__isset.key_metainfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_temporary);
          this->__isset.is_temporary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast191;
          xfer += iprot->readI32(ecast191);
          this->partition_detail = (TPartitionDetail::type)ecast191;
          this->__isset.partition_detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableDetails::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableDetails");

  xfer += oprot->writeFieldBegin("row_desc", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row_desc.size()));
    std::vector<TColumnType> ::const_iterator _iter192;
    for (_iter192 = this->row_desc.begin(); _iter192 != this->row_desc.end(); ++_iter192)
    {
      xfer += (*_iter192).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fragment_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->fragment_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("page_size", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->page_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_rows", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->max_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_sql", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->view_sql);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shard_count", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->shard_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_metainfo", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->key_metainfo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_temporary", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->is_temporary);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partition_detail", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32((int32_t)this->partition_detail);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableDetails &a, TTableDetails &b) {
  using ::std::swap;
  swap(a.row_desc, b.row_desc);
  swap(a.fragment_size, b.fragment_size);
  swap(a.page_size, b.page_size);
  swap(a.max_rows, b.max_rows);
  swap(a.view_sql, b.view_sql);
  swap(a.shard_count, b.shard_count);
  swap(a.key_metainfo, b.key_metainfo);
  swap(a.is_temporary, b.is_temporary);
  swap(a.partition_detail, b.partition_detail);
  swap(a.__isset, b.__isset);
}

TTableDetails::TTableDetails(const TTableDetails& other193) {
  row_desc = other193.row_desc;
  fragment_size = other193.fragment_size;
  page_size = other193.page_size;
  max_rows = other193.max_rows;
  view_sql = other193.view_sql;
  shard_count = other193.shard_count;
  key_metainfo = other193.key_metainfo;
  is_temporary = other193.is_temporary;
  partition_detail = other193.partition_detail;
  __isset = other193.__isset;
}
TTableDetails& TTableDetails::operator=(const TTableDetails& other194) {
  row_desc = other194.row_desc;
  fragment_size = other194.fragment_size;
  page_size = other194.page_size;
  max_rows = other194.max_rows;
  view_sql = other194.view_sql;
  shard_count = other194.shard_count;
  key_metainfo = other194.key_metainfo;
  is_temporary = other194.is_temporary;
  partition_detail = other194.partition_detail;
  __isset = other194.__isset;
  return *this;
}
void TTableDetails::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableDetails(";
  out << "row_desc=" << to_string(row_desc);
  out << ", " << "fragment_size=" << to_string(fragment_size);
  out << ", " << "page_size=" << to_string(page_size);
  out << ", " << "max_rows=" << to_string(max_rows);
  out << ", " << "view_sql=" << to_string(view_sql);
  out << ", " << "shard_count=" << to_string(shard_count);
  out << ", " << "key_metainfo=" << to_string(key_metainfo);
  out << ", " << "is_temporary=" << to_string(is_temporary);
  out << ", " << "partition_detail=" << to_string(partition_detail);
  out << ")";
}


TColumnRange::~TColumnRange() throw() {
}


void TColumnRange::__set_type(const TExpressionRangeType::type val) {
  this->type = val;
}

void TColumnRange::__set_col_id(const int32_t val) {
  this->col_id = val;
}

void TColumnRange::__set_table_id(const int32_t val) {
  this->table_id = val;
}

void TColumnRange::__set_has_nulls(const bool val) {
  this->has_nulls = val;
}

void TColumnRange::__set_int_min(const int64_t val) {
  this->int_min = val;
}

void TColumnRange::__set_int_max(const int64_t val) {
  this->int_max = val;
}

void TColumnRange::__set_bucket(const int64_t val) {
  this->bucket = val;
}

void TColumnRange::__set_fp_min(const double val) {
  this->fp_min = val;
}

void TColumnRange::__set_fp_max(const double val) {
  this->fp_max = val;
}
std::ostream& operator<<(std::ostream& out, const TColumnRange& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast195;
          xfer += iprot->readI32(ecast195);
          this->type = (TExpressionRangeType::type)ecast195;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->col_id);
          this->__isset.col_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_nulls);
          this->__isset.has_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->int_min);
          this->__isset.int_min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->int_max);
          this->__isset.int_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bucket);
          this->__isset.bucket = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fp_min);
          this->__isset.fp_min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fp_max);
          this->__isset.fp_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnRange");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->col_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_nulls", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->has_nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("int_min", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->int_min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("int_max", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->int_max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bucket", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->bucket);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fp_min", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->fp_min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fp_max", ::apache::thrift::protocol::T_DOUBLE, 9);
  xfer += oprot->writeDouble(this->fp_max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnRange &a, TColumnRange &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.col_id, b.col_id);
  swap(a.table_id, b.table_id);
  swap(a.has_nulls, b.has_nulls);
  swap(a.int_min, b.int_min);
  swap(a.int_max, b.int_max);
  swap(a.bucket, b.bucket);
  swap(a.fp_min, b.fp_min);
  swap(a.fp_max, b.fp_max);
  swap(a.__isset, b.__isset);
}

TColumnRange::TColumnRange(const TColumnRange& other196) {
  type = other196.type;
  col_id = other196.col_id;
  table_id = other196.table_id;
  has_nulls = other196.has_nulls;
  int_min = other196.int_min;
  int_max = other196.int_max;
  bucket = other196.bucket;
  fp_min = other196.fp_min;
  fp_max = other196.fp_max;
  __isset = other196.__isset;
}
TColumnRange& TColumnRange::operator=(const TColumnRange& other197) {
  type = other197.type;
  col_id = other197.col_id;
  table_id = other197.table_id;
  has_nulls = other197.has_nulls;
  int_min = other197.int_min;
  int_max = other197.int_max;
  bucket = other197.bucket;
  fp_min = other197.fp_min;
  fp_max = other197.fp_max;
  __isset = other197.__isset;
  return *this;
}
void TColumnRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnRange(";
  out << "type=" << to_string(type);
  out << ", " << "col_id=" << to_string(col_id);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "has_nulls=" << to_string(has_nulls);
  out << ", " << "int_min=" << to_string(int_min);
  out << ", " << "int_max=" << to_string(int_max);
  out << ", " << "bucket=" << to_string(bucket);
  out << ", " << "fp_min=" << to_string(fp_min);
  out << ", " << "fp_max=" << to_string(fp_max);
  out << ")";
}


TDictionaryGeneration::~TDictionaryGeneration() throw() {
}


void TDictionaryGeneration::__set_dict_id(const int32_t val) {
  this->dict_id = val;
}

void TDictionaryGeneration::__set_entry_count(const int64_t val) {
  this->entry_count = val;
}
std::ostream& operator<<(std::ostream& out, const TDictionaryGeneration& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDictionaryGeneration::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dict_id);
          this->__isset.dict_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->entry_count);
          this->__isset.entry_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDictionaryGeneration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDictionaryGeneration");

  xfer += oprot->writeFieldBegin("dict_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->dict_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entry_count", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->entry_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDictionaryGeneration &a, TDictionaryGeneration &b) {
  using ::std::swap;
  swap(a.dict_id, b.dict_id);
  swap(a.entry_count, b.entry_count);
  swap(a.__isset, b.__isset);
}

TDictionaryGeneration::TDictionaryGeneration(const TDictionaryGeneration& other198) {
  dict_id = other198.dict_id;
  entry_count = other198.entry_count;
  __isset = other198.__isset;
}
TDictionaryGeneration& TDictionaryGeneration::operator=(const TDictionaryGeneration& other199) {
  dict_id = other199.dict_id;
  entry_count = other199.entry_count;
  __isset = other199.__isset;
  return *this;
}
void TDictionaryGeneration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDictionaryGeneration(";
  out << "dict_id=" << to_string(dict_id);
  out << ", " << "entry_count=" << to_string(entry_count);
  out << ")";
}


TTableGeneration::~TTableGeneration() throw() {
}


void TTableGeneration::__set_table_id(const int32_t val) {
  this->table_id = val;
}

void TTableGeneration::__set_tuple_count(const int64_t val) {
  this->tuple_count = val;
}

void TTableGeneration::__set_start_rowid(const int64_t val) {
  this->start_rowid = val;
}
std::ostream& operator<<(std::ostream& out, const TTableGeneration& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableGeneration::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tuple_count);
          this->__isset.tuple_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_rowid);
          this->__isset.start_rowid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableGeneration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableGeneration");

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tuple_count", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->tuple_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_rowid", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->start_rowid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableGeneration &a, TTableGeneration &b) {
  using ::std::swap;
  swap(a.table_id, b.table_id);
  swap(a.tuple_count, b.tuple_count);
  swap(a.start_rowid, b.start_rowid);
  swap(a.__isset, b.__isset);
}

TTableGeneration::TTableGeneration(const TTableGeneration& other200) {
  table_id = other200.table_id;
  tuple_count = other200.tuple_count;
  start_rowid = other200.start_rowid;
  __isset = other200.__isset;
}
TTableGeneration& TTableGeneration::operator=(const TTableGeneration& other201) {
  table_id = other201.table_id;
  tuple_count = other201.tuple_count;
  start_rowid = other201.start_rowid;
  __isset = other201.__isset;
  return *this;
}
void TTableGeneration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableGeneration(";
  out << "table_id=" << to_string(table_id);
  out << ", " << "tuple_count=" << to_string(tuple_count);
  out << ", " << "start_rowid=" << to_string(start_rowid);
  out << ")";
}


TPendingQuery::~TPendingQuery() throw() {
}


void TPendingQuery::__set_id(const TQueryId val) {
  this->id = val;
}

void TPendingQuery::__set_column_ranges(const std::vector<TColumnRange> & val) {
  this->column_ranges = val;
}

void TPendingQuery::__set_dictionary_generations(const std::vector<TDictionaryGeneration> & val) {
  this->dictionary_generations = val;
}

void TPendingQuery::__set_table_generations(const std::vector<TTableGeneration> & val) {
  this->table_generations = val;
}
std::ostream& operator<<(std::ostream& out, const TPendingQuery& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPendingQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_ranges.clear();
            uint32_t _size202;
            ::apache::thrift::protocol::TType _etype205;
            xfer += iprot->readListBegin(_etype205, _size202);
            this->column_ranges.resize(_size202);
            uint32_t _i206;
            for (_i206 = 0; _i206 < _size202; ++_i206)
            {
              xfer += this->column_ranges[_i206].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dictionary_generations.clear();
            uint32_t _size207;
            ::apache::thrift::protocol::TType _etype210;
            xfer += iprot->readListBegin(_etype210, _size207);
            this->dictionary_generations.resize(_size207);
            uint32_t _i211;
            for (_i211 = 0; _i211 < _size207; ++_i211)
            {
              xfer += this->dictionary_generations[_i211].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dictionary_generations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->table_generations.clear();
            uint32_t _size212;
            ::apache::thrift::protocol::TType _etype215;
            xfer += iprot->readListBegin(_etype215, _size212);
            this->table_generations.resize(_size212);
            uint32_t _i216;
            for (_i216 = 0; _i216 < _size212; ++_i216)
            {
              xfer += this->table_generations[_i216].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.table_generations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPendingQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPendingQuery");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_ranges", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_ranges.size()));
    std::vector<TColumnRange> ::const_iterator _iter217;
    for (_iter217 = this->column_ranges.begin(); _iter217 != this->column_ranges.end(); ++_iter217)
    {
      xfer += (*_iter217).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dictionary_generations", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dictionary_generations.size()));
    std::vector<TDictionaryGeneration> ::const_iterator _iter218;
    for (_iter218 = this->dictionary_generations.begin(); _iter218 != this->dictionary_generations.end(); ++_iter218)
    {
      xfer += (*_iter218).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_generations", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->table_generations.size()));
    std::vector<TTableGeneration> ::const_iterator _iter219;
    for (_iter219 = this->table_generations.begin(); _iter219 != this->table_generations.end(); ++_iter219)
    {
      xfer += (*_iter219).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPendingQuery &a, TPendingQuery &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.column_ranges, b.column_ranges);
  swap(a.dictionary_generations, b.dictionary_generations);
  swap(a.table_generations, b.table_generations);
  swap(a.__isset, b.__isset);
}

TPendingQuery::TPendingQuery(const TPendingQuery& other220) {
  id = other220.id;
  column_ranges = other220.column_ranges;
  dictionary_generations = other220.dictionary_generations;
  table_generations = other220.table_generations;
  __isset = other220.__isset;
}
TPendingQuery& TPendingQuery::operator=(const TPendingQuery& other221) {
  id = other221.id;
  column_ranges = other221.column_ranges;
  dictionary_generations = other221.dictionary_generations;
  table_generations = other221.table_generations;
  __isset = other221.__isset;
  return *this;
}
void TPendingQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPendingQuery(";
  out << "id=" << to_string(id);
  out << ", " << "column_ranges=" << to_string(column_ranges);
  out << ", " << "dictionary_generations=" << to_string(dictionary_generations);
  out << ", " << "table_generations=" << to_string(table_generations);
  out << ")";
}


TVarLen::~TVarLen() throw() {
}


void TVarLen::__set_payload(const std::string& val) {
  this->payload = val;
}

void TVarLen::__set_is_null(const bool val) {
  this->is_null = val;
}
std::ostream& operator<<(std::ostream& out, const TVarLen& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TVarLen::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->payload);
          this->__isset.payload = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_null);
          this->__isset.is_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TVarLen::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TVarLen");

  xfer += oprot->writeFieldBegin("payload", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->payload);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_null", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TVarLen &a, TVarLen &b) {
  using ::std::swap;
  swap(a.payload, b.payload);
  swap(a.is_null, b.is_null);
  swap(a.__isset, b.__isset);
}

TVarLen::TVarLen(const TVarLen& other222) {
  payload = other222.payload;
  is_null = other222.is_null;
  __isset = other222.__isset;
}
TVarLen& TVarLen::operator=(const TVarLen& other223) {
  payload = other223.payload;
  is_null = other223.is_null;
  __isset = other223.__isset;
  return *this;
}
void TVarLen::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TVarLen(";
  out << "payload=" << to_string(payload);
  out << ", " << "is_null=" << to_string(is_null);
  out << ")";
}


TDataBlockPtr::~TDataBlockPtr() throw() {
}


void TDataBlockPtr::__set_fixed_len_data(const std::string& val) {
  this->fixed_len_data = val;
__isset.fixed_len_data = true;
}

void TDataBlockPtr::__set_var_len_data(const std::vector<TVarLen> & val) {
  this->var_len_data = val;
__isset.var_len_data = true;
}
std::ostream& operator<<(std::ostream& out, const TDataBlockPtr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDataBlockPtr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->fixed_len_data);
          this->__isset.fixed_len_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->var_len_data.clear();
            uint32_t _size224;
            ::apache::thrift::protocol::TType _etype227;
            xfer += iprot->readListBegin(_etype227, _size224);
            this->var_len_data.resize(_size224);
            uint32_t _i228;
            for (_i228 = 0; _i228 < _size224; ++_i228)
            {
              xfer += this->var_len_data[_i228].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.var_len_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDataBlockPtr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataBlockPtr");

  if (this->__isset.fixed_len_data) {
    xfer += oprot->writeFieldBegin("fixed_len_data", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->fixed_len_data);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.var_len_data) {
    xfer += oprot->writeFieldBegin("var_len_data", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->var_len_data.size()));
      std::vector<TVarLen> ::const_iterator _iter229;
      for (_iter229 = this->var_len_data.begin(); _iter229 != this->var_len_data.end(); ++_iter229)
      {
        xfer += (*_iter229).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDataBlockPtr &a, TDataBlockPtr &b) {
  using ::std::swap;
  swap(a.fixed_len_data, b.fixed_len_data);
  swap(a.var_len_data, b.var_len_data);
  swap(a.__isset, b.__isset);
}

TDataBlockPtr::TDataBlockPtr(const TDataBlockPtr& other230) {
  fixed_len_data = other230.fixed_len_data;
  var_len_data = other230.var_len_data;
  __isset = other230.__isset;
}
TDataBlockPtr& TDataBlockPtr::operator=(const TDataBlockPtr& other231) {
  fixed_len_data = other231.fixed_len_data;
  var_len_data = other231.var_len_data;
  __isset = other231.__isset;
  return *this;
}
void TDataBlockPtr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDataBlockPtr(";
  out << "fixed_len_data="; (__isset.fixed_len_data ? (out << to_string(fixed_len_data)) : (out << "<null>"));
  out << ", " << "var_len_data="; (__isset.var_len_data ? (out << to_string(var_len_data)) : (out << "<null>"));
  out << ")";
}


TInsertData::~TInsertData() throw() {
}


void TInsertData::__set_db_id(const int32_t val) {
  this->db_id = val;
}

void TInsertData::__set_table_id(const int32_t val) {
  this->table_id = val;
}

void TInsertData::__set_column_ids(const std::vector<int32_t> & val) {
  this->column_ids = val;
}

void TInsertData::__set_data(const std::vector<TDataBlockPtr> & val) {
  this->data = val;
}

void TInsertData::__set_num_rows(const int64_t val) {
  this->num_rows = val;
}
std::ostream& operator<<(std::ostream& out, const TInsertData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TInsertData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->db_id);
          this->__isset.db_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_ids.clear();
            uint32_t _size232;
            ::apache::thrift::protocol::TType _etype235;
            xfer += iprot->readListBegin(_etype235, _size232);
            this->column_ids.resize(_size232);
            uint32_t _i236;
            for (_i236 = 0; _i236 < _size232; ++_i236)
            {
              xfer += iprot->readI32(this->column_ids[_i236]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size237;
            ::apache::thrift::protocol::TType _etype240;
            xfer += iprot->readListBegin(_etype240, _size237);
            this->data.resize(_size237);
            uint32_t _i241;
            for (_i241 = 0; _i241 < _size237; ++_i241)
            {
              xfer += this->data[_i241].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_rows);
          this->__isset.num_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TInsertData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TInsertData");

  xfer += oprot->writeFieldBegin("db_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->db_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_ids", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->column_ids.size()));
    std::vector<int32_t> ::const_iterator _iter242;
    for (_iter242 = this->column_ids.begin(); _iter242 != this->column_ids.end(); ++_iter242)
    {
      xfer += oprot->writeI32((*_iter242));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->data.size()));
    std::vector<TDataBlockPtr> ::const_iterator _iter243;
    for (_iter243 = this->data.begin(); _iter243 != this->data.end(); ++_iter243)
    {
      xfer += (*_iter243).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_rows", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->num_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TInsertData &a, TInsertData &b) {
  using ::std::swap;
  swap(a.db_id, b.db_id);
  swap(a.table_id, b.table_id);
  swap(a.column_ids, b.column_ids);
  swap(a.data, b.data);
  swap(a.num_rows, b.num_rows);
  swap(a.__isset, b.__isset);
}

TInsertData::TInsertData(const TInsertData& other244) {
  db_id = other244.db_id;
  table_id = other244.table_id;
  column_ids = other244.column_ids;
  data = other244.data;
  num_rows = other244.num_rows;
  __isset = other244.__isset;
}
TInsertData& TInsertData::operator=(const TInsertData& other245) {
  db_id = other245.db_id;
  table_id = other245.table_id;
  column_ids = other245.column_ids;
  data = other245.data;
  num_rows = other245.num_rows;
  __isset = other245.__isset;
  return *this;
}
void TInsertData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TInsertData(";
  out << "db_id=" << to_string(db_id);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "column_ids=" << to_string(column_ids);
  out << ", " << "data=" << to_string(data);
  out << ", " << "num_rows=" << to_string(num_rows);
  out << ")";
}


TPendingRenderQuery::~TPendingRenderQuery() throw() {
}


void TPendingRenderQuery::__set_id(const TQueryId val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const TPendingRenderQuery& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPendingRenderQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPendingRenderQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPendingRenderQuery");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPendingRenderQuery &a, TPendingRenderQuery &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

TPendingRenderQuery::TPendingRenderQuery(const TPendingRenderQuery& other246) {
  id = other246.id;
  __isset = other246.__isset;
}
TPendingRenderQuery& TPendingRenderQuery::operator=(const TPendingRenderQuery& other247) {
  id = other247.id;
  __isset = other247.__isset;
  return *this;
}
void TPendingRenderQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPendingRenderQuery(";
  out << "id=" << to_string(id);
  out << ")";
}


TRenderParseResult::~TRenderParseResult() throw() {
}


void TRenderParseResult::__set_merge_type(const TMergeType::type val) {
  this->merge_type = val;
}

void TRenderParseResult::__set_node_id(const int32_t val) {
  this->node_id = val;
}

void TRenderParseResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TRenderParseResult::__set_render_time_ms(const int64_t val) {
  this->render_time_ms = val;
}

void TRenderParseResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderParseResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderParseResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast248;
          xfer += iprot->readI32(ecast248);
          this->merge_type = (TMergeType::type)ecast248;
          this->__isset.merge_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->render_time_ms);
          this->__isset.render_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderParseResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderParseResult");

  xfer += oprot->writeFieldBegin("merge_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->merge_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_time_ms", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->render_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderParseResult &a, TRenderParseResult &b) {
  using ::std::swap;
  swap(a.merge_type, b.merge_type);
  swap(a.node_id, b.node_id);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.render_time_ms, b.render_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.__isset, b.__isset);
}

TRenderParseResult::TRenderParseResult(const TRenderParseResult& other249) {
  merge_type = other249.merge_type;
  node_id = other249.node_id;
  execution_time_ms = other249.execution_time_ms;
  render_time_ms = other249.render_time_ms;
  total_time_ms = other249.total_time_ms;
  __isset = other249.__isset;
}
TRenderParseResult& TRenderParseResult::operator=(const TRenderParseResult& other250) {
  merge_type = other250.merge_type;
  node_id = other250.node_id;
  execution_time_ms = other250.execution_time_ms;
  render_time_ms = other250.render_time_ms;
  total_time_ms = other250.total_time_ms;
  __isset = other250.__isset;
  return *this;
}
void TRenderParseResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderParseResult(";
  out << "merge_type=" << to_string(merge_type);
  out << ", " << "node_id=" << to_string(node_id);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "render_time_ms=" << to_string(render_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ")";
}


TRawRenderPassDataResult::~TRawRenderPassDataResult() throw() {
}


void TRawRenderPassDataResult::__set_num_pixel_channels(const int32_t val) {
  this->num_pixel_channels = val;
}

void TRawRenderPassDataResult::__set_num_pixel_samples(const int32_t val) {
  this->num_pixel_samples = val;
}

void TRawRenderPassDataResult::__set_pixels(const std::string& val) {
  this->pixels = val;
}

void TRawRenderPassDataResult::__set_row_ids_A(const std::string& val) {
  this->row_ids_A = val;
}

void TRawRenderPassDataResult::__set_row_ids_B(const std::string& val) {
  this->row_ids_B = val;
}

void TRawRenderPassDataResult::__set_table_ids(const std::string& val) {
  this->table_ids = val;
}

void TRawRenderPassDataResult::__set_accum_data(const std::string& val) {
  this->accum_data = val;
}
std::ostream& operator<<(std::ostream& out, const TRawRenderPassDataResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRawRenderPassDataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_pixel_channels);
          this->__isset.num_pixel_channels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_pixel_samples);
          this->__isset.num_pixel_samples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pixels);
          this->__isset.pixels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row_ids_A);
          this->__isset.row_ids_A = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row_ids_B);
          this->__isset.row_ids_B = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->table_ids);
          this->__isset.table_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->accum_data);
          this->__isset.accum_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRawRenderPassDataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRawRenderPassDataResult");

  xfer += oprot->writeFieldBegin("num_pixel_channels", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num_pixel_channels);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_pixel_samples", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num_pixel_samples);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pixels", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->pixels);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_ids_A", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->row_ids_A);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_ids_B", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->row_ids_B);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_ids", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->table_ids);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("accum_data", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeBinary(this->accum_data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRawRenderPassDataResult &a, TRawRenderPassDataResult &b) {
  using ::std::swap;
  swap(a.num_pixel_channels, b.num_pixel_channels);
  swap(a.num_pixel_samples, b.num_pixel_samples);
  swap(a.pixels, b.pixels);
  swap(a.row_ids_A, b.row_ids_A);
  swap(a.row_ids_B, b.row_ids_B);
  swap(a.table_ids, b.table_ids);
  swap(a.accum_data, b.accum_data);
  swap(a.__isset, b.__isset);
}

TRawRenderPassDataResult::TRawRenderPassDataResult(const TRawRenderPassDataResult& other251) {
  num_pixel_channels = other251.num_pixel_channels;
  num_pixel_samples = other251.num_pixel_samples;
  pixels = other251.pixels;
  row_ids_A = other251.row_ids_A;
  row_ids_B = other251.row_ids_B;
  table_ids = other251.table_ids;
  accum_data = other251.accum_data;
  __isset = other251.__isset;
}
TRawRenderPassDataResult& TRawRenderPassDataResult::operator=(const TRawRenderPassDataResult& other252) {
  num_pixel_channels = other252.num_pixel_channels;
  num_pixel_samples = other252.num_pixel_samples;
  pixels = other252.pixels;
  row_ids_A = other252.row_ids_A;
  row_ids_B = other252.row_ids_B;
  table_ids = other252.table_ids;
  accum_data = other252.accum_data;
  __isset = other252.__isset;
  return *this;
}
void TRawRenderPassDataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRawRenderPassDataResult(";
  out << "num_pixel_channels=" << to_string(num_pixel_channels);
  out << ", " << "num_pixel_samples=" << to_string(num_pixel_samples);
  out << ", " << "pixels=" << to_string(pixels);
  out << ", " << "row_ids_A=" << to_string(row_ids_A);
  out << ", " << "row_ids_B=" << to_string(row_ids_B);
  out << ", " << "table_ids=" << to_string(table_ids);
  out << ", " << "accum_data=" << to_string(accum_data);
  out << ")";
}


TRawPixelData::~TRawPixelData() throw() {
}


void TRawPixelData::__set_width(const int32_t val) {
  this->width = val;
}

void TRawPixelData::__set_height(const int32_t val) {
  this->height = val;
}

void TRawPixelData::__set_render_pass_map(const TRenderPassMap& val) {
  this->render_pass_map = val;
}
std::ostream& operator<<(std::ostream& out, const TRawPixelData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRawPixelData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->width);
          this->__isset.width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->height);
          this->__isset.height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->render_pass_map.clear();
            uint32_t _size253;
            ::apache::thrift::protocol::TType _ktype254;
            ::apache::thrift::protocol::TType _vtype255;
            xfer += iprot->readMapBegin(_ktype254, _vtype255, _size253);
            uint32_t _i257;
            for (_i257 = 0; _i257 < _size253; ++_i257)
            {
              int32_t _key258;
              xfer += iprot->readI32(_key258);
              TRawRenderPassDataResult& _val259 = this->render_pass_map[_key258];
              xfer += _val259.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.render_pass_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRawPixelData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRawPixelData");

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_pass_map", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->render_pass_map.size()));
    std::map<int32_t, TRawRenderPassDataResult> ::const_iterator _iter260;
    for (_iter260 = this->render_pass_map.begin(); _iter260 != this->render_pass_map.end(); ++_iter260)
    {
      xfer += oprot->writeI32(_iter260->first);
      xfer += _iter260->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRawPixelData &a, TRawPixelData &b) {
  using ::std::swap;
  swap(a.width, b.width);
  swap(a.height, b.height);
  swap(a.render_pass_map, b.render_pass_map);
  swap(a.__isset, b.__isset);
}

TRawPixelData::TRawPixelData(const TRawPixelData& other261) {
  width = other261.width;
  height = other261.height;
  render_pass_map = other261.render_pass_map;
  __isset = other261.__isset;
}
TRawPixelData& TRawPixelData::operator=(const TRawPixelData& other262) {
  width = other262.width;
  height = other262.height;
  render_pass_map = other262.render_pass_map;
  __isset = other262.__isset;
  return *this;
}
void TRawPixelData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRawPixelData(";
  out << "width=" << to_string(width);
  out << ", " << "height=" << to_string(height);
  out << ", " << "render_pass_map=" << to_string(render_pass_map);
  out << ")";
}


TRenderDatum::~TRenderDatum() throw() {
}


void TRenderDatum::__set_type(const  ::TDatumType::type val) {
  this->type = val;
}

void TRenderDatum::__set_cnt(const int32_t val) {
  this->cnt = val;
}

void TRenderDatum::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderDatum& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderDatum::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast263;
          xfer += iprot->readI32(ecast263);
          this->type = ( ::TDatumType::type)ecast263;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cnt);
          this->__isset.cnt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderDatum::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderDatum");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cnt", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->cnt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderDatum &a, TRenderDatum &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.cnt, b.cnt);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TRenderDatum::TRenderDatum(const TRenderDatum& other264) {
  type = other264.type;
  cnt = other264.cnt;
  value = other264.value;
  __isset = other264.__isset;
}
TRenderDatum& TRenderDatum::operator=(const TRenderDatum& other265) {
  type = other265.type;
  cnt = other265.cnt;
  value = other265.value;
  __isset = other265.__isset;
  return *this;
}
void TRenderDatum::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderDatum(";
  out << "type=" << to_string(type);
  out << ", " << "cnt=" << to_string(cnt);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


TRenderStepResult::~TRenderStepResult() throw() {
}


void TRenderStepResult::__set_merge_data(const TRenderAggDataMap& val) {
  this->merge_data = val;
}

void TRenderStepResult::__set_raw_pixel_data(const TRawPixelData& val) {
  this->raw_pixel_data = val;
}

void TRenderStepResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TRenderStepResult::__set_render_time_ms(const int64_t val) {
  this->render_time_ms = val;
}

void TRenderStepResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderStepResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderStepResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->merge_data.clear();
            uint32_t _size266;
            ::apache::thrift::protocol::TType _ktype267;
            ::apache::thrift::protocol::TType _vtype268;
            xfer += iprot->readMapBegin(_ktype267, _vtype268, _size266);
            uint32_t _i270;
            for (_i270 = 0; _i270 < _size266; ++_i270)
            {
              std::string _key271;
              xfer += iprot->readString(_key271);
              std::map<std::string, std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > > & _val272 = this->merge_data[_key271];
              {
                _val272.clear();
                uint32_t _size273;
                ::apache::thrift::protocol::TType _ktype274;
                ::apache::thrift::protocol::TType _vtype275;
                xfer += iprot->readMapBegin(_ktype274, _vtype275, _size273);
                uint32_t _i277;
                for (_i277 = 0; _i277 < _size273; ++_i277)
                {
                  std::string _key278;
                  xfer += iprot->readString(_key278);
                  std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > & _val279 = _val272[_key278];
                  {
                    _val279.clear();
                    uint32_t _size280;
                    ::apache::thrift::protocol::TType _ktype281;
                    ::apache::thrift::protocol::TType _vtype282;
                    xfer += iprot->readMapBegin(_ktype281, _vtype282, _size280);
                    uint32_t _i284;
                    for (_i284 = 0; _i284 < _size280; ++_i284)
                    {
                      std::string _key285;
                      xfer += iprot->readString(_key285);
                      std::map<std::string, std::vector<TRenderDatum> > & _val286 = _val279[_key285];
                      {
                        _val286.clear();
                        uint32_t _size287;
                        ::apache::thrift::protocol::TType _ktype288;
                        ::apache::thrift::protocol::TType _vtype289;
                        xfer += iprot->readMapBegin(_ktype288, _vtype289, _size287);
                        uint32_t _i291;
                        for (_i291 = 0; _i291 < _size287; ++_i291)
                        {
                          std::string _key292;
                          xfer += iprot->readString(_key292);
                          std::vector<TRenderDatum> & _val293 = _val286[_key292];
                          {
                            _val293.clear();
                            uint32_t _size294;
                            ::apache::thrift::protocol::TType _etype297;
                            xfer += iprot->readListBegin(_etype297, _size294);
                            _val293.resize(_size294);
                            uint32_t _i298;
                            for (_i298 = 0; _i298 < _size294; ++_i298)
                            {
                              xfer += _val293[_i298].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                          }
                        }
                        xfer += iprot->readMapEnd();
                      }
                    }
                    xfer += iprot->readMapEnd();
                  }
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.merge_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->raw_pixel_data.read(iprot);
          this->__isset.raw_pixel_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->render_time_ms);
          this->__isset.render_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderStepResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderStepResult");

  xfer += oprot->writeFieldBegin("merge_data", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->merge_data.size()));
    std::map<std::string, std::map<std::string, std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > > > ::const_iterator _iter299;
    for (_iter299 = this->merge_data.begin(); _iter299 != this->merge_data.end(); ++_iter299)
    {
      xfer += oprot->writeString(_iter299->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(_iter299->second.size()));
        std::map<std::string, std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > > ::const_iterator _iter300;
        for (_iter300 = _iter299->second.begin(); _iter300 != _iter299->second.end(); ++_iter300)
        {
          xfer += oprot->writeString(_iter300->first);
          {
            xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(_iter300->second.size()));
            std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > ::const_iterator _iter301;
            for (_iter301 = _iter300->second.begin(); _iter301 != _iter300->second.end(); ++_iter301)
            {
              xfer += oprot->writeString(_iter301->first);
              {
                xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(_iter301->second.size()));
                std::map<std::string, std::vector<TRenderDatum> > ::const_iterator _iter302;
                for (_iter302 = _iter301->second.begin(); _iter302 != _iter301->second.end(); ++_iter302)
                {
                  xfer += oprot->writeString(_iter302->first);
                  {
                    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter302->second.size()));
                    std::vector<TRenderDatum> ::const_iterator _iter303;
                    for (_iter303 = _iter302->second.begin(); _iter303 != _iter302->second.end(); ++_iter303)
                    {
                      xfer += (*_iter303).write(oprot);
                    }
                    xfer += oprot->writeListEnd();
                  }
                }
                xfer += oprot->writeMapEnd();
              }
            }
            xfer += oprot->writeMapEnd();
          }
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("raw_pixel_data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->raw_pixel_data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_time_ms", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->render_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderStepResult &a, TRenderStepResult &b) {
  using ::std::swap;
  swap(a.merge_data, b.merge_data);
  swap(a.raw_pixel_data, b.raw_pixel_data);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.render_time_ms, b.render_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.__isset, b.__isset);
}

TRenderStepResult::TRenderStepResult(const TRenderStepResult& other304) {
  merge_data = other304.merge_data;
  raw_pixel_data = other304.raw_pixel_data;
  execution_time_ms = other304.execution_time_ms;
  render_time_ms = other304.render_time_ms;
  total_time_ms = other304.total_time_ms;
  __isset = other304.__isset;
}
TRenderStepResult& TRenderStepResult::operator=(const TRenderStepResult& other305) {
  merge_data = other305.merge_data;
  raw_pixel_data = other305.raw_pixel_data;
  execution_time_ms = other305.execution_time_ms;
  render_time_ms = other305.render_time_ms;
  total_time_ms = other305.total_time_ms;
  __isset = other305.__isset;
  return *this;
}
void TRenderStepResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderStepResult(";
  out << "merge_data=" << to_string(merge_data);
  out << ", " << "raw_pixel_data=" << to_string(raw_pixel_data);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "render_time_ms=" << to_string(render_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ")";
}


TDatabasePermissions::~TDatabasePermissions() throw() {
}


void TDatabasePermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TDatabasePermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}

void TDatabasePermissions::__set_view_sql_editor_(const bool val) {
  this->view_sql_editor_ = val;
}

void TDatabasePermissions::__set_access_(const bool val) {
  this->access_ = val;
}
std::ostream& operator<<(std::ostream& out, const TDatabasePermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDatabasePermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->view_sql_editor_);
          this->__isset.view_sql_editor_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->access_);
          this->__isset.access_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDatabasePermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDatabasePermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_sql_editor_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->view_sql_editor_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("access_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->access_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDatabasePermissions &a, TDatabasePermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.delete_, b.delete_);
  swap(a.view_sql_editor_, b.view_sql_editor_);
  swap(a.access_, b.access_);
  swap(a.__isset, b.__isset);
}

TDatabasePermissions::TDatabasePermissions(const TDatabasePermissions& other306) {
  create_ = other306.create_;
  delete_ = other306.delete_;
  view_sql_editor_ = other306.view_sql_editor_;
  access_ = other306.access_;
  __isset = other306.__isset;
}
TDatabasePermissions& TDatabasePermissions::operator=(const TDatabasePermissions& other307) {
  create_ = other307.create_;
  delete_ = other307.delete_;
  view_sql_editor_ = other307.view_sql_editor_;
  access_ = other307.access_;
  __isset = other307.__isset;
  return *this;
}
void TDatabasePermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDatabasePermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ", " << "view_sql_editor_=" << to_string(view_sql_editor_);
  out << ", " << "access_=" << to_string(access_);
  out << ")";
}


TTablePermissions::~TTablePermissions() throw() {
}


void TTablePermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TTablePermissions::__set_drop_(const bool val) {
  this->drop_ = val;
}

void TTablePermissions::__set_select_(const bool val) {
  this->select_ = val;
}

void TTablePermissions::__set_insert_(const bool val) {
  this->insert_ = val;
}

void TTablePermissions::__set_update_(const bool val) {
  this->update_ = val;
}

void TTablePermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}

void TTablePermissions::__set_truncate_(const bool val) {
  this->truncate_ = val;
}

void TTablePermissions::__set_alter_(const bool val) {
  this->alter_ = val;
}
std::ostream& operator<<(std::ostream& out, const TTablePermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTablePermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->drop_);
          this->__isset.drop_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->select_);
          this->__isset.select_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->insert_);
          this->__isset.insert_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->update_);
          this->__isset.update_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->truncate_);
          this->__isset.truncate_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->alter_);
          this->__isset.alter_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTablePermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTablePermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("drop_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->drop_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("select_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->select_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("insert_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->insert_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->update_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("truncate_", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->truncate_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("alter_", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->alter_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTablePermissions &a, TTablePermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.drop_, b.drop_);
  swap(a.select_, b.select_);
  swap(a.insert_, b.insert_);
  swap(a.update_, b.update_);
  swap(a.delete_, b.delete_);
  swap(a.truncate_, b.truncate_);
  swap(a.alter_, b.alter_);
  swap(a.__isset, b.__isset);
}

TTablePermissions::TTablePermissions(const TTablePermissions& other308) {
  create_ = other308.create_;
  drop_ = other308.drop_;
  select_ = other308.select_;
  insert_ = other308.insert_;
  update_ = other308.update_;
  delete_ = other308.delete_;
  truncate_ = other308.truncate_;
  alter_ = other308.alter_;
  __isset = other308.__isset;
}
TTablePermissions& TTablePermissions::operator=(const TTablePermissions& other309) {
  create_ = other309.create_;
  drop_ = other309.drop_;
  select_ = other309.select_;
  insert_ = other309.insert_;
  update_ = other309.update_;
  delete_ = other309.delete_;
  truncate_ = other309.truncate_;
  alter_ = other309.alter_;
  __isset = other309.__isset;
  return *this;
}
void TTablePermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTablePermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "drop_=" << to_string(drop_);
  out << ", " << "select_=" << to_string(select_);
  out << ", " << "insert_=" << to_string(insert_);
  out << ", " << "update_=" << to_string(update_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ", " << "truncate_=" << to_string(truncate_);
  out << ", " << "alter_=" << to_string(alter_);
  out << ")";
}


TDashboardPermissions::~TDashboardPermissions() throw() {
}


void TDashboardPermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TDashboardPermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}

void TDashboardPermissions::__set_view_(const bool val) {
  this->view_ = val;
}

void TDashboardPermissions::__set_edit_(const bool val) {
  this->edit_ = val;
}
std::ostream& operator<<(std::ostream& out, const TDashboardPermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDashboardPermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->view_);
          this->__isset.view_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->edit_);
          this->__isset.edit_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDashboardPermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDashboardPermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->view_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("edit_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->edit_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDashboardPermissions &a, TDashboardPermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.delete_, b.delete_);
  swap(a.view_, b.view_);
  swap(a.edit_, b.edit_);
  swap(a.__isset, b.__isset);
}

TDashboardPermissions::TDashboardPermissions(const TDashboardPermissions& other310) {
  create_ = other310.create_;
  delete_ = other310.delete_;
  view_ = other310.view_;
  edit_ = other310.edit_;
  __isset = other310.__isset;
}
TDashboardPermissions& TDashboardPermissions::operator=(const TDashboardPermissions& other311) {
  create_ = other311.create_;
  delete_ = other311.delete_;
  view_ = other311.view_;
  edit_ = other311.edit_;
  __isset = other311.__isset;
  return *this;
}
void TDashboardPermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDashboardPermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ", " << "view_=" << to_string(view_);
  out << ", " << "edit_=" << to_string(edit_);
  out << ")";
}


TViewPermissions::~TViewPermissions() throw() {
}


void TViewPermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TViewPermissions::__set_drop_(const bool val) {
  this->drop_ = val;
}

void TViewPermissions::__set_select_(const bool val) {
  this->select_ = val;
}

void TViewPermissions::__set_insert_(const bool val) {
  this->insert_ = val;
}

void TViewPermissions::__set_update_(const bool val) {
  this->update_ = val;
}

void TViewPermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}
std::ostream& operator<<(std::ostream& out, const TViewPermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TViewPermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->drop_);
          this->__isset.drop_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->select_);
          this->__isset.select_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->insert_);
          this->__isset.insert_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->update_);
          this->__isset.update_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TViewPermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TViewPermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("drop_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->drop_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("select_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->select_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("insert_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->insert_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->update_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TViewPermissions &a, TViewPermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.drop_, b.drop_);
  swap(a.select_, b.select_);
  swap(a.insert_, b.insert_);
  swap(a.update_, b.update_);
  swap(a.delete_, b.delete_);
  swap(a.__isset, b.__isset);
}

TViewPermissions::TViewPermissions(const TViewPermissions& other312) {
  create_ = other312.create_;
  drop_ = other312.drop_;
  select_ = other312.select_;
  insert_ = other312.insert_;
  update_ = other312.update_;
  delete_ = other312.delete_;
  __isset = other312.__isset;
}
TViewPermissions& TViewPermissions::operator=(const TViewPermissions& other313) {
  create_ = other313.create_;
  drop_ = other313.drop_;
  select_ = other313.select_;
  insert_ = other313.insert_;
  update_ = other313.update_;
  delete_ = other313.delete_;
  __isset = other313.__isset;
  return *this;
}
void TViewPermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TViewPermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "drop_=" << to_string(drop_);
  out << ", " << "select_=" << to_string(select_);
  out << ", " << "insert_=" << to_string(insert_);
  out << ", " << "update_=" << to_string(update_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ")";
}


TDBObjectPermissions::~TDBObjectPermissions() throw() {
}


void TDBObjectPermissions::__set_database_permissions_(const TDatabasePermissions& val) {
  this->database_permissions_ = val;
__isset.database_permissions_ = true;
}

void TDBObjectPermissions::__set_table_permissions_(const TTablePermissions& val) {
  this->table_permissions_ = val;
__isset.table_permissions_ = true;
}

void TDBObjectPermissions::__set_dashboard_permissions_(const TDashboardPermissions& val) {
  this->dashboard_permissions_ = val;
__isset.dashboard_permissions_ = true;
}

void TDBObjectPermissions::__set_view_permissions_(const TViewPermissions& val) {
  this->view_permissions_ = val;
__isset.view_permissions_ = true;
}
std::ostream& operator<<(std::ostream& out, const TDBObjectPermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDBObjectPermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->database_permissions_.read(iprot);
          this->__isset.database_permissions_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_permissions_.read(iprot);
          this->__isset.table_permissions_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dashboard_permissions_.read(iprot);
          this->__isset.dashboard_permissions_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->view_permissions_.read(iprot);
          this->__isset.view_permissions_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDBObjectPermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDBObjectPermissions");

  if (this->__isset.database_permissions_) {
    xfer += oprot->writeFieldBegin("database_permissions_", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->database_permissions_.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_permissions_) {
    xfer += oprot->writeFieldBegin("table_permissions_", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->table_permissions_.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dashboard_permissions_) {
    xfer += oprot->writeFieldBegin("dashboard_permissions_", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->dashboard_permissions_.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.view_permissions_) {
    xfer += oprot->writeFieldBegin("view_permissions_", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->view_permissions_.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDBObjectPermissions &a, TDBObjectPermissions &b) {
  using ::std::swap;
  swap(a.database_permissions_, b.database_permissions_);
  swap(a.table_permissions_, b.table_permissions_);
  swap(a.dashboard_permissions_, b.dashboard_permissions_);
  swap(a.view_permissions_, b.view_permissions_);
  swap(a.__isset, b.__isset);
}

TDBObjectPermissions::TDBObjectPermissions(const TDBObjectPermissions& other314) {
  database_permissions_ = other314.database_permissions_;
  table_permissions_ = other314.table_permissions_;
  dashboard_permissions_ = other314.dashboard_permissions_;
  view_permissions_ = other314.view_permissions_;
  __isset = other314.__isset;
}
TDBObjectPermissions& TDBObjectPermissions::operator=(const TDBObjectPermissions& other315) {
  database_permissions_ = other315.database_permissions_;
  table_permissions_ = other315.table_permissions_;
  dashboard_permissions_ = other315.dashboard_permissions_;
  view_permissions_ = other315.view_permissions_;
  __isset = other315.__isset;
  return *this;
}
void TDBObjectPermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDBObjectPermissions(";
  out << "database_permissions_="; (__isset.database_permissions_ ? (out << to_string(database_permissions_)) : (out << "<null>"));
  out << ", " << "table_permissions_="; (__isset.table_permissions_ ? (out << to_string(table_permissions_)) : (out << "<null>"));
  out << ", " << "dashboard_permissions_="; (__isset.dashboard_permissions_ ? (out << to_string(dashboard_permissions_)) : (out << "<null>"));
  out << ", " << "view_permissions_="; (__isset.view_permissions_ ? (out << to_string(view_permissions_)) : (out << "<null>"));
  out << ")";
}


TDBObject::~TDBObject() throw() {
}


void TDBObject::__set_objectName(const std::string& val) {
  this->objectName = val;
}

void TDBObject::__set_objectType(const TDBObjectType::type val) {
  this->objectType = val;
}

void TDBObject::__set_privs(const std::vector<bool> & val) {
  this->privs = val;
}

void TDBObject::__set_grantee(const std::string& val) {
  this->grantee = val;
}
std::ostream& operator<<(std::ostream& out, const TDBObject& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDBObject::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->objectName);
          this->__isset.objectName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast316;
          xfer += iprot->readI32(ecast316);
          this->objectType = (TDBObjectType::type)ecast316;
          this->__isset.objectType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->privs.clear();
            uint32_t _size317;
            ::apache::thrift::protocol::TType _etype320;
            xfer += iprot->readListBegin(_etype320, _size317);
            this->privs.resize(_size317);
            uint32_t _i321;
            for (_i321 = 0; _i321 < _size317; ++_i321)
            {
              xfer += iprot->readBool(this->privs[_i321]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.privs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->grantee);
          this->__isset.grantee = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDBObject::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDBObject");

  xfer += oprot->writeFieldBegin("objectName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->objectName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("objectType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->objectType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("privs", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->privs.size()));
    std::vector<bool> ::const_iterator _iter322;
    for (_iter322 = this->privs.begin(); _iter322 != this->privs.end(); ++_iter322)
    {
      xfer += oprot->writeBool((*_iter322));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantee", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->grantee);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDBObject &a, TDBObject &b) {
  using ::std::swap;
  swap(a.objectName, b.objectName);
  swap(a.objectType, b.objectType);
  swap(a.privs, b.privs);
  swap(a.grantee, b.grantee);
  swap(a.__isset, b.__isset);
}

TDBObject::TDBObject(const TDBObject& other323) {
  objectName = other323.objectName;
  objectType = other323.objectType;
  privs = other323.privs;
  grantee = other323.grantee;
  __isset = other323.__isset;
}
TDBObject& TDBObject::operator=(const TDBObject& other324) {
  objectName = other324.objectName;
  objectType = other324.objectType;
  privs = other324.privs;
  grantee = other324.grantee;
  __isset = other324.__isset;
  return *this;
}
void TDBObject::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDBObject(";
  out << "objectName=" << to_string(objectName);
  out << ", " << "objectType=" << to_string(objectType);
  out << ", " << "privs=" << to_string(privs);
  out << ", " << "grantee=" << to_string(grantee);
  out << ")";
}


TDashboardGrantees::~TDashboardGrantees() throw() {
}


void TDashboardGrantees::__set_name(const std::string& val) {
  this->name = val;
}

void TDashboardGrantees::__set_is_user(const bool val) {
  this->is_user = val;
}

void TDashboardGrantees::__set_permissions(const TDashboardPermissions& val) {
  this->permissions = val;
}
std::ostream& operator<<(std::ostream& out, const TDashboardGrantees& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDashboardGrantees::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_user);
          this->__isset.is_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->permissions.read(iprot);
          this->__isset.permissions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDashboardGrantees::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDashboardGrantees");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_user", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("permissions", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->permissions.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDashboardGrantees &a, TDashboardGrantees &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.is_user, b.is_user);
  swap(a.permissions, b.permissions);
  swap(a.__isset, b.__isset);
}

TDashboardGrantees::TDashboardGrantees(const TDashboardGrantees& other325) {
  name = other325.name;
  is_user = other325.is_user;
  permissions = other325.permissions;
  __isset = other325.__isset;
}
TDashboardGrantees& TDashboardGrantees::operator=(const TDashboardGrantees& other326) {
  name = other326.name;
  is_user = other326.is_user;
  permissions = other326.permissions;
  __isset = other326.__isset;
  return *this;
}
void TDashboardGrantees::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDashboardGrantees(";
  out << "name=" << to_string(name);
  out << ", " << "is_user=" << to_string(is_user);
  out << ", " << "permissions=" << to_string(permissions);
  out << ")";
}


TLicenseInfo::~TLicenseInfo() throw() {
}


void TLicenseInfo::__set_claims(const std::vector<std::string> & val) {
  this->claims = val;
}
std::ostream& operator<<(std::ostream& out, const TLicenseInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TLicenseInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->claims.clear();
            uint32_t _size327;
            ::apache::thrift::protocol::TType _etype330;
            xfer += iprot->readListBegin(_etype330, _size327);
            this->claims.resize(_size327);
            uint32_t _i331;
            for (_i331 = 0; _i331 < _size327; ++_i331)
            {
              xfer += iprot->readString(this->claims[_i331]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.claims = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TLicenseInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLicenseInfo");

  xfer += oprot->writeFieldBegin("claims", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->claims.size()));
    std::vector<std::string> ::const_iterator _iter332;
    for (_iter332 = this->claims.begin(); _iter332 != this->claims.end(); ++_iter332)
    {
      xfer += oprot->writeString((*_iter332));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLicenseInfo &a, TLicenseInfo &b) {
  using ::std::swap;
  swap(a.claims, b.claims);
  swap(a.__isset, b.__isset);
}

TLicenseInfo::TLicenseInfo(const TLicenseInfo& other333) {
  claims = other333.claims;
  __isset = other333.__isset;
}
TLicenseInfo& TLicenseInfo::operator=(const TLicenseInfo& other334) {
  claims = other334.claims;
  __isset = other334.__isset;
  return *this;
}
void TLicenseInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLicenseInfo(";
  out << "claims=" << to_string(claims);
  out << ")";
}


TSessionInfo::~TSessionInfo() throw() {
}


void TSessionInfo::__set_user(const std::string& val) {
  this->user = val;
}

void TSessionInfo::__set_database(const std::string& val) {
  this->database = val;
}

void TSessionInfo::__set_start_time(const int64_t val) {
  this->start_time = val;
}

void TSessionInfo::__set_is_super(const bool val) {
  this->is_super = val;
}
std::ostream& operator<<(std::ostream& out, const TSessionInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSessionInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->database);
          this->__isset.database = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_time);
          this->__isset.start_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_super);
          this->__isset.is_super = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TSessionInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSessionInfo");

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("database", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->database);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_time", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->start_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_super", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_super);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSessionInfo &a, TSessionInfo &b) {
  using ::std::swap;
  swap(a.user, b.user);
  swap(a.database, b.database);
  swap(a.start_time, b.start_time);
  swap(a.is_super, b.is_super);
  swap(a.__isset, b.__isset);
}

TSessionInfo::TSessionInfo(const TSessionInfo& other335) {
  user = other335.user;
  database = other335.database;
  start_time = other335.start_time;
  is_super = other335.is_super;
  __isset = other335.__isset;
}
TSessionInfo& TSessionInfo::operator=(const TSessionInfo& other336) {
  user = other336.user;
  database = other336.database;
  start_time = other336.start_time;
  is_super = other336.is_super;
  __isset = other336.__isset;
  return *this;
}
void TSessionInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSessionInfo(";
  out << "user=" << to_string(user);
  out << ", " << "database=" << to_string(database);
  out << ", " << "start_time=" << to_string(start_time);
  out << ", " << "is_super=" << to_string(is_super);
  out << ")";
}


TGeoFileLayerInfo::~TGeoFileLayerInfo() throw() {
}


void TGeoFileLayerInfo::__set_name(const std::string& val) {
  this->name = val;
}

void TGeoFileLayerInfo::__set_contents(const TGeoFileLayerContents::type val) {
  this->contents = val;
}
std::ostream& operator<<(std::ostream& out, const TGeoFileLayerInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGeoFileLayerInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast337;
          xfer += iprot->readI32(ecast337);
          this->contents = (TGeoFileLayerContents::type)ecast337;
          this->__isset.contents = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGeoFileLayerInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGeoFileLayerInfo");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contents", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->contents);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGeoFileLayerInfo &a, TGeoFileLayerInfo &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.contents, b.contents);
  swap(a.__isset, b.__isset);
}

TGeoFileLayerInfo::TGeoFileLayerInfo(const TGeoFileLayerInfo& other338) {
  name = other338.name;
  contents = other338.contents;
  __isset = other338.__isset;
}
TGeoFileLayerInfo& TGeoFileLayerInfo::operator=(const TGeoFileLayerInfo& other339) {
  name = other339.name;
  contents = other339.contents;
  __isset = other339.__isset;
  return *this;
}
void TGeoFileLayerInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGeoFileLayerInfo(";
  out << "name=" << to_string(name);
  out << ", " << "contents=" << to_string(contents);
  out << ")";
}


