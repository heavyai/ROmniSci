/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef mapd_TYPES_H
#define mapd_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>
#include "common_types.h"
#include "completion_hints_types.h"
#include "serialized_result_set_types.h"




struct TExecuteMode {
  enum type {
    GPU = 1,
    CPU = 2
  };
};

extern const std::map<int, const char*> _TExecuteMode_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TExecuteMode::type& val);

struct TFileType {
  enum type {
    DELIMITED = 0,
    POLYGON = 1,
    PARQUET = 2
  };
};

extern const std::map<int, const char*> _TFileType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TFileType::type& val);

struct TPartitionDetail {
  enum type {
    DEFAULT = 0,
    REPLICATED = 1,
    SHARDED = 2,
    OTHER = 3
  };
};

extern const std::map<int, const char*> _TPartitionDetail_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TPartitionDetail::type& val);

struct TGeoFileLayerContents {
  enum type {
    EMPTY = 0,
    GEO = 1,
    NON_GEO = 2,
    UNSUPPORTED_GEO = 3
  };
};

extern const std::map<int, const char*> _TGeoFileLayerContents_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TGeoFileLayerContents::type& val);

struct TImportHeaderRow {
  enum type {
    AUTODETECT = 0,
    NO_HEADER = 1,
    HAS_HEADER = 2
  };
};

extern const std::map<int, const char*> _TImportHeaderRow_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TImportHeaderRow::type& val);

struct TRole {
  enum type {
    SERVER = 0,
    AGGREGATOR = 1,
    LEAF = 2,
    STRING_DICTIONARY = 3
  };
};

extern const std::map<int, const char*> _TRole_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TRole::type& val);

struct TMergeType {
  enum type {
    UNION = 0,
    REDUCE = 1
  };
};

extern const std::map<int, const char*> _TMergeType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TMergeType::type& val);

struct TExpressionRangeType {
  enum type {
    INVALID = 0,
    INTEGER = 1,
    FLOAT = 2,
    DOUBLE = 3
  };
};

extern const std::map<int, const char*> _TExpressionRangeType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TExpressionRangeType::type& val);

struct TDBObjectType {
  enum type {
    AbstractDBObjectType = 0,
    DatabaseDBObjectType = 1,
    TableDBObjectType = 2,
    DashboardDBObjectType = 3,
    ViewDBObjectType = 4
  };
};

extern const std::map<int, const char*> _TDBObjectType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TDBObjectType::type& val);

typedef std::vector<class TColumnType>  TRowDescriptor;

typedef std::map<std::string, class TColumnType>  TTableDescriptor;

typedef std::string TSessionId;

typedef int64_t TQueryId;

typedef std::map<int32_t, class TRawRenderPassDataResult>  TRenderPassMap;

typedef std::map<std::string, std::map<std::string, std::map<std::string, std::map<std::string, std::vector<class TRenderDatum> > > > >  TRenderAggDataMap;

class TDatumVal;

class TDatum;

class TStringValue;

class TColumnType;

class TRow;

class TColumnData;

class TColumn;

class TStringRow;

class TStepResult;

class TRowSet;

class TQueryResult;

class TDataFrame;

class TDBInfo;

class TMapDException;

class TCopyParams;

class TCreateParams;

class TDetectResult;

class TImportStatus;

class TFrontendView;

class TDashboard;

class TServerStatus;

class TPixel;

class TPixelTableRowResult;

class TRenderResult;

class TGpuSpecification;

class THardwareInfo;

class TClusterHardwareInfo;

class TMemoryData;

class TNodeMemoryInfo;

class TTableMeta;

class TTableDetails;

class TColumnRange;

class TDictionaryGeneration;

class TTableGeneration;

class TPendingQuery;

class TVarLen;

class TDataBlockPtr;

class TInsertData;

class TPendingRenderQuery;

class TRenderParseResult;

class TRawRenderPassDataResult;

class TRawPixelData;

class TRenderDatum;

class TRenderStepResult;

class TDatabasePermissions;

class TTablePermissions;

class TDashboardPermissions;

class TViewPermissions;

class TDBObjectPermissions;

class TDBObject;

class TDashboardGrantees;

class TLicenseInfo;

class TSessionInfo;

class TGeoFileLayerInfo;

typedef struct _TDatumVal__isset {
  _TDatumVal__isset() : int_val(false), real_val(false), str_val(false), arr_val(false) {}
  bool int_val :1;
  bool real_val :1;
  bool str_val :1;
  bool arr_val :1;
} _TDatumVal__isset;

class TDatumVal : public virtual ::apache::thrift::TBase {
 public:

  TDatumVal(const TDatumVal&);
  TDatumVal& operator=(const TDatumVal&);
  TDatumVal() : int_val(0), real_val(0), str_val() {
  }

  virtual ~TDatumVal() throw();
  int64_t int_val;
  double real_val;
  std::string str_val;
  std::vector<TDatum>  arr_val;

  _TDatumVal__isset __isset;

  void __set_int_val(const int64_t val);

  void __set_real_val(const double val);

  void __set_str_val(const std::string& val);

  void __set_arr_val(const std::vector<TDatum> & val);

  bool operator == (const TDatumVal & rhs) const
  {
    if (!(int_val == rhs.int_val))
      return false;
    if (!(real_val == rhs.real_val))
      return false;
    if (!(str_val == rhs.str_val))
      return false;
    if (!(arr_val == rhs.arr_val))
      return false;
    return true;
  }
  bool operator != (const TDatumVal &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDatumVal & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDatumVal &a, TDatumVal &b);

std::ostream& operator<<(std::ostream& out, const TDatumVal& obj);

typedef struct _TDatum__isset {
  _TDatum__isset() : val(false), is_null(false) {}
  bool val :1;
  bool is_null :1;
} _TDatum__isset;

class TDatum : public virtual ::apache::thrift::TBase {
 public:

  TDatum(const TDatum&);
  TDatum& operator=(const TDatum&);
  TDatum() : is_null(0) {
  }

  virtual ~TDatum() throw();
  TDatumVal val;
  bool is_null;

  _TDatum__isset __isset;

  void __set_val(const TDatumVal& val);

  void __set_is_null(const bool val);

  bool operator == (const TDatum & rhs) const
  {
    if (!(val == rhs.val))
      return false;
    if (!(is_null == rhs.is_null))
      return false;
    return true;
  }
  bool operator != (const TDatum &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDatum & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDatum &a, TDatum &b);

std::ostream& operator<<(std::ostream& out, const TDatum& obj);

typedef struct _TStringValue__isset {
  _TStringValue__isset() : str_val(false), is_null(false) {}
  bool str_val :1;
  bool is_null :1;
} _TStringValue__isset;

class TStringValue : public virtual ::apache::thrift::TBase {
 public:

  TStringValue(const TStringValue&);
  TStringValue& operator=(const TStringValue&);
  TStringValue() : str_val(), is_null(0) {
  }

  virtual ~TStringValue() throw();
  std::string str_val;
  bool is_null;

  _TStringValue__isset __isset;

  void __set_str_val(const std::string& val);

  void __set_is_null(const bool val);

  bool operator == (const TStringValue & rhs) const
  {
    if (!(str_val == rhs.str_val))
      return false;
    if (!(is_null == rhs.is_null))
      return false;
    return true;
  }
  bool operator != (const TStringValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStringValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TStringValue &a, TStringValue &b);

std::ostream& operator<<(std::ostream& out, const TStringValue& obj);

typedef struct _TColumnType__isset {
  _TColumnType__isset() : col_name(false), col_type(false), is_reserved_keyword(false), src_name(false), is_system(false), is_physical(false), col_id(false) {}
  bool col_name :1;
  bool col_type :1;
  bool is_reserved_keyword :1;
  bool src_name :1;
  bool is_system :1;
  bool is_physical :1;
  bool col_id :1;
} _TColumnType__isset;

class TColumnType : public virtual ::apache::thrift::TBase {
 public:

  TColumnType(const TColumnType&);
  TColumnType& operator=(const TColumnType&);
  TColumnType() : col_name(), is_reserved_keyword(0), src_name(), is_system(0), is_physical(0), col_id(0) {
  }

  virtual ~TColumnType() throw();
  std::string col_name;
   ::TTypeInfo col_type;
  bool is_reserved_keyword;
  std::string src_name;
  bool is_system;
  bool is_physical;
  int64_t col_id;

  _TColumnType__isset __isset;

  void __set_col_name(const std::string& val);

  void __set_col_type(const  ::TTypeInfo& val);

  void __set_is_reserved_keyword(const bool val);

  void __set_src_name(const std::string& val);

  void __set_is_system(const bool val);

  void __set_is_physical(const bool val);

  void __set_col_id(const int64_t val);

  bool operator == (const TColumnType & rhs) const
  {
    if (!(col_name == rhs.col_name))
      return false;
    if (!(col_type == rhs.col_type))
      return false;
    if (!(is_reserved_keyword == rhs.is_reserved_keyword))
      return false;
    if (!(src_name == rhs.src_name))
      return false;
    if (!(is_system == rhs.is_system))
      return false;
    if (!(is_physical == rhs.is_physical))
      return false;
    if (!(col_id == rhs.col_id))
      return false;
    return true;
  }
  bool operator != (const TColumnType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TColumnType &a, TColumnType &b);

std::ostream& operator<<(std::ostream& out, const TColumnType& obj);

typedef struct _TRow__isset {
  _TRow__isset() : cols(false) {}
  bool cols :1;
} _TRow__isset;

class TRow : public virtual ::apache::thrift::TBase {
 public:

  TRow(const TRow&);
  TRow& operator=(const TRow&);
  TRow() {
  }

  virtual ~TRow() throw();
  std::vector<TDatum>  cols;

  _TRow__isset __isset;

  void __set_cols(const std::vector<TDatum> & val);

  bool operator == (const TRow & rhs) const
  {
    if (!(cols == rhs.cols))
      return false;
    return true;
  }
  bool operator != (const TRow &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRow & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRow &a, TRow &b);

std::ostream& operator<<(std::ostream& out, const TRow& obj);

typedef struct _TColumnData__isset {
  _TColumnData__isset() : int_col(false), real_col(false), str_col(false), arr_col(false) {}
  bool int_col :1;
  bool real_col :1;
  bool str_col :1;
  bool arr_col :1;
} _TColumnData__isset;

class TColumnData : public virtual ::apache::thrift::TBase {
 public:

  TColumnData(const TColumnData&);
  TColumnData& operator=(const TColumnData&);
  TColumnData() {
  }

  virtual ~TColumnData() throw();
  std::vector<int64_t>  int_col;
  std::vector<double>  real_col;
  std::vector<std::string>  str_col;
  std::vector<TColumn>  arr_col;

  _TColumnData__isset __isset;

  void __set_int_col(const std::vector<int64_t> & val);

  void __set_real_col(const std::vector<double> & val);

  void __set_str_col(const std::vector<std::string> & val);

  void __set_arr_col(const std::vector<TColumn> & val);

  bool operator == (const TColumnData & rhs) const
  {
    if (!(int_col == rhs.int_col))
      return false;
    if (!(real_col == rhs.real_col))
      return false;
    if (!(str_col == rhs.str_col))
      return false;
    if (!(arr_col == rhs.arr_col))
      return false;
    return true;
  }
  bool operator != (const TColumnData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TColumnData &a, TColumnData &b);

std::ostream& operator<<(std::ostream& out, const TColumnData& obj);

typedef struct _TColumn__isset {
  _TColumn__isset() : data(false), nulls(false) {}
  bool data :1;
  bool nulls :1;
} _TColumn__isset;

class TColumn : public virtual ::apache::thrift::TBase {
 public:

  TColumn(const TColumn&);
  TColumn& operator=(const TColumn&);
  TColumn() {
  }

  virtual ~TColumn() throw();
  TColumnData data;
  std::vector<bool>  nulls;

  _TColumn__isset __isset;

  void __set_data(const TColumnData& val);

  void __set_nulls(const std::vector<bool> & val);

  bool operator == (const TColumn & rhs) const
  {
    if (!(data == rhs.data))
      return false;
    if (!(nulls == rhs.nulls))
      return false;
    return true;
  }
  bool operator != (const TColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TColumn &a, TColumn &b);

std::ostream& operator<<(std::ostream& out, const TColumn& obj);

typedef struct _TStringRow__isset {
  _TStringRow__isset() : cols(false) {}
  bool cols :1;
} _TStringRow__isset;

class TStringRow : public virtual ::apache::thrift::TBase {
 public:

  TStringRow(const TStringRow&);
  TStringRow& operator=(const TStringRow&);
  TStringRow() {
  }

  virtual ~TStringRow() throw();
  std::vector<TStringValue>  cols;

  _TStringRow__isset __isset;

  void __set_cols(const std::vector<TStringValue> & val);

  bool operator == (const TStringRow & rhs) const
  {
    if (!(cols == rhs.cols))
      return false;
    return true;
  }
  bool operator != (const TStringRow &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStringRow & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TStringRow &a, TStringRow &b);

std::ostream& operator<<(std::ostream& out, const TStringRow& obj);

typedef struct _TStepResult__isset {
  _TStepResult__isset() : serialized_rows(false), execution_finished(false), merge_type(false), sharded(false), row_desc(false), node_id(false) {}
  bool serialized_rows :1;
  bool execution_finished :1;
  bool merge_type :1;
  bool sharded :1;
  bool row_desc :1;
  bool node_id :1;
} _TStepResult__isset;

class TStepResult : public virtual ::apache::thrift::TBase {
 public:

  TStepResult(const TStepResult&);
  TStepResult& operator=(const TStepResult&);
  TStepResult() : execution_finished(0), merge_type((TMergeType::type)0), sharded(0), node_id(0) {
  }

  virtual ~TStepResult() throw();
   ::TSerializedRows serialized_rows;
  bool execution_finished;
  TMergeType::type merge_type;
  bool sharded;
  TRowDescriptor row_desc;
  int32_t node_id;

  _TStepResult__isset __isset;

  void __set_serialized_rows(const  ::TSerializedRows& val);

  void __set_execution_finished(const bool val);

  void __set_merge_type(const TMergeType::type val);

  void __set_sharded(const bool val);

  void __set_row_desc(const TRowDescriptor& val);

  void __set_node_id(const int32_t val);

  bool operator == (const TStepResult & rhs) const
  {
    if (!(serialized_rows == rhs.serialized_rows))
      return false;
    if (!(execution_finished == rhs.execution_finished))
      return false;
    if (!(merge_type == rhs.merge_type))
      return false;
    if (!(sharded == rhs.sharded))
      return false;
    if (!(row_desc == rhs.row_desc))
      return false;
    if (!(node_id == rhs.node_id))
      return false;
    return true;
  }
  bool operator != (const TStepResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStepResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TStepResult &a, TStepResult &b);

std::ostream& operator<<(std::ostream& out, const TStepResult& obj);

typedef struct _TRowSet__isset {
  _TRowSet__isset() : row_desc(false), rows(false), columns(false), is_columnar(false) {}
  bool row_desc :1;
  bool rows :1;
  bool columns :1;
  bool is_columnar :1;
} _TRowSet__isset;

class TRowSet : public virtual ::apache::thrift::TBase {
 public:

  TRowSet(const TRowSet&);
  TRowSet& operator=(const TRowSet&);
  TRowSet() : is_columnar(0) {
  }

  virtual ~TRowSet() throw();
  TRowDescriptor row_desc;
  std::vector<TRow>  rows;
  std::vector<TColumn>  columns;
  bool is_columnar;

  _TRowSet__isset __isset;

  void __set_row_desc(const TRowDescriptor& val);

  void __set_rows(const std::vector<TRow> & val);

  void __set_columns(const std::vector<TColumn> & val);

  void __set_is_columnar(const bool val);

  bool operator == (const TRowSet & rhs) const
  {
    if (!(row_desc == rhs.row_desc))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(is_columnar == rhs.is_columnar))
      return false;
    return true;
  }
  bool operator != (const TRowSet &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRowSet & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRowSet &a, TRowSet &b);

std::ostream& operator<<(std::ostream& out, const TRowSet& obj);

typedef struct _TQueryResult__isset {
  _TQueryResult__isset() : row_set(false), execution_time_ms(false), total_time_ms(false), nonce(false) {}
  bool row_set :1;
  bool execution_time_ms :1;
  bool total_time_ms :1;
  bool nonce :1;
} _TQueryResult__isset;

class TQueryResult : public virtual ::apache::thrift::TBase {
 public:

  TQueryResult(const TQueryResult&);
  TQueryResult& operator=(const TQueryResult&);
  TQueryResult() : execution_time_ms(0), total_time_ms(0), nonce() {
  }

  virtual ~TQueryResult() throw();
  TRowSet row_set;
  int64_t execution_time_ms;
  int64_t total_time_ms;
  std::string nonce;

  _TQueryResult__isset __isset;

  void __set_row_set(const TRowSet& val);

  void __set_execution_time_ms(const int64_t val);

  void __set_total_time_ms(const int64_t val);

  void __set_nonce(const std::string& val);

  bool operator == (const TQueryResult & rhs) const
  {
    if (!(row_set == rhs.row_set))
      return false;
    if (!(execution_time_ms == rhs.execution_time_ms))
      return false;
    if (!(total_time_ms == rhs.total_time_ms))
      return false;
    if (!(nonce == rhs.nonce))
      return false;
    return true;
  }
  bool operator != (const TQueryResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TQueryResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TQueryResult &a, TQueryResult &b);

std::ostream& operator<<(std::ostream& out, const TQueryResult& obj);

typedef struct _TDataFrame__isset {
  _TDataFrame__isset() : sm_handle(false), sm_size(false), df_handle(false), df_size(false) {}
  bool sm_handle :1;
  bool sm_size :1;
  bool df_handle :1;
  bool df_size :1;
} _TDataFrame__isset;

class TDataFrame : public virtual ::apache::thrift::TBase {
 public:

  TDataFrame(const TDataFrame&);
  TDataFrame& operator=(const TDataFrame&);
  TDataFrame() : sm_handle(), sm_size(0), df_handle(), df_size(0) {
  }

  virtual ~TDataFrame() throw();
  std::string sm_handle;
  int64_t sm_size;
  std::string df_handle;
  int64_t df_size;

  _TDataFrame__isset __isset;

  void __set_sm_handle(const std::string& val);

  void __set_sm_size(const int64_t val);

  void __set_df_handle(const std::string& val);

  void __set_df_size(const int64_t val);

  bool operator == (const TDataFrame & rhs) const
  {
    if (!(sm_handle == rhs.sm_handle))
      return false;
    if (!(sm_size == rhs.sm_size))
      return false;
    if (!(df_handle == rhs.df_handle))
      return false;
    if (!(df_size == rhs.df_size))
      return false;
    return true;
  }
  bool operator != (const TDataFrame &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDataFrame & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDataFrame &a, TDataFrame &b);

std::ostream& operator<<(std::ostream& out, const TDataFrame& obj);

typedef struct _TDBInfo__isset {
  _TDBInfo__isset() : db_name(false), db_owner(false) {}
  bool db_name :1;
  bool db_owner :1;
} _TDBInfo__isset;

class TDBInfo : public virtual ::apache::thrift::TBase {
 public:

  TDBInfo(const TDBInfo&);
  TDBInfo& operator=(const TDBInfo&);
  TDBInfo() : db_name(), db_owner() {
  }

  virtual ~TDBInfo() throw();
  std::string db_name;
  std::string db_owner;

  _TDBInfo__isset __isset;

  void __set_db_name(const std::string& val);

  void __set_db_owner(const std::string& val);

  bool operator == (const TDBInfo & rhs) const
  {
    if (!(db_name == rhs.db_name))
      return false;
    if (!(db_owner == rhs.db_owner))
      return false;
    return true;
  }
  bool operator != (const TDBInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDBInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDBInfo &a, TDBInfo &b);

std::ostream& operator<<(std::ostream& out, const TDBInfo& obj);

typedef struct _TMapDException__isset {
  _TMapDException__isset() : error_msg(false) {}
  bool error_msg :1;
} _TMapDException__isset;

class TMapDException : public ::apache::thrift::TException {
 public:

  TMapDException(const TMapDException&);
  TMapDException& operator=(const TMapDException&);
  TMapDException() : error_msg() {
  }

  virtual ~TMapDException() throw();
  std::string error_msg;

  _TMapDException__isset __isset;

  void __set_error_msg(const std::string& val);

  bool operator == (const TMapDException & rhs) const
  {
    if (!(error_msg == rhs.error_msg))
      return false;
    return true;
  }
  bool operator != (const TMapDException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMapDException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(TMapDException &a, TMapDException &b);

std::ostream& operator<<(std::ostream& out, const TMapDException& obj);

typedef struct _TCopyParams__isset {
  _TCopyParams__isset() : delimiter(false), null_str(false), has_header(true), quoted(false), quote(false), escape(false), line_delim(false), array_delim(false), array_begin(false), array_end(false), threads(false), file_type(true), s3_access_key(false), s3_secret_key(false), s3_region(false), geo_coords_encoding(true), geo_coords_comp_param(true), geo_coords_type(true), geo_coords_srid(true), sanitize_column_names(true), geo_layer_name(false), s3_endpoint(false) {}
  bool delimiter :1;
  bool null_str :1;
  bool has_header :1;
  bool quoted :1;
  bool quote :1;
  bool escape :1;
  bool line_delim :1;
  bool array_delim :1;
  bool array_begin :1;
  bool array_end :1;
  bool threads :1;
  bool file_type :1;
  bool s3_access_key :1;
  bool s3_secret_key :1;
  bool s3_region :1;
  bool geo_coords_encoding :1;
  bool geo_coords_comp_param :1;
  bool geo_coords_type :1;
  bool geo_coords_srid :1;
  bool sanitize_column_names :1;
  bool geo_layer_name :1;
  bool s3_endpoint :1;
} _TCopyParams__isset;

class TCopyParams : public virtual ::apache::thrift::TBase {
 public:

  TCopyParams(const TCopyParams&);
  TCopyParams& operator=(const TCopyParams&);
  TCopyParams() : delimiter(), null_str(), has_header((TImportHeaderRow::type)0), quoted(0), quote(), escape(), line_delim(), array_delim(), array_begin(), array_end(), threads(0), file_type((TFileType::type)0), s3_access_key(), s3_secret_key(), s3_region(), geo_coords_encoding(( ::TEncodingType::type)6), geo_coords_comp_param(32), geo_coords_type(( ::TDatumType::type)18), geo_coords_srid(4326), sanitize_column_names(true), geo_layer_name(), s3_endpoint() {
    has_header = (TImportHeaderRow::type)0;

    file_type = (TFileType::type)0;

    geo_coords_encoding = ( ::TEncodingType::type)6;

    geo_coords_type = ( ::TDatumType::type)18;

  }

  virtual ~TCopyParams() throw();
  std::string delimiter;
  std::string null_str;
  TImportHeaderRow::type has_header;
  bool quoted;
  std::string quote;
  std::string escape;
  std::string line_delim;
  std::string array_delim;
  std::string array_begin;
  std::string array_end;
  int32_t threads;
  TFileType::type file_type;
  std::string s3_access_key;
  std::string s3_secret_key;
  std::string s3_region;
   ::TEncodingType::type geo_coords_encoding;
  int32_t geo_coords_comp_param;
   ::TDatumType::type geo_coords_type;
  int32_t geo_coords_srid;
  bool sanitize_column_names;
  std::string geo_layer_name;
  std::string s3_endpoint;

  _TCopyParams__isset __isset;

  void __set_delimiter(const std::string& val);

  void __set_null_str(const std::string& val);

  void __set_has_header(const TImportHeaderRow::type val);

  void __set_quoted(const bool val);

  void __set_quote(const std::string& val);

  void __set_escape(const std::string& val);

  void __set_line_delim(const std::string& val);

  void __set_array_delim(const std::string& val);

  void __set_array_begin(const std::string& val);

  void __set_array_end(const std::string& val);

  void __set_threads(const int32_t val);

  void __set_file_type(const TFileType::type val);

  void __set_s3_access_key(const std::string& val);

  void __set_s3_secret_key(const std::string& val);

  void __set_s3_region(const std::string& val);

  void __set_geo_coords_encoding(const  ::TEncodingType::type val);

  void __set_geo_coords_comp_param(const int32_t val);

  void __set_geo_coords_type(const  ::TDatumType::type val);

  void __set_geo_coords_srid(const int32_t val);

  void __set_sanitize_column_names(const bool val);

  void __set_geo_layer_name(const std::string& val);

  void __set_s3_endpoint(const std::string& val);

  bool operator == (const TCopyParams & rhs) const
  {
    if (!(delimiter == rhs.delimiter))
      return false;
    if (!(null_str == rhs.null_str))
      return false;
    if (!(has_header == rhs.has_header))
      return false;
    if (!(quoted == rhs.quoted))
      return false;
    if (!(quote == rhs.quote))
      return false;
    if (!(escape == rhs.escape))
      return false;
    if (!(line_delim == rhs.line_delim))
      return false;
    if (!(array_delim == rhs.array_delim))
      return false;
    if (!(array_begin == rhs.array_begin))
      return false;
    if (!(array_end == rhs.array_end))
      return false;
    if (!(threads == rhs.threads))
      return false;
    if (!(file_type == rhs.file_type))
      return false;
    if (!(s3_access_key == rhs.s3_access_key))
      return false;
    if (!(s3_secret_key == rhs.s3_secret_key))
      return false;
    if (!(s3_region == rhs.s3_region))
      return false;
    if (!(geo_coords_encoding == rhs.geo_coords_encoding))
      return false;
    if (!(geo_coords_comp_param == rhs.geo_coords_comp_param))
      return false;
    if (!(geo_coords_type == rhs.geo_coords_type))
      return false;
    if (!(geo_coords_srid == rhs.geo_coords_srid))
      return false;
    if (!(sanitize_column_names == rhs.sanitize_column_names))
      return false;
    if (!(geo_layer_name == rhs.geo_layer_name))
      return false;
    if (!(s3_endpoint == rhs.s3_endpoint))
      return false;
    return true;
  }
  bool operator != (const TCopyParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCopyParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCopyParams &a, TCopyParams &b);

std::ostream& operator<<(std::ostream& out, const TCopyParams& obj);

typedef struct _TCreateParams__isset {
  _TCreateParams__isset() : is_replicated(false) {}
  bool is_replicated :1;
} _TCreateParams__isset;

class TCreateParams : public virtual ::apache::thrift::TBase {
 public:

  TCreateParams(const TCreateParams&);
  TCreateParams& operator=(const TCreateParams&);
  TCreateParams() : is_replicated(0) {
  }

  virtual ~TCreateParams() throw();
  bool is_replicated;

  _TCreateParams__isset __isset;

  void __set_is_replicated(const bool val);

  bool operator == (const TCreateParams & rhs) const
  {
    if (!(is_replicated == rhs.is_replicated))
      return false;
    return true;
  }
  bool operator != (const TCreateParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCreateParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCreateParams &a, TCreateParams &b);

std::ostream& operator<<(std::ostream& out, const TCreateParams& obj);

typedef struct _TDetectResult__isset {
  _TDetectResult__isset() : row_set(false), copy_params(false) {}
  bool row_set :1;
  bool copy_params :1;
} _TDetectResult__isset;

class TDetectResult : public virtual ::apache::thrift::TBase {
 public:

  TDetectResult(const TDetectResult&);
  TDetectResult& operator=(const TDetectResult&);
  TDetectResult() {
  }

  virtual ~TDetectResult() throw();
  TRowSet row_set;
  TCopyParams copy_params;

  _TDetectResult__isset __isset;

  void __set_row_set(const TRowSet& val);

  void __set_copy_params(const TCopyParams& val);

  bool operator == (const TDetectResult & rhs) const
  {
    if (!(row_set == rhs.row_set))
      return false;
    if (!(copy_params == rhs.copy_params))
      return false;
    return true;
  }
  bool operator != (const TDetectResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDetectResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDetectResult &a, TDetectResult &b);

std::ostream& operator<<(std::ostream& out, const TDetectResult& obj);

typedef struct _TImportStatus__isset {
  _TImportStatus__isset() : elapsed(false), rows_completed(false), rows_estimated(false), rows_rejected(false) {}
  bool elapsed :1;
  bool rows_completed :1;
  bool rows_estimated :1;
  bool rows_rejected :1;
} _TImportStatus__isset;

class TImportStatus : public virtual ::apache::thrift::TBase {
 public:

  TImportStatus(const TImportStatus&);
  TImportStatus& operator=(const TImportStatus&);
  TImportStatus() : elapsed(0), rows_completed(0), rows_estimated(0), rows_rejected(0) {
  }

  virtual ~TImportStatus() throw();
  int64_t elapsed;
  int64_t rows_completed;
  int64_t rows_estimated;
  int64_t rows_rejected;

  _TImportStatus__isset __isset;

  void __set_elapsed(const int64_t val);

  void __set_rows_completed(const int64_t val);

  void __set_rows_estimated(const int64_t val);

  void __set_rows_rejected(const int64_t val);

  bool operator == (const TImportStatus & rhs) const
  {
    if (!(elapsed == rhs.elapsed))
      return false;
    if (!(rows_completed == rhs.rows_completed))
      return false;
    if (!(rows_estimated == rhs.rows_estimated))
      return false;
    if (!(rows_rejected == rhs.rows_rejected))
      return false;
    return true;
  }
  bool operator != (const TImportStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TImportStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TImportStatus &a, TImportStatus &b);

std::ostream& operator<<(std::ostream& out, const TImportStatus& obj);

typedef struct _TFrontendView__isset {
  _TFrontendView__isset() : view_name(false), view_state(false), image_hash(false), update_time(false), view_metadata(false) {}
  bool view_name :1;
  bool view_state :1;
  bool image_hash :1;
  bool update_time :1;
  bool view_metadata :1;
} _TFrontendView__isset;

class TFrontendView : public virtual ::apache::thrift::TBase {
 public:

  TFrontendView(const TFrontendView&);
  TFrontendView& operator=(const TFrontendView&);
  TFrontendView() : view_name(), view_state(), image_hash(), update_time(), view_metadata() {
  }

  virtual ~TFrontendView() throw();
  std::string view_name;
  std::string view_state;
  std::string image_hash;
  std::string update_time;
  std::string view_metadata;

  _TFrontendView__isset __isset;

  void __set_view_name(const std::string& val);

  void __set_view_state(const std::string& val);

  void __set_image_hash(const std::string& val);

  void __set_update_time(const std::string& val);

  void __set_view_metadata(const std::string& val);

  bool operator == (const TFrontendView & rhs) const
  {
    if (!(view_name == rhs.view_name))
      return false;
    if (!(view_state == rhs.view_state))
      return false;
    if (!(image_hash == rhs.image_hash))
      return false;
    if (!(update_time == rhs.update_time))
      return false;
    if (!(view_metadata == rhs.view_metadata))
      return false;
    return true;
  }
  bool operator != (const TFrontendView &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFrontendView & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFrontendView &a, TFrontendView &b);

std::ostream& operator<<(std::ostream& out, const TFrontendView& obj);

typedef struct _TDashboard__isset {
  _TDashboard__isset() : dashboard_name(false), dashboard_state(false), image_hash(false), update_time(false), dashboard_metadata(false), dashboard_id(false), dashboard_owner(false), is_dash_shared(false) {}
  bool dashboard_name :1;
  bool dashboard_state :1;
  bool image_hash :1;
  bool update_time :1;
  bool dashboard_metadata :1;
  bool dashboard_id :1;
  bool dashboard_owner :1;
  bool is_dash_shared :1;
} _TDashboard__isset;

class TDashboard : public virtual ::apache::thrift::TBase {
 public:

  TDashboard(const TDashboard&);
  TDashboard& operator=(const TDashboard&);
  TDashboard() : dashboard_name(), dashboard_state(), image_hash(), update_time(), dashboard_metadata(), dashboard_id(0), dashboard_owner(), is_dash_shared(0) {
  }

  virtual ~TDashboard() throw();
  std::string dashboard_name;
  std::string dashboard_state;
  std::string image_hash;
  std::string update_time;
  std::string dashboard_metadata;
  int32_t dashboard_id;
  std::string dashboard_owner;
  bool is_dash_shared;

  _TDashboard__isset __isset;

  void __set_dashboard_name(const std::string& val);

  void __set_dashboard_state(const std::string& val);

  void __set_image_hash(const std::string& val);

  void __set_update_time(const std::string& val);

  void __set_dashboard_metadata(const std::string& val);

  void __set_dashboard_id(const int32_t val);

  void __set_dashboard_owner(const std::string& val);

  void __set_is_dash_shared(const bool val);

  bool operator == (const TDashboard & rhs) const
  {
    if (!(dashboard_name == rhs.dashboard_name))
      return false;
    if (!(dashboard_state == rhs.dashboard_state))
      return false;
    if (!(image_hash == rhs.image_hash))
      return false;
    if (!(update_time == rhs.update_time))
      return false;
    if (!(dashboard_metadata == rhs.dashboard_metadata))
      return false;
    if (!(dashboard_id == rhs.dashboard_id))
      return false;
    if (!(dashboard_owner == rhs.dashboard_owner))
      return false;
    if (!(is_dash_shared == rhs.is_dash_shared))
      return false;
    return true;
  }
  bool operator != (const TDashboard &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDashboard & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDashboard &a, TDashboard &b);

std::ostream& operator<<(std::ostream& out, const TDashboard& obj);

typedef struct _TServerStatus__isset {
  _TServerStatus__isset() : read_only(false), version(false), rendering_enabled(false), start_time(false), edition(false), host_name(false), poly_rendering_enabled(false), role(false) {}
  bool read_only :1;
  bool version :1;
  bool rendering_enabled :1;
  bool start_time :1;
  bool edition :1;
  bool host_name :1;
  bool poly_rendering_enabled :1;
  bool role :1;
} _TServerStatus__isset;

class TServerStatus : public virtual ::apache::thrift::TBase {
 public:

  TServerStatus(const TServerStatus&);
  TServerStatus& operator=(const TServerStatus&);
  TServerStatus() : read_only(0), version(), rendering_enabled(0), start_time(0), edition(), host_name(), poly_rendering_enabled(0), role((TRole::type)0) {
  }

  virtual ~TServerStatus() throw();
  bool read_only;
  std::string version;
  bool rendering_enabled;
  int64_t start_time;
  std::string edition;
  std::string host_name;
  bool poly_rendering_enabled;
  TRole::type role;

  _TServerStatus__isset __isset;

  void __set_read_only(const bool val);

  void __set_version(const std::string& val);

  void __set_rendering_enabled(const bool val);

  void __set_start_time(const int64_t val);

  void __set_edition(const std::string& val);

  void __set_host_name(const std::string& val);

  void __set_poly_rendering_enabled(const bool val);

  void __set_role(const TRole::type val);

  bool operator == (const TServerStatus & rhs) const
  {
    if (!(read_only == rhs.read_only))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(rendering_enabled == rhs.rendering_enabled))
      return false;
    if (!(start_time == rhs.start_time))
      return false;
    if (!(edition == rhs.edition))
      return false;
    if (!(host_name == rhs.host_name))
      return false;
    if (!(poly_rendering_enabled == rhs.poly_rendering_enabled))
      return false;
    if (!(role == rhs.role))
      return false;
    return true;
  }
  bool operator != (const TServerStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TServerStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TServerStatus &a, TServerStatus &b);

std::ostream& operator<<(std::ostream& out, const TServerStatus& obj);

typedef struct _TPixel__isset {
  _TPixel__isset() : x(false), y(false) {}
  bool x :1;
  bool y :1;
} _TPixel__isset;

class TPixel : public virtual ::apache::thrift::TBase {
 public:

  TPixel(const TPixel&);
  TPixel& operator=(const TPixel&);
  TPixel() : x(0), y(0) {
  }

  virtual ~TPixel() throw();
  int64_t x;
  int64_t y;

  _TPixel__isset __isset;

  void __set_x(const int64_t val);

  void __set_y(const int64_t val);

  bool operator == (const TPixel & rhs) const
  {
    if (!(x == rhs.x))
      return false;
    if (!(y == rhs.y))
      return false;
    return true;
  }
  bool operator != (const TPixel &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPixel & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPixel &a, TPixel &b);

std::ostream& operator<<(std::ostream& out, const TPixel& obj);

typedef struct _TPixelTableRowResult__isset {
  _TPixelTableRowResult__isset() : pixel(false), vega_table_name(false), table_id(false), row_id(false), row_set(false), nonce(false) {}
  bool pixel :1;
  bool vega_table_name :1;
  bool table_id :1;
  bool row_id :1;
  bool row_set :1;
  bool nonce :1;
} _TPixelTableRowResult__isset;

class TPixelTableRowResult : public virtual ::apache::thrift::TBase {
 public:

  TPixelTableRowResult(const TPixelTableRowResult&);
  TPixelTableRowResult& operator=(const TPixelTableRowResult&);
  TPixelTableRowResult() : vega_table_name(), nonce() {
  }

  virtual ~TPixelTableRowResult() throw();
  TPixel pixel;
  std::string vega_table_name;
  std::vector<int64_t>  table_id;
  std::vector<int64_t>  row_id;
  TRowSet row_set;
  std::string nonce;

  _TPixelTableRowResult__isset __isset;

  void __set_pixel(const TPixel& val);

  void __set_vega_table_name(const std::string& val);

  void __set_table_id(const std::vector<int64_t> & val);

  void __set_row_id(const std::vector<int64_t> & val);

  void __set_row_set(const TRowSet& val);

  void __set_nonce(const std::string& val);

  bool operator == (const TPixelTableRowResult & rhs) const
  {
    if (!(pixel == rhs.pixel))
      return false;
    if (!(vega_table_name == rhs.vega_table_name))
      return false;
    if (!(table_id == rhs.table_id))
      return false;
    if (!(row_id == rhs.row_id))
      return false;
    if (!(row_set == rhs.row_set))
      return false;
    if (!(nonce == rhs.nonce))
      return false;
    return true;
  }
  bool operator != (const TPixelTableRowResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPixelTableRowResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPixelTableRowResult &a, TPixelTableRowResult &b);

std::ostream& operator<<(std::ostream& out, const TPixelTableRowResult& obj);

typedef struct _TRenderResult__isset {
  _TRenderResult__isset() : image(false), nonce(false), execution_time_ms(false), render_time_ms(false), total_time_ms(false), vega_metadata(false) {}
  bool image :1;
  bool nonce :1;
  bool execution_time_ms :1;
  bool render_time_ms :1;
  bool total_time_ms :1;
  bool vega_metadata :1;
} _TRenderResult__isset;

class TRenderResult : public virtual ::apache::thrift::TBase {
 public:

  TRenderResult(const TRenderResult&);
  TRenderResult& operator=(const TRenderResult&);
  TRenderResult() : image(), nonce(), execution_time_ms(0), render_time_ms(0), total_time_ms(0), vega_metadata() {
  }

  virtual ~TRenderResult() throw();
  std::string image;
  std::string nonce;
  int64_t execution_time_ms;
  int64_t render_time_ms;
  int64_t total_time_ms;
  std::string vega_metadata;

  _TRenderResult__isset __isset;

  void __set_image(const std::string& val);

  void __set_nonce(const std::string& val);

  void __set_execution_time_ms(const int64_t val);

  void __set_render_time_ms(const int64_t val);

  void __set_total_time_ms(const int64_t val);

  void __set_vega_metadata(const std::string& val);

  bool operator == (const TRenderResult & rhs) const
  {
    if (!(image == rhs.image))
      return false;
    if (!(nonce == rhs.nonce))
      return false;
    if (!(execution_time_ms == rhs.execution_time_ms))
      return false;
    if (!(render_time_ms == rhs.render_time_ms))
      return false;
    if (!(total_time_ms == rhs.total_time_ms))
      return false;
    if (!(vega_metadata == rhs.vega_metadata))
      return false;
    return true;
  }
  bool operator != (const TRenderResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRenderResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRenderResult &a, TRenderResult &b);

std::ostream& operator<<(std::ostream& out, const TRenderResult& obj);

typedef struct _TGpuSpecification__isset {
  _TGpuSpecification__isset() : num_sm(false), clock_frequency_kHz(false), memory(false), compute_capability_major(false), compute_capability_minor(false) {}
  bool num_sm :1;
  bool clock_frequency_kHz :1;
  bool memory :1;
  bool compute_capability_major :1;
  bool compute_capability_minor :1;
} _TGpuSpecification__isset;

class TGpuSpecification : public virtual ::apache::thrift::TBase {
 public:

  TGpuSpecification(const TGpuSpecification&);
  TGpuSpecification& operator=(const TGpuSpecification&);
  TGpuSpecification() : num_sm(0), clock_frequency_kHz(0), memory(0), compute_capability_major(0), compute_capability_minor(0) {
  }

  virtual ~TGpuSpecification() throw();
  int32_t num_sm;
  int64_t clock_frequency_kHz;
  int64_t memory;
  int16_t compute_capability_major;
  int16_t compute_capability_minor;

  _TGpuSpecification__isset __isset;

  void __set_num_sm(const int32_t val);

  void __set_clock_frequency_kHz(const int64_t val);

  void __set_memory(const int64_t val);

  void __set_compute_capability_major(const int16_t val);

  void __set_compute_capability_minor(const int16_t val);

  bool operator == (const TGpuSpecification & rhs) const
  {
    if (!(num_sm == rhs.num_sm))
      return false;
    if (!(clock_frequency_kHz == rhs.clock_frequency_kHz))
      return false;
    if (!(memory == rhs.memory))
      return false;
    if (!(compute_capability_major == rhs.compute_capability_major))
      return false;
    if (!(compute_capability_minor == rhs.compute_capability_minor))
      return false;
    return true;
  }
  bool operator != (const TGpuSpecification &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGpuSpecification & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGpuSpecification &a, TGpuSpecification &b);

std::ostream& operator<<(std::ostream& out, const TGpuSpecification& obj);

typedef struct _THardwareInfo__isset {
  _THardwareInfo__isset() : num_gpu_hw(false), num_cpu_hw(false), num_gpu_allocated(false), start_gpu(false), host_name(false), gpu_info(false) {}
  bool num_gpu_hw :1;
  bool num_cpu_hw :1;
  bool num_gpu_allocated :1;
  bool start_gpu :1;
  bool host_name :1;
  bool gpu_info :1;
} _THardwareInfo__isset;

class THardwareInfo : public virtual ::apache::thrift::TBase {
 public:

  THardwareInfo(const THardwareInfo&);
  THardwareInfo& operator=(const THardwareInfo&);
  THardwareInfo() : num_gpu_hw(0), num_cpu_hw(0), num_gpu_allocated(0), start_gpu(0), host_name() {
  }

  virtual ~THardwareInfo() throw();
  int16_t num_gpu_hw;
  int16_t num_cpu_hw;
  int16_t num_gpu_allocated;
  int16_t start_gpu;
  std::string host_name;
  std::vector<TGpuSpecification>  gpu_info;

  _THardwareInfo__isset __isset;

  void __set_num_gpu_hw(const int16_t val);

  void __set_num_cpu_hw(const int16_t val);

  void __set_num_gpu_allocated(const int16_t val);

  void __set_start_gpu(const int16_t val);

  void __set_host_name(const std::string& val);

  void __set_gpu_info(const std::vector<TGpuSpecification> & val);

  bool operator == (const THardwareInfo & rhs) const
  {
    if (!(num_gpu_hw == rhs.num_gpu_hw))
      return false;
    if (!(num_cpu_hw == rhs.num_cpu_hw))
      return false;
    if (!(num_gpu_allocated == rhs.num_gpu_allocated))
      return false;
    if (!(start_gpu == rhs.start_gpu))
      return false;
    if (!(host_name == rhs.host_name))
      return false;
    if (!(gpu_info == rhs.gpu_info))
      return false;
    return true;
  }
  bool operator != (const THardwareInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THardwareInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THardwareInfo &a, THardwareInfo &b);

std::ostream& operator<<(std::ostream& out, const THardwareInfo& obj);

typedef struct _TClusterHardwareInfo__isset {
  _TClusterHardwareInfo__isset() : hardware_info(false) {}
  bool hardware_info :1;
} _TClusterHardwareInfo__isset;

class TClusterHardwareInfo : public virtual ::apache::thrift::TBase {
 public:

  TClusterHardwareInfo(const TClusterHardwareInfo&);
  TClusterHardwareInfo& operator=(const TClusterHardwareInfo&);
  TClusterHardwareInfo() {
  }

  virtual ~TClusterHardwareInfo() throw();
  std::vector<THardwareInfo>  hardware_info;

  _TClusterHardwareInfo__isset __isset;

  void __set_hardware_info(const std::vector<THardwareInfo> & val);

  bool operator == (const TClusterHardwareInfo & rhs) const
  {
    if (!(hardware_info == rhs.hardware_info))
      return false;
    return true;
  }
  bool operator != (const TClusterHardwareInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TClusterHardwareInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TClusterHardwareInfo &a, TClusterHardwareInfo &b);

std::ostream& operator<<(std::ostream& out, const TClusterHardwareInfo& obj);

typedef struct _TMemoryData__isset {
  _TMemoryData__isset() : slab(false), start_page(false), num_pages(false), touch(false), chunk_key(false), buffer_epoch(false), is_free(false) {}
  bool slab :1;
  bool start_page :1;
  bool num_pages :1;
  bool touch :1;
  bool chunk_key :1;
  bool buffer_epoch :1;
  bool is_free :1;
} _TMemoryData__isset;

class TMemoryData : public virtual ::apache::thrift::TBase {
 public:

  TMemoryData(const TMemoryData&);
  TMemoryData& operator=(const TMemoryData&);
  TMemoryData() : slab(0), start_page(0), num_pages(0), touch(0), buffer_epoch(0), is_free(0) {
  }

  virtual ~TMemoryData() throw();
  int64_t slab;
  int32_t start_page;
  int64_t num_pages;
  int32_t touch;
  std::vector<int64_t>  chunk_key;
  int32_t buffer_epoch;
  bool is_free;

  _TMemoryData__isset __isset;

  void __set_slab(const int64_t val);

  void __set_start_page(const int32_t val);

  void __set_num_pages(const int64_t val);

  void __set_touch(const int32_t val);

  void __set_chunk_key(const std::vector<int64_t> & val);

  void __set_buffer_epoch(const int32_t val);

  void __set_is_free(const bool val);

  bool operator == (const TMemoryData & rhs) const
  {
    if (!(slab == rhs.slab))
      return false;
    if (!(start_page == rhs.start_page))
      return false;
    if (!(num_pages == rhs.num_pages))
      return false;
    if (!(touch == rhs.touch))
      return false;
    if (!(chunk_key == rhs.chunk_key))
      return false;
    if (!(buffer_epoch == rhs.buffer_epoch))
      return false;
    if (!(is_free == rhs.is_free))
      return false;
    return true;
  }
  bool operator != (const TMemoryData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMemoryData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TMemoryData &a, TMemoryData &b);

std::ostream& operator<<(std::ostream& out, const TMemoryData& obj);

typedef struct _TNodeMemoryInfo__isset {
  _TNodeMemoryInfo__isset() : host_name(false), page_size(false), max_num_pages(false), num_pages_allocated(false), is_allocation_capped(false), node_memory_data(false) {}
  bool host_name :1;
  bool page_size :1;
  bool max_num_pages :1;
  bool num_pages_allocated :1;
  bool is_allocation_capped :1;
  bool node_memory_data :1;
} _TNodeMemoryInfo__isset;

class TNodeMemoryInfo : public virtual ::apache::thrift::TBase {
 public:

  TNodeMemoryInfo(const TNodeMemoryInfo&);
  TNodeMemoryInfo& operator=(const TNodeMemoryInfo&);
  TNodeMemoryInfo() : host_name(), page_size(0), max_num_pages(0), num_pages_allocated(0), is_allocation_capped(0) {
  }

  virtual ~TNodeMemoryInfo() throw();
  std::string host_name;
  int64_t page_size;
  int64_t max_num_pages;
  int64_t num_pages_allocated;
  bool is_allocation_capped;
  std::vector<TMemoryData>  node_memory_data;

  _TNodeMemoryInfo__isset __isset;

  void __set_host_name(const std::string& val);

  void __set_page_size(const int64_t val);

  void __set_max_num_pages(const int64_t val);

  void __set_num_pages_allocated(const int64_t val);

  void __set_is_allocation_capped(const bool val);

  void __set_node_memory_data(const std::vector<TMemoryData> & val);

  bool operator == (const TNodeMemoryInfo & rhs) const
  {
    if (!(host_name == rhs.host_name))
      return false;
    if (!(page_size == rhs.page_size))
      return false;
    if (!(max_num_pages == rhs.max_num_pages))
      return false;
    if (!(num_pages_allocated == rhs.num_pages_allocated))
      return false;
    if (!(is_allocation_capped == rhs.is_allocation_capped))
      return false;
    if (!(node_memory_data == rhs.node_memory_data))
      return false;
    return true;
  }
  bool operator != (const TNodeMemoryInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TNodeMemoryInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TNodeMemoryInfo &a, TNodeMemoryInfo &b);

std::ostream& operator<<(std::ostream& out, const TNodeMemoryInfo& obj);

typedef struct _TTableMeta__isset {
  _TTableMeta__isset() : table_name(false), num_cols(false), is_view(false), is_replicated(false), shard_count(false), max_rows(false), table_id(false), max_table_id(false), col_types(false), col_names(false) {}
  bool table_name :1;
  bool num_cols :1;
  bool is_view :1;
  bool is_replicated :1;
  bool shard_count :1;
  bool max_rows :1;
  bool table_id :1;
  bool max_table_id :1;
  bool col_types :1;
  bool col_names :1;
} _TTableMeta__isset;

class TTableMeta : public virtual ::apache::thrift::TBase {
 public:

  TTableMeta(const TTableMeta&);
  TTableMeta& operator=(const TTableMeta&);
  TTableMeta() : table_name(), num_cols(0), is_view(0), is_replicated(0), shard_count(0), max_rows(0), table_id(0), max_table_id(0) {
  }

  virtual ~TTableMeta() throw();
  std::string table_name;
  int64_t num_cols;
  bool is_view;
  bool is_replicated;
  int64_t shard_count;
  int64_t max_rows;
  int64_t table_id;
  int64_t max_table_id;
  std::vector< ::TTypeInfo>  col_types;
  std::vector<std::string>  col_names;

  _TTableMeta__isset __isset;

  void __set_table_name(const std::string& val);

  void __set_num_cols(const int64_t val);

  void __set_is_view(const bool val);

  void __set_is_replicated(const bool val);

  void __set_shard_count(const int64_t val);

  void __set_max_rows(const int64_t val);

  void __set_table_id(const int64_t val);

  void __set_max_table_id(const int64_t val);

  void __set_col_types(const std::vector< ::TTypeInfo> & val);

  void __set_col_names(const std::vector<std::string> & val);

  bool operator == (const TTableMeta & rhs) const
  {
    if (!(table_name == rhs.table_name))
      return false;
    if (!(num_cols == rhs.num_cols))
      return false;
    if (!(is_view == rhs.is_view))
      return false;
    if (!(is_replicated == rhs.is_replicated))
      return false;
    if (!(shard_count == rhs.shard_count))
      return false;
    if (!(max_rows == rhs.max_rows))
      return false;
    if (!(table_id == rhs.table_id))
      return false;
    if (!(max_table_id == rhs.max_table_id))
      return false;
    if (!(col_types == rhs.col_types))
      return false;
    if (!(col_names == rhs.col_names))
      return false;
    return true;
  }
  bool operator != (const TTableMeta &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableMeta & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTableMeta &a, TTableMeta &b);

std::ostream& operator<<(std::ostream& out, const TTableMeta& obj);

typedef struct _TTableDetails__isset {
  _TTableDetails__isset() : row_desc(false), fragment_size(false), page_size(false), max_rows(false), view_sql(false), shard_count(false), key_metainfo(false), is_temporary(false), partition_detail(false) {}
  bool row_desc :1;
  bool fragment_size :1;
  bool page_size :1;
  bool max_rows :1;
  bool view_sql :1;
  bool shard_count :1;
  bool key_metainfo :1;
  bool is_temporary :1;
  bool partition_detail :1;
} _TTableDetails__isset;

class TTableDetails : public virtual ::apache::thrift::TBase {
 public:

  TTableDetails(const TTableDetails&);
  TTableDetails& operator=(const TTableDetails&);
  TTableDetails() : fragment_size(0), page_size(0), max_rows(0), view_sql(), shard_count(0), key_metainfo(), is_temporary(0), partition_detail((TPartitionDetail::type)0) {
  }

  virtual ~TTableDetails() throw();
  TRowDescriptor row_desc;
  int64_t fragment_size;
  int64_t page_size;
  int64_t max_rows;
  std::string view_sql;
  int64_t shard_count;
  std::string key_metainfo;
  bool is_temporary;
  TPartitionDetail::type partition_detail;

  _TTableDetails__isset __isset;

  void __set_row_desc(const TRowDescriptor& val);

  void __set_fragment_size(const int64_t val);

  void __set_page_size(const int64_t val);

  void __set_max_rows(const int64_t val);

  void __set_view_sql(const std::string& val);

  void __set_shard_count(const int64_t val);

  void __set_key_metainfo(const std::string& val);

  void __set_is_temporary(const bool val);

  void __set_partition_detail(const TPartitionDetail::type val);

  bool operator == (const TTableDetails & rhs) const
  {
    if (!(row_desc == rhs.row_desc))
      return false;
    if (!(fragment_size == rhs.fragment_size))
      return false;
    if (!(page_size == rhs.page_size))
      return false;
    if (!(max_rows == rhs.max_rows))
      return false;
    if (!(view_sql == rhs.view_sql))
      return false;
    if (!(shard_count == rhs.shard_count))
      return false;
    if (!(key_metainfo == rhs.key_metainfo))
      return false;
    if (!(is_temporary == rhs.is_temporary))
      return false;
    if (!(partition_detail == rhs.partition_detail))
      return false;
    return true;
  }
  bool operator != (const TTableDetails &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableDetails & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTableDetails &a, TTableDetails &b);

std::ostream& operator<<(std::ostream& out, const TTableDetails& obj);

typedef struct _TColumnRange__isset {
  _TColumnRange__isset() : type(false), col_id(false), table_id(false), has_nulls(false), int_min(false), int_max(false), bucket(false), fp_min(false), fp_max(false) {}
  bool type :1;
  bool col_id :1;
  bool table_id :1;
  bool has_nulls :1;
  bool int_min :1;
  bool int_max :1;
  bool bucket :1;
  bool fp_min :1;
  bool fp_max :1;
} _TColumnRange__isset;

class TColumnRange : public virtual ::apache::thrift::TBase {
 public:

  TColumnRange(const TColumnRange&);
  TColumnRange& operator=(const TColumnRange&);
  TColumnRange() : type((TExpressionRangeType::type)0), col_id(0), table_id(0), has_nulls(0), int_min(0), int_max(0), bucket(0), fp_min(0), fp_max(0) {
  }

  virtual ~TColumnRange() throw();
  TExpressionRangeType::type type;
  int32_t col_id;
  int32_t table_id;
  bool has_nulls;
  int64_t int_min;
  int64_t int_max;
  int64_t bucket;
  double fp_min;
  double fp_max;

  _TColumnRange__isset __isset;

  void __set_type(const TExpressionRangeType::type val);

  void __set_col_id(const int32_t val);

  void __set_table_id(const int32_t val);

  void __set_has_nulls(const bool val);

  void __set_int_min(const int64_t val);

  void __set_int_max(const int64_t val);

  void __set_bucket(const int64_t val);

  void __set_fp_min(const double val);

  void __set_fp_max(const double val);

  bool operator == (const TColumnRange & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(col_id == rhs.col_id))
      return false;
    if (!(table_id == rhs.table_id))
      return false;
    if (!(has_nulls == rhs.has_nulls))
      return false;
    if (!(int_min == rhs.int_min))
      return false;
    if (!(int_max == rhs.int_max))
      return false;
    if (!(bucket == rhs.bucket))
      return false;
    if (!(fp_min == rhs.fp_min))
      return false;
    if (!(fp_max == rhs.fp_max))
      return false;
    return true;
  }
  bool operator != (const TColumnRange &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnRange & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TColumnRange &a, TColumnRange &b);

std::ostream& operator<<(std::ostream& out, const TColumnRange& obj);

typedef struct _TDictionaryGeneration__isset {
  _TDictionaryGeneration__isset() : dict_id(false), entry_count(false) {}
  bool dict_id :1;
  bool entry_count :1;
} _TDictionaryGeneration__isset;

class TDictionaryGeneration : public virtual ::apache::thrift::TBase {
 public:

  TDictionaryGeneration(const TDictionaryGeneration&);
  TDictionaryGeneration& operator=(const TDictionaryGeneration&);
  TDictionaryGeneration() : dict_id(0), entry_count(0) {
  }

  virtual ~TDictionaryGeneration() throw();
  int32_t dict_id;
  int64_t entry_count;

  _TDictionaryGeneration__isset __isset;

  void __set_dict_id(const int32_t val);

  void __set_entry_count(const int64_t val);

  bool operator == (const TDictionaryGeneration & rhs) const
  {
    if (!(dict_id == rhs.dict_id))
      return false;
    if (!(entry_count == rhs.entry_count))
      return false;
    return true;
  }
  bool operator != (const TDictionaryGeneration &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDictionaryGeneration & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDictionaryGeneration &a, TDictionaryGeneration &b);

std::ostream& operator<<(std::ostream& out, const TDictionaryGeneration& obj);

typedef struct _TTableGeneration__isset {
  _TTableGeneration__isset() : table_id(false), tuple_count(false), start_rowid(false) {}
  bool table_id :1;
  bool tuple_count :1;
  bool start_rowid :1;
} _TTableGeneration__isset;

class TTableGeneration : public virtual ::apache::thrift::TBase {
 public:

  TTableGeneration(const TTableGeneration&);
  TTableGeneration& operator=(const TTableGeneration&);
  TTableGeneration() : table_id(0), tuple_count(0), start_rowid(0) {
  }

  virtual ~TTableGeneration() throw();
  int32_t table_id;
  int64_t tuple_count;
  int64_t start_rowid;

  _TTableGeneration__isset __isset;

  void __set_table_id(const int32_t val);

  void __set_tuple_count(const int64_t val);

  void __set_start_rowid(const int64_t val);

  bool operator == (const TTableGeneration & rhs) const
  {
    if (!(table_id == rhs.table_id))
      return false;
    if (!(tuple_count == rhs.tuple_count))
      return false;
    if (!(start_rowid == rhs.start_rowid))
      return false;
    return true;
  }
  bool operator != (const TTableGeneration &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableGeneration & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTableGeneration &a, TTableGeneration &b);

std::ostream& operator<<(std::ostream& out, const TTableGeneration& obj);

typedef struct _TPendingQuery__isset {
  _TPendingQuery__isset() : id(false), column_ranges(false), dictionary_generations(false), table_generations(false) {}
  bool id :1;
  bool column_ranges :1;
  bool dictionary_generations :1;
  bool table_generations :1;
} _TPendingQuery__isset;

class TPendingQuery : public virtual ::apache::thrift::TBase {
 public:

  TPendingQuery(const TPendingQuery&);
  TPendingQuery& operator=(const TPendingQuery&);
  TPendingQuery() : id(0) {
  }

  virtual ~TPendingQuery() throw();
  TQueryId id;
  std::vector<TColumnRange>  column_ranges;
  std::vector<TDictionaryGeneration>  dictionary_generations;
  std::vector<TTableGeneration>  table_generations;

  _TPendingQuery__isset __isset;

  void __set_id(const TQueryId val);

  void __set_column_ranges(const std::vector<TColumnRange> & val);

  void __set_dictionary_generations(const std::vector<TDictionaryGeneration> & val);

  void __set_table_generations(const std::vector<TTableGeneration> & val);

  bool operator == (const TPendingQuery & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(column_ranges == rhs.column_ranges))
      return false;
    if (!(dictionary_generations == rhs.dictionary_generations))
      return false;
    if (!(table_generations == rhs.table_generations))
      return false;
    return true;
  }
  bool operator != (const TPendingQuery &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPendingQuery & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPendingQuery &a, TPendingQuery &b);

std::ostream& operator<<(std::ostream& out, const TPendingQuery& obj);

typedef struct _TVarLen__isset {
  _TVarLen__isset() : payload(false), is_null(false) {}
  bool payload :1;
  bool is_null :1;
} _TVarLen__isset;

class TVarLen : public virtual ::apache::thrift::TBase {
 public:

  TVarLen(const TVarLen&);
  TVarLen& operator=(const TVarLen&);
  TVarLen() : payload(), is_null(0) {
  }

  virtual ~TVarLen() throw();
  std::string payload;
  bool is_null;

  _TVarLen__isset __isset;

  void __set_payload(const std::string& val);

  void __set_is_null(const bool val);

  bool operator == (const TVarLen & rhs) const
  {
    if (!(payload == rhs.payload))
      return false;
    if (!(is_null == rhs.is_null))
      return false;
    return true;
  }
  bool operator != (const TVarLen &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TVarLen & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TVarLen &a, TVarLen &b);

std::ostream& operator<<(std::ostream& out, const TVarLen& obj);

typedef struct _TDataBlockPtr__isset {
  _TDataBlockPtr__isset() : fixed_len_data(false), var_len_data(false) {}
  bool fixed_len_data :1;
  bool var_len_data :1;
} _TDataBlockPtr__isset;

class TDataBlockPtr : public virtual ::apache::thrift::TBase {
 public:

  TDataBlockPtr(const TDataBlockPtr&);
  TDataBlockPtr& operator=(const TDataBlockPtr&);
  TDataBlockPtr() : fixed_len_data() {
  }

  virtual ~TDataBlockPtr() throw();
  std::string fixed_len_data;
  std::vector<TVarLen>  var_len_data;

  _TDataBlockPtr__isset __isset;

  void __set_fixed_len_data(const std::string& val);

  void __set_var_len_data(const std::vector<TVarLen> & val);

  bool operator == (const TDataBlockPtr & rhs) const
  {
    if (__isset.fixed_len_data != rhs.__isset.fixed_len_data)
      return false;
    else if (__isset.fixed_len_data && !(fixed_len_data == rhs.fixed_len_data))
      return false;
    if (__isset.var_len_data != rhs.__isset.var_len_data)
      return false;
    else if (__isset.var_len_data && !(var_len_data == rhs.var_len_data))
      return false;
    return true;
  }
  bool operator != (const TDataBlockPtr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDataBlockPtr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDataBlockPtr &a, TDataBlockPtr &b);

std::ostream& operator<<(std::ostream& out, const TDataBlockPtr& obj);

typedef struct _TInsertData__isset {
  _TInsertData__isset() : db_id(false), table_id(false), column_ids(false), data(false), num_rows(false) {}
  bool db_id :1;
  bool table_id :1;
  bool column_ids :1;
  bool data :1;
  bool num_rows :1;
} _TInsertData__isset;

class TInsertData : public virtual ::apache::thrift::TBase {
 public:

  TInsertData(const TInsertData&);
  TInsertData& operator=(const TInsertData&);
  TInsertData() : db_id(0), table_id(0), num_rows(0) {
  }

  virtual ~TInsertData() throw();
  int32_t db_id;
  int32_t table_id;
  std::vector<int32_t>  column_ids;
  std::vector<TDataBlockPtr>  data;
  int64_t num_rows;

  _TInsertData__isset __isset;

  void __set_db_id(const int32_t val);

  void __set_table_id(const int32_t val);

  void __set_column_ids(const std::vector<int32_t> & val);

  void __set_data(const std::vector<TDataBlockPtr> & val);

  void __set_num_rows(const int64_t val);

  bool operator == (const TInsertData & rhs) const
  {
    if (!(db_id == rhs.db_id))
      return false;
    if (!(table_id == rhs.table_id))
      return false;
    if (!(column_ids == rhs.column_ids))
      return false;
    if (!(data == rhs.data))
      return false;
    if (!(num_rows == rhs.num_rows))
      return false;
    return true;
  }
  bool operator != (const TInsertData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TInsertData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TInsertData &a, TInsertData &b);

std::ostream& operator<<(std::ostream& out, const TInsertData& obj);

typedef struct _TPendingRenderQuery__isset {
  _TPendingRenderQuery__isset() : id(false) {}
  bool id :1;
} _TPendingRenderQuery__isset;

class TPendingRenderQuery : public virtual ::apache::thrift::TBase {
 public:

  TPendingRenderQuery(const TPendingRenderQuery&);
  TPendingRenderQuery& operator=(const TPendingRenderQuery&);
  TPendingRenderQuery() : id(0) {
  }

  virtual ~TPendingRenderQuery() throw();
  TQueryId id;

  _TPendingRenderQuery__isset __isset;

  void __set_id(const TQueryId val);

  bool operator == (const TPendingRenderQuery & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const TPendingRenderQuery &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPendingRenderQuery & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPendingRenderQuery &a, TPendingRenderQuery &b);

std::ostream& operator<<(std::ostream& out, const TPendingRenderQuery& obj);

typedef struct _TRenderParseResult__isset {
  _TRenderParseResult__isset() : merge_type(false), node_id(false), execution_time_ms(false), render_time_ms(false), total_time_ms(false) {}
  bool merge_type :1;
  bool node_id :1;
  bool execution_time_ms :1;
  bool render_time_ms :1;
  bool total_time_ms :1;
} _TRenderParseResult__isset;

class TRenderParseResult : public virtual ::apache::thrift::TBase {
 public:

  TRenderParseResult(const TRenderParseResult&);
  TRenderParseResult& operator=(const TRenderParseResult&);
  TRenderParseResult() : merge_type((TMergeType::type)0), node_id(0), execution_time_ms(0), render_time_ms(0), total_time_ms(0) {
  }

  virtual ~TRenderParseResult() throw();
  TMergeType::type merge_type;
  int32_t node_id;
  int64_t execution_time_ms;
  int64_t render_time_ms;
  int64_t total_time_ms;

  _TRenderParseResult__isset __isset;

  void __set_merge_type(const TMergeType::type val);

  void __set_node_id(const int32_t val);

  void __set_execution_time_ms(const int64_t val);

  void __set_render_time_ms(const int64_t val);

  void __set_total_time_ms(const int64_t val);

  bool operator == (const TRenderParseResult & rhs) const
  {
    if (!(merge_type == rhs.merge_type))
      return false;
    if (!(node_id == rhs.node_id))
      return false;
    if (!(execution_time_ms == rhs.execution_time_ms))
      return false;
    if (!(render_time_ms == rhs.render_time_ms))
      return false;
    if (!(total_time_ms == rhs.total_time_ms))
      return false;
    return true;
  }
  bool operator != (const TRenderParseResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRenderParseResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRenderParseResult &a, TRenderParseResult &b);

std::ostream& operator<<(std::ostream& out, const TRenderParseResult& obj);

typedef struct _TRawRenderPassDataResult__isset {
  _TRawRenderPassDataResult__isset() : num_pixel_channels(false), num_pixel_samples(false), pixels(false), row_ids_A(false), row_ids_B(false), table_ids(false), accum_data(false) {}
  bool num_pixel_channels :1;
  bool num_pixel_samples :1;
  bool pixels :1;
  bool row_ids_A :1;
  bool row_ids_B :1;
  bool table_ids :1;
  bool accum_data :1;
} _TRawRenderPassDataResult__isset;

class TRawRenderPassDataResult : public virtual ::apache::thrift::TBase {
 public:

  TRawRenderPassDataResult(const TRawRenderPassDataResult&);
  TRawRenderPassDataResult& operator=(const TRawRenderPassDataResult&);
  TRawRenderPassDataResult() : num_pixel_channels(0), num_pixel_samples(0), pixels(), row_ids_A(), row_ids_B(), table_ids(), accum_data() {
  }

  virtual ~TRawRenderPassDataResult() throw();
  int32_t num_pixel_channels;
  int32_t num_pixel_samples;
  std::string pixels;
  std::string row_ids_A;
  std::string row_ids_B;
  std::string table_ids;
  std::string accum_data;

  _TRawRenderPassDataResult__isset __isset;

  void __set_num_pixel_channels(const int32_t val);

  void __set_num_pixel_samples(const int32_t val);

  void __set_pixels(const std::string& val);

  void __set_row_ids_A(const std::string& val);

  void __set_row_ids_B(const std::string& val);

  void __set_table_ids(const std::string& val);

  void __set_accum_data(const std::string& val);

  bool operator == (const TRawRenderPassDataResult & rhs) const
  {
    if (!(num_pixel_channels == rhs.num_pixel_channels))
      return false;
    if (!(num_pixel_samples == rhs.num_pixel_samples))
      return false;
    if (!(pixels == rhs.pixels))
      return false;
    if (!(row_ids_A == rhs.row_ids_A))
      return false;
    if (!(row_ids_B == rhs.row_ids_B))
      return false;
    if (!(table_ids == rhs.table_ids))
      return false;
    if (!(accum_data == rhs.accum_data))
      return false;
    return true;
  }
  bool operator != (const TRawRenderPassDataResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRawRenderPassDataResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRawRenderPassDataResult &a, TRawRenderPassDataResult &b);

std::ostream& operator<<(std::ostream& out, const TRawRenderPassDataResult& obj);

typedef struct _TRawPixelData__isset {
  _TRawPixelData__isset() : width(false), height(false), render_pass_map(false) {}
  bool width :1;
  bool height :1;
  bool render_pass_map :1;
} _TRawPixelData__isset;

class TRawPixelData : public virtual ::apache::thrift::TBase {
 public:

  TRawPixelData(const TRawPixelData&);
  TRawPixelData& operator=(const TRawPixelData&);
  TRawPixelData() : width(0), height(0) {
  }

  virtual ~TRawPixelData() throw();
  int32_t width;
  int32_t height;
  TRenderPassMap render_pass_map;

  _TRawPixelData__isset __isset;

  void __set_width(const int32_t val);

  void __set_height(const int32_t val);

  void __set_render_pass_map(const TRenderPassMap& val);

  bool operator == (const TRawPixelData & rhs) const
  {
    if (!(width == rhs.width))
      return false;
    if (!(height == rhs.height))
      return false;
    if (!(render_pass_map == rhs.render_pass_map))
      return false;
    return true;
  }
  bool operator != (const TRawPixelData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRawPixelData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRawPixelData &a, TRawPixelData &b);

std::ostream& operator<<(std::ostream& out, const TRawPixelData& obj);

typedef struct _TRenderDatum__isset {
  _TRenderDatum__isset() : type(false), cnt(false), value(false) {}
  bool type :1;
  bool cnt :1;
  bool value :1;
} _TRenderDatum__isset;

class TRenderDatum : public virtual ::apache::thrift::TBase {
 public:

  TRenderDatum(const TRenderDatum&);
  TRenderDatum& operator=(const TRenderDatum&);
  TRenderDatum() : type(( ::TDatumType::type)0), cnt(0), value() {
  }

  virtual ~TRenderDatum() throw();
   ::TDatumType::type type;
  int32_t cnt;
  std::string value;

  _TRenderDatum__isset __isset;

  void __set_type(const  ::TDatumType::type val);

  void __set_cnt(const int32_t val);

  void __set_value(const std::string& val);

  bool operator == (const TRenderDatum & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(cnt == rhs.cnt))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TRenderDatum &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRenderDatum & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRenderDatum &a, TRenderDatum &b);

std::ostream& operator<<(std::ostream& out, const TRenderDatum& obj);

typedef struct _TRenderStepResult__isset {
  _TRenderStepResult__isset() : merge_data(false), raw_pixel_data(false), execution_time_ms(false), render_time_ms(false), total_time_ms(false) {}
  bool merge_data :1;
  bool raw_pixel_data :1;
  bool execution_time_ms :1;
  bool render_time_ms :1;
  bool total_time_ms :1;
} _TRenderStepResult__isset;

class TRenderStepResult : public virtual ::apache::thrift::TBase {
 public:

  TRenderStepResult(const TRenderStepResult&);
  TRenderStepResult& operator=(const TRenderStepResult&);
  TRenderStepResult() : execution_time_ms(0), render_time_ms(0), total_time_ms(0) {
  }

  virtual ~TRenderStepResult() throw();
  TRenderAggDataMap merge_data;
  TRawPixelData raw_pixel_data;
  int64_t execution_time_ms;
  int64_t render_time_ms;
  int64_t total_time_ms;

  _TRenderStepResult__isset __isset;

  void __set_merge_data(const TRenderAggDataMap& val);

  void __set_raw_pixel_data(const TRawPixelData& val);

  void __set_execution_time_ms(const int64_t val);

  void __set_render_time_ms(const int64_t val);

  void __set_total_time_ms(const int64_t val);

  bool operator == (const TRenderStepResult & rhs) const
  {
    if (!(merge_data == rhs.merge_data))
      return false;
    if (!(raw_pixel_data == rhs.raw_pixel_data))
      return false;
    if (!(execution_time_ms == rhs.execution_time_ms))
      return false;
    if (!(render_time_ms == rhs.render_time_ms))
      return false;
    if (!(total_time_ms == rhs.total_time_ms))
      return false;
    return true;
  }
  bool operator != (const TRenderStepResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRenderStepResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRenderStepResult &a, TRenderStepResult &b);

std::ostream& operator<<(std::ostream& out, const TRenderStepResult& obj);

typedef struct _TDatabasePermissions__isset {
  _TDatabasePermissions__isset() : create_(false), delete_(false), view_sql_editor_(false), access_(false) {}
  bool create_ :1;
  bool delete_ :1;
  bool view_sql_editor_ :1;
  bool access_ :1;
} _TDatabasePermissions__isset;

class TDatabasePermissions : public virtual ::apache::thrift::TBase {
 public:

  TDatabasePermissions(const TDatabasePermissions&);
  TDatabasePermissions& operator=(const TDatabasePermissions&);
  TDatabasePermissions() : create_(0), delete_(0), view_sql_editor_(0), access_(0) {
  }

  virtual ~TDatabasePermissions() throw();
  bool create_;
  bool delete_;
  bool view_sql_editor_;
  bool access_;

  _TDatabasePermissions__isset __isset;

  void __set_create_(const bool val);

  void __set_delete_(const bool val);

  void __set_view_sql_editor_(const bool val);

  void __set_access_(const bool val);

  bool operator == (const TDatabasePermissions & rhs) const
  {
    if (!(create_ == rhs.create_))
      return false;
    if (!(delete_ == rhs.delete_))
      return false;
    if (!(view_sql_editor_ == rhs.view_sql_editor_))
      return false;
    if (!(access_ == rhs.access_))
      return false;
    return true;
  }
  bool operator != (const TDatabasePermissions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDatabasePermissions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDatabasePermissions &a, TDatabasePermissions &b);

std::ostream& operator<<(std::ostream& out, const TDatabasePermissions& obj);

typedef struct _TTablePermissions__isset {
  _TTablePermissions__isset() : create_(false), drop_(false), select_(false), insert_(false), update_(false), delete_(false), truncate_(false), alter_(false) {}
  bool create_ :1;
  bool drop_ :1;
  bool select_ :1;
  bool insert_ :1;
  bool update_ :1;
  bool delete_ :1;
  bool truncate_ :1;
  bool alter_ :1;
} _TTablePermissions__isset;

class TTablePermissions : public virtual ::apache::thrift::TBase {
 public:

  TTablePermissions(const TTablePermissions&);
  TTablePermissions& operator=(const TTablePermissions&);
  TTablePermissions() : create_(0), drop_(0), select_(0), insert_(0), update_(0), delete_(0), truncate_(0), alter_(0) {
  }

  virtual ~TTablePermissions() throw();
  bool create_;
  bool drop_;
  bool select_;
  bool insert_;
  bool update_;
  bool delete_;
  bool truncate_;
  bool alter_;

  _TTablePermissions__isset __isset;

  void __set_create_(const bool val);

  void __set_drop_(const bool val);

  void __set_select_(const bool val);

  void __set_insert_(const bool val);

  void __set_update_(const bool val);

  void __set_delete_(const bool val);

  void __set_truncate_(const bool val);

  void __set_alter_(const bool val);

  bool operator == (const TTablePermissions & rhs) const
  {
    if (!(create_ == rhs.create_))
      return false;
    if (!(drop_ == rhs.drop_))
      return false;
    if (!(select_ == rhs.select_))
      return false;
    if (!(insert_ == rhs.insert_))
      return false;
    if (!(update_ == rhs.update_))
      return false;
    if (!(delete_ == rhs.delete_))
      return false;
    if (!(truncate_ == rhs.truncate_))
      return false;
    if (!(alter_ == rhs.alter_))
      return false;
    return true;
  }
  bool operator != (const TTablePermissions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTablePermissions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTablePermissions &a, TTablePermissions &b);

std::ostream& operator<<(std::ostream& out, const TTablePermissions& obj);

typedef struct _TDashboardPermissions__isset {
  _TDashboardPermissions__isset() : create_(false), delete_(false), view_(false), edit_(false) {}
  bool create_ :1;
  bool delete_ :1;
  bool view_ :1;
  bool edit_ :1;
} _TDashboardPermissions__isset;

class TDashboardPermissions : public virtual ::apache::thrift::TBase {
 public:

  TDashboardPermissions(const TDashboardPermissions&);
  TDashboardPermissions& operator=(const TDashboardPermissions&);
  TDashboardPermissions() : create_(0), delete_(0), view_(0), edit_(0) {
  }

  virtual ~TDashboardPermissions() throw();
  bool create_;
  bool delete_;
  bool view_;
  bool edit_;

  _TDashboardPermissions__isset __isset;

  void __set_create_(const bool val);

  void __set_delete_(const bool val);

  void __set_view_(const bool val);

  void __set_edit_(const bool val);

  bool operator == (const TDashboardPermissions & rhs) const
  {
    if (!(create_ == rhs.create_))
      return false;
    if (!(delete_ == rhs.delete_))
      return false;
    if (!(view_ == rhs.view_))
      return false;
    if (!(edit_ == rhs.edit_))
      return false;
    return true;
  }
  bool operator != (const TDashboardPermissions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDashboardPermissions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDashboardPermissions &a, TDashboardPermissions &b);

std::ostream& operator<<(std::ostream& out, const TDashboardPermissions& obj);

typedef struct _TViewPermissions__isset {
  _TViewPermissions__isset() : create_(false), drop_(false), select_(false), insert_(false), update_(false), delete_(false) {}
  bool create_ :1;
  bool drop_ :1;
  bool select_ :1;
  bool insert_ :1;
  bool update_ :1;
  bool delete_ :1;
} _TViewPermissions__isset;

class TViewPermissions : public virtual ::apache::thrift::TBase {
 public:

  TViewPermissions(const TViewPermissions&);
  TViewPermissions& operator=(const TViewPermissions&);
  TViewPermissions() : create_(0), drop_(0), select_(0), insert_(0), update_(0), delete_(0) {
  }

  virtual ~TViewPermissions() throw();
  bool create_;
  bool drop_;
  bool select_;
  bool insert_;
  bool update_;
  bool delete_;

  _TViewPermissions__isset __isset;

  void __set_create_(const bool val);

  void __set_drop_(const bool val);

  void __set_select_(const bool val);

  void __set_insert_(const bool val);

  void __set_update_(const bool val);

  void __set_delete_(const bool val);

  bool operator == (const TViewPermissions & rhs) const
  {
    if (!(create_ == rhs.create_))
      return false;
    if (!(drop_ == rhs.drop_))
      return false;
    if (!(select_ == rhs.select_))
      return false;
    if (!(insert_ == rhs.insert_))
      return false;
    if (!(update_ == rhs.update_))
      return false;
    if (!(delete_ == rhs.delete_))
      return false;
    return true;
  }
  bool operator != (const TViewPermissions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TViewPermissions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TViewPermissions &a, TViewPermissions &b);

std::ostream& operator<<(std::ostream& out, const TViewPermissions& obj);

typedef struct _TDBObjectPermissions__isset {
  _TDBObjectPermissions__isset() : database_permissions_(false), table_permissions_(false), dashboard_permissions_(false), view_permissions_(false) {}
  bool database_permissions_ :1;
  bool table_permissions_ :1;
  bool dashboard_permissions_ :1;
  bool view_permissions_ :1;
} _TDBObjectPermissions__isset;

class TDBObjectPermissions : public virtual ::apache::thrift::TBase {
 public:

  TDBObjectPermissions(const TDBObjectPermissions&);
  TDBObjectPermissions& operator=(const TDBObjectPermissions&);
  TDBObjectPermissions() {
  }

  virtual ~TDBObjectPermissions() throw();
  TDatabasePermissions database_permissions_;
  TTablePermissions table_permissions_;
  TDashboardPermissions dashboard_permissions_;
  TViewPermissions view_permissions_;

  _TDBObjectPermissions__isset __isset;

  void __set_database_permissions_(const TDatabasePermissions& val);

  void __set_table_permissions_(const TTablePermissions& val);

  void __set_dashboard_permissions_(const TDashboardPermissions& val);

  void __set_view_permissions_(const TViewPermissions& val);

  bool operator == (const TDBObjectPermissions & rhs) const
  {
    if (__isset.database_permissions_ != rhs.__isset.database_permissions_)
      return false;
    else if (__isset.database_permissions_ && !(database_permissions_ == rhs.database_permissions_))
      return false;
    if (__isset.table_permissions_ != rhs.__isset.table_permissions_)
      return false;
    else if (__isset.table_permissions_ && !(table_permissions_ == rhs.table_permissions_))
      return false;
    if (__isset.dashboard_permissions_ != rhs.__isset.dashboard_permissions_)
      return false;
    else if (__isset.dashboard_permissions_ && !(dashboard_permissions_ == rhs.dashboard_permissions_))
      return false;
    if (__isset.view_permissions_ != rhs.__isset.view_permissions_)
      return false;
    else if (__isset.view_permissions_ && !(view_permissions_ == rhs.view_permissions_))
      return false;
    return true;
  }
  bool operator != (const TDBObjectPermissions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDBObjectPermissions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDBObjectPermissions &a, TDBObjectPermissions &b);

std::ostream& operator<<(std::ostream& out, const TDBObjectPermissions& obj);

typedef struct _TDBObject__isset {
  _TDBObject__isset() : objectName(false), objectType(false), privs(false), grantee(false) {}
  bool objectName :1;
  bool objectType :1;
  bool privs :1;
  bool grantee :1;
} _TDBObject__isset;

class TDBObject : public virtual ::apache::thrift::TBase {
 public:

  TDBObject(const TDBObject&);
  TDBObject& operator=(const TDBObject&);
  TDBObject() : objectName(), objectType((TDBObjectType::type)0), grantee() {
  }

  virtual ~TDBObject() throw();
  std::string objectName;
  TDBObjectType::type objectType;
  std::vector<bool>  privs;
  std::string grantee;

  _TDBObject__isset __isset;

  void __set_objectName(const std::string& val);

  void __set_objectType(const TDBObjectType::type val);

  void __set_privs(const std::vector<bool> & val);

  void __set_grantee(const std::string& val);

  bool operator == (const TDBObject & rhs) const
  {
    if (!(objectName == rhs.objectName))
      return false;
    if (!(objectType == rhs.objectType))
      return false;
    if (!(privs == rhs.privs))
      return false;
    if (!(grantee == rhs.grantee))
      return false;
    return true;
  }
  bool operator != (const TDBObject &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDBObject & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDBObject &a, TDBObject &b);

std::ostream& operator<<(std::ostream& out, const TDBObject& obj);

typedef struct _TDashboardGrantees__isset {
  _TDashboardGrantees__isset() : name(false), is_user(false), permissions(false) {}
  bool name :1;
  bool is_user :1;
  bool permissions :1;
} _TDashboardGrantees__isset;

class TDashboardGrantees : public virtual ::apache::thrift::TBase {
 public:

  TDashboardGrantees(const TDashboardGrantees&);
  TDashboardGrantees& operator=(const TDashboardGrantees&);
  TDashboardGrantees() : name(), is_user(0) {
  }

  virtual ~TDashboardGrantees() throw();
  std::string name;
  bool is_user;
  TDashboardPermissions permissions;

  _TDashboardGrantees__isset __isset;

  void __set_name(const std::string& val);

  void __set_is_user(const bool val);

  void __set_permissions(const TDashboardPermissions& val);

  bool operator == (const TDashboardGrantees & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(is_user == rhs.is_user))
      return false;
    if (!(permissions == rhs.permissions))
      return false;
    return true;
  }
  bool operator != (const TDashboardGrantees &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDashboardGrantees & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDashboardGrantees &a, TDashboardGrantees &b);

std::ostream& operator<<(std::ostream& out, const TDashboardGrantees& obj);

typedef struct _TLicenseInfo__isset {
  _TLicenseInfo__isset() : claims(false) {}
  bool claims :1;
} _TLicenseInfo__isset;

class TLicenseInfo : public virtual ::apache::thrift::TBase {
 public:

  TLicenseInfo(const TLicenseInfo&);
  TLicenseInfo& operator=(const TLicenseInfo&);
  TLicenseInfo() {
  }

  virtual ~TLicenseInfo() throw();
  std::vector<std::string>  claims;

  _TLicenseInfo__isset __isset;

  void __set_claims(const std::vector<std::string> & val);

  bool operator == (const TLicenseInfo & rhs) const
  {
    if (!(claims == rhs.claims))
      return false;
    return true;
  }
  bool operator != (const TLicenseInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TLicenseInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TLicenseInfo &a, TLicenseInfo &b);

std::ostream& operator<<(std::ostream& out, const TLicenseInfo& obj);

typedef struct _TSessionInfo__isset {
  _TSessionInfo__isset() : user(false), database(false), start_time(false), is_super(false) {}
  bool user :1;
  bool database :1;
  bool start_time :1;
  bool is_super :1;
} _TSessionInfo__isset;

class TSessionInfo : public virtual ::apache::thrift::TBase {
 public:

  TSessionInfo(const TSessionInfo&);
  TSessionInfo& operator=(const TSessionInfo&);
  TSessionInfo() : user(), database(), start_time(0), is_super(0) {
  }

  virtual ~TSessionInfo() throw();
  std::string user;
  std::string database;
  int64_t start_time;
  bool is_super;

  _TSessionInfo__isset __isset;

  void __set_user(const std::string& val);

  void __set_database(const std::string& val);

  void __set_start_time(const int64_t val);

  void __set_is_super(const bool val);

  bool operator == (const TSessionInfo & rhs) const
  {
    if (!(user == rhs.user))
      return false;
    if (!(database == rhs.database))
      return false;
    if (!(start_time == rhs.start_time))
      return false;
    if (!(is_super == rhs.is_super))
      return false;
    return true;
  }
  bool operator != (const TSessionInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSessionInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSessionInfo &a, TSessionInfo &b);

std::ostream& operator<<(std::ostream& out, const TSessionInfo& obj);

typedef struct _TGeoFileLayerInfo__isset {
  _TGeoFileLayerInfo__isset() : name(false), contents(false) {}
  bool name :1;
  bool contents :1;
} _TGeoFileLayerInfo__isset;

class TGeoFileLayerInfo : public virtual ::apache::thrift::TBase {
 public:

  TGeoFileLayerInfo(const TGeoFileLayerInfo&);
  TGeoFileLayerInfo& operator=(const TGeoFileLayerInfo&);
  TGeoFileLayerInfo() : name(), contents((TGeoFileLayerContents::type)0) {
  }

  virtual ~TGeoFileLayerInfo() throw();
  std::string name;
  TGeoFileLayerContents::type contents;

  _TGeoFileLayerInfo__isset __isset;

  void __set_name(const std::string& val);

  void __set_contents(const TGeoFileLayerContents::type val);

  bool operator == (const TGeoFileLayerInfo & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(contents == rhs.contents))
      return false;
    return true;
  }
  bool operator != (const TGeoFileLayerInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGeoFileLayerInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGeoFileLayerInfo &a, TGeoFileLayerInfo &b);

std::ostream& operator<<(std::ostream& out, const TGeoFileLayerInfo& obj);



#endif
