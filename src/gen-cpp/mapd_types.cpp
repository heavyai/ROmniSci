/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "mapd_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kTExecuteModeValues[] = {
  TExecuteMode::GPU,
  TExecuteMode::CPU
};
const char* _kTExecuteModeNames[] = {
  "GPU",
  "CPU"
};
const std::map<int, const char*> _TExecuteMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTExecuteModeValues, _kTExecuteModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TExecuteMode::type& val) {
  std::map<int, const char*>::const_iterator it = _TExecuteMode_VALUES_TO_NAMES.find(val);
  if (it != _TExecuteMode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTFileTypeValues[] = {
  TFileType::DELIMITED,
  TFileType::POLYGON,
  TFileType::PARQUET
};
const char* _kTFileTypeNames[] = {
  "DELIMITED",
  "POLYGON",
  "PARQUET"
};
const std::map<int, const char*> _TFileType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTFileTypeValues, _kTFileTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TFileType::type& val) {
  std::map<int, const char*>::const_iterator it = _TFileType_VALUES_TO_NAMES.find(val);
  if (it != _TFileType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTPartitionDetailValues[] = {
  TPartitionDetail::DEFAULT,
  TPartitionDetail::REPLICATED,
  TPartitionDetail::SHARDED,
  TPartitionDetail::OTHER
};
const char* _kTPartitionDetailNames[] = {
  "DEFAULT",
  "REPLICATED",
  "SHARDED",
  "OTHER"
};
const std::map<int, const char*> _TPartitionDetail_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTPartitionDetailValues, _kTPartitionDetailNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TPartitionDetail::type& val) {
  std::map<int, const char*>::const_iterator it = _TPartitionDetail_VALUES_TO_NAMES.find(val);
  if (it != _TPartitionDetail_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTGeoFileLayerContentsValues[] = {
  TGeoFileLayerContents::EMPTY,
  TGeoFileLayerContents::GEO,
  TGeoFileLayerContents::NON_GEO,
  TGeoFileLayerContents::UNSUPPORTED_GEO
};
const char* _kTGeoFileLayerContentsNames[] = {
  "EMPTY",
  "GEO",
  "NON_GEO",
  "UNSUPPORTED_GEO"
};
const std::map<int, const char*> _TGeoFileLayerContents_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTGeoFileLayerContentsValues, _kTGeoFileLayerContentsNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TGeoFileLayerContents::type& val) {
  std::map<int, const char*>::const_iterator it = _TGeoFileLayerContents_VALUES_TO_NAMES.find(val);
  if (it != _TGeoFileLayerContents_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTImportHeaderRowValues[] = {
  TImportHeaderRow::AUTODETECT,
  TImportHeaderRow::NO_HEADER,
  TImportHeaderRow::HAS_HEADER
};
const char* _kTImportHeaderRowNames[] = {
  "AUTODETECT",
  "NO_HEADER",
  "HAS_HEADER"
};
const std::map<int, const char*> _TImportHeaderRow_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTImportHeaderRowValues, _kTImportHeaderRowNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TImportHeaderRow::type& val) {
  std::map<int, const char*>::const_iterator it = _TImportHeaderRow_VALUES_TO_NAMES.find(val);
  if (it != _TImportHeaderRow_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTRoleValues[] = {
  TRole::SERVER,
  TRole::AGGREGATOR,
  TRole::LEAF,
  TRole::STRING_DICTIONARY
};
const char* _kTRoleNames[] = {
  "SERVER",
  "AGGREGATOR",
  "LEAF",
  "STRING_DICTIONARY"
};
const std::map<int, const char*> _TRole_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTRoleValues, _kTRoleNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TRole::type& val) {
  std::map<int, const char*>::const_iterator it = _TRole_VALUES_TO_NAMES.find(val);
  if (it != _TRole_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTMergeTypeValues[] = {
  TMergeType::UNION,
  TMergeType::REDUCE
};
const char* _kTMergeTypeNames[] = {
  "UNION",
  "REDUCE"
};
const std::map<int, const char*> _TMergeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTMergeTypeValues, _kTMergeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TMergeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TMergeType_VALUES_TO_NAMES.find(val);
  if (it != _TMergeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTExpressionRangeTypeValues[] = {
  TExpressionRangeType::INVALID,
  TExpressionRangeType::INTEGER,
  TExpressionRangeType::FLOAT,
  TExpressionRangeType::DOUBLE
};
const char* _kTExpressionRangeTypeNames[] = {
  "INVALID",
  "INTEGER",
  "FLOAT",
  "DOUBLE"
};
const std::map<int, const char*> _TExpressionRangeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTExpressionRangeTypeValues, _kTExpressionRangeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TExpressionRangeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TExpressionRangeType_VALUES_TO_NAMES.find(val);
  if (it != _TExpressionRangeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTDBObjectTypeValues[] = {
  TDBObjectType::AbstractDBObjectType,
  TDBObjectType::DatabaseDBObjectType,
  TDBObjectType::TableDBObjectType,
  TDBObjectType::DashboardDBObjectType,
  TDBObjectType::ViewDBObjectType
};
const char* _kTDBObjectTypeNames[] = {
  "AbstractDBObjectType",
  "DatabaseDBObjectType",
  "TableDBObjectType",
  "DashboardDBObjectType",
  "ViewDBObjectType"
};
const std::map<int, const char*> _TDBObjectType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTDBObjectTypeValues, _kTDBObjectTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TDBObjectType::type& val) {
  std::map<int, const char*>::const_iterator it = _TDBObjectType_VALUES_TO_NAMES.find(val);
  if (it != _TDBObjectType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


TDatumVal::~TDatumVal() throw() {
}


void TDatumVal::__set_int_val(const int64_t val) {
  this->int_val = val;
}

void TDatumVal::__set_real_val(const double val) {
  this->real_val = val;
}

void TDatumVal::__set_str_val(const std::string& val) {
  this->str_val = val;
}

void TDatumVal::__set_arr_val(const std::vector<TDatum> & val) {
  this->arr_val = val;
}
std::ostream& operator<<(std::ostream& out, const TDatumVal& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDatumVal::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->int_val);
          this->__isset.int_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->real_val);
          this->__isset.real_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->str_val);
          this->__isset.str_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arr_val.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->arr_val.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->arr_val[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arr_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDatumVal::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDatumVal");

  xfer += oprot->writeFieldBegin("int_val", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->int_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("real_val", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->real_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("str_val", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->str_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arr_val", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arr_val.size()));
    std::vector<TDatum> ::const_iterator _iter5;
    for (_iter5 = this->arr_val.begin(); _iter5 != this->arr_val.end(); ++_iter5)
    {
      xfer += (*_iter5).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDatumVal &a, TDatumVal &b) {
  using ::std::swap;
  swap(a.int_val, b.int_val);
  swap(a.real_val, b.real_val);
  swap(a.str_val, b.str_val);
  swap(a.arr_val, b.arr_val);
  swap(a.__isset, b.__isset);
}

TDatumVal::TDatumVal(const TDatumVal& other6) {
  int_val = other6.int_val;
  real_val = other6.real_val;
  str_val = other6.str_val;
  arr_val = other6.arr_val;
  __isset = other6.__isset;
}
TDatumVal& TDatumVal::operator=(const TDatumVal& other7) {
  int_val = other7.int_val;
  real_val = other7.real_val;
  str_val = other7.str_val;
  arr_val = other7.arr_val;
  __isset = other7.__isset;
  return *this;
}
void TDatumVal::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDatumVal(";
  out << "int_val=" << to_string(int_val);
  out << ", " << "real_val=" << to_string(real_val);
  out << ", " << "str_val=" << to_string(str_val);
  out << ", " << "arr_val=" << to_string(arr_val);
  out << ")";
}


TDatum::~TDatum() throw() {
}


void TDatum::__set_val(const TDatumVal& val) {
  this->val = val;
}

void TDatum::__set_is_null(const bool val) {
  this->is_null = val;
}
std::ostream& operator<<(std::ostream& out, const TDatum& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDatum::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->val.read(iprot);
          this->__isset.val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_null);
          this->__isset.is_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDatum::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDatum");

  xfer += oprot->writeFieldBegin("val", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->val.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_null", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDatum &a, TDatum &b) {
  using ::std::swap;
  swap(a.val, b.val);
  swap(a.is_null, b.is_null);
  swap(a.__isset, b.__isset);
}

TDatum::TDatum(const TDatum& other8) {
  val = other8.val;
  is_null = other8.is_null;
  __isset = other8.__isset;
}
TDatum& TDatum::operator=(const TDatum& other9) {
  val = other9.val;
  is_null = other9.is_null;
  __isset = other9.__isset;
  return *this;
}
void TDatum::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDatum(";
  out << "val=" << to_string(val);
  out << ", " << "is_null=" << to_string(is_null);
  out << ")";
}


TStringValue::~TStringValue() throw() {
}


void TStringValue::__set_str_val(const std::string& val) {
  this->str_val = val;
}

void TStringValue::__set_is_null(const bool val) {
  this->is_null = val;
}
std::ostream& operator<<(std::ostream& out, const TStringValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStringValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->str_val);
          this->__isset.str_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_null);
          this->__isset.is_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringValue");

  xfer += oprot->writeFieldBegin("str_val", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->str_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_null", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStringValue &a, TStringValue &b) {
  using ::std::swap;
  swap(a.str_val, b.str_val);
  swap(a.is_null, b.is_null);
  swap(a.__isset, b.__isset);
}

TStringValue::TStringValue(const TStringValue& other10) {
  str_val = other10.str_val;
  is_null = other10.is_null;
  __isset = other10.__isset;
}
TStringValue& TStringValue::operator=(const TStringValue& other11) {
  str_val = other11.str_val;
  is_null = other11.is_null;
  __isset = other11.__isset;
  return *this;
}
void TStringValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStringValue(";
  out << "str_val=" << to_string(str_val);
  out << ", " << "is_null=" << to_string(is_null);
  out << ")";
}


TColumnType::~TColumnType() throw() {
}


void TColumnType::__set_col_name(const std::string& val) {
  this->col_name = val;
}

void TColumnType::__set_col_type(const  ::TTypeInfo& val) {
  this->col_type = val;
}

void TColumnType::__set_is_reserved_keyword(const bool val) {
  this->is_reserved_keyword = val;
}

void TColumnType::__set_src_name(const std::string& val) {
  this->src_name = val;
}

void TColumnType::__set_is_system(const bool val) {
  this->is_system = val;
}

void TColumnType::__set_is_physical(const bool val) {
  this->is_physical = val;
}

void TColumnType::__set_col_id(const int64_t val) {
  this->col_id = val;
}
std::ostream& operator<<(std::ostream& out, const TColumnType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col_name);
          this->__isset.col_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->col_type.read(iprot);
          this->__isset.col_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_reserved_keyword);
          this->__isset.is_reserved_keyword = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->src_name);
          this->__isset.src_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_system);
          this->__isset.is_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_physical);
          this->__isset.is_physical = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->col_id);
          this->__isset.col_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnType");

  xfer += oprot->writeFieldBegin("col_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->col_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_type", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->col_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_reserved_keyword", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_reserved_keyword);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->src_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_system", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_system);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_physical", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->is_physical);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_id", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->col_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnType &a, TColumnType &b) {
  using ::std::swap;
  swap(a.col_name, b.col_name);
  swap(a.col_type, b.col_type);
  swap(a.is_reserved_keyword, b.is_reserved_keyword);
  swap(a.src_name, b.src_name);
  swap(a.is_system, b.is_system);
  swap(a.is_physical, b.is_physical);
  swap(a.col_id, b.col_id);
  swap(a.__isset, b.__isset);
}

TColumnType::TColumnType(const TColumnType& other12) {
  col_name = other12.col_name;
  col_type = other12.col_type;
  is_reserved_keyword = other12.is_reserved_keyword;
  src_name = other12.src_name;
  is_system = other12.is_system;
  is_physical = other12.is_physical;
  col_id = other12.col_id;
  __isset = other12.__isset;
}
TColumnType& TColumnType::operator=(const TColumnType& other13) {
  col_name = other13.col_name;
  col_type = other13.col_type;
  is_reserved_keyword = other13.is_reserved_keyword;
  src_name = other13.src_name;
  is_system = other13.is_system;
  is_physical = other13.is_physical;
  col_id = other13.col_id;
  __isset = other13.__isset;
  return *this;
}
void TColumnType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnType(";
  out << "col_name=" << to_string(col_name);
  out << ", " << "col_type=" << to_string(col_type);
  out << ", " << "is_reserved_keyword=" << to_string(is_reserved_keyword);
  out << ", " << "src_name=" << to_string(src_name);
  out << ", " << "is_system=" << to_string(is_system);
  out << ", " << "is_physical=" << to_string(is_physical);
  out << ", " << "col_id=" << to_string(col_id);
  out << ")";
}


TRow::~TRow() throw() {
}


void TRow::__set_cols(const std::vector<TDatum> & val) {
  this->cols = val;
}
std::ostream& operator<<(std::ostream& out, const TRow& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRow::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cols.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->cols.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += this->cols[_i18].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRow");

  xfer += oprot->writeFieldBegin("cols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cols.size()));
    std::vector<TDatum> ::const_iterator _iter19;
    for (_iter19 = this->cols.begin(); _iter19 != this->cols.end(); ++_iter19)
    {
      xfer += (*_iter19).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRow &a, TRow &b) {
  using ::std::swap;
  swap(a.cols, b.cols);
  swap(a.__isset, b.__isset);
}

TRow::TRow(const TRow& other20) {
  cols = other20.cols;
  __isset = other20.__isset;
}
TRow& TRow::operator=(const TRow& other21) {
  cols = other21.cols;
  __isset = other21.__isset;
  return *this;
}
void TRow::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRow(";
  out << "cols=" << to_string(cols);
  out << ")";
}


TColumnData::~TColumnData() throw() {
}


void TColumnData::__set_int_col(const std::vector<int64_t> & val) {
  this->int_col = val;
}

void TColumnData::__set_real_col(const std::vector<double> & val) {
  this->real_col = val;
}

void TColumnData::__set_str_col(const std::vector<std::string> & val) {
  this->str_col = val;
}

void TColumnData::__set_arr_col(const std::vector<TColumn> & val) {
  this->arr_col = val;
}
std::ostream& operator<<(std::ostream& out, const TColumnData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->int_col.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->int_col.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += iprot->readI64(this->int_col[_i26]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.int_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->real_col.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->real_col.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += iprot->readDouble(this->real_col[_i31]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.real_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->str_col.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->str_col.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += iprot->readString(this->str_col[_i36]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.str_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arr_col.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->arr_col.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += this->arr_col[_i41].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arr_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnData");

  xfer += oprot->writeFieldBegin("int_col", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->int_col.size()));
    std::vector<int64_t> ::const_iterator _iter42;
    for (_iter42 = this->int_col.begin(); _iter42 != this->int_col.end(); ++_iter42)
    {
      xfer += oprot->writeI64((*_iter42));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("real_col", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->real_col.size()));
    std::vector<double> ::const_iterator _iter43;
    for (_iter43 = this->real_col.begin(); _iter43 != this->real_col.end(); ++_iter43)
    {
      xfer += oprot->writeDouble((*_iter43));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("str_col", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->str_col.size()));
    std::vector<std::string> ::const_iterator _iter44;
    for (_iter44 = this->str_col.begin(); _iter44 != this->str_col.end(); ++_iter44)
    {
      xfer += oprot->writeString((*_iter44));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arr_col", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arr_col.size()));
    std::vector<TColumn> ::const_iterator _iter45;
    for (_iter45 = this->arr_col.begin(); _iter45 != this->arr_col.end(); ++_iter45)
    {
      xfer += (*_iter45).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnData &a, TColumnData &b) {
  using ::std::swap;
  swap(a.int_col, b.int_col);
  swap(a.real_col, b.real_col);
  swap(a.str_col, b.str_col);
  swap(a.arr_col, b.arr_col);
  swap(a.__isset, b.__isset);
}

TColumnData::TColumnData(const TColumnData& other46) {
  int_col = other46.int_col;
  real_col = other46.real_col;
  str_col = other46.str_col;
  arr_col = other46.arr_col;
  __isset = other46.__isset;
}
TColumnData& TColumnData::operator=(const TColumnData& other47) {
  int_col = other47.int_col;
  real_col = other47.real_col;
  str_col = other47.str_col;
  arr_col = other47.arr_col;
  __isset = other47.__isset;
  return *this;
}
void TColumnData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnData(";
  out << "int_col=" << to_string(int_col);
  out << ", " << "real_col=" << to_string(real_col);
  out << ", " << "str_col=" << to_string(str_col);
  out << ", " << "arr_col=" << to_string(arr_col);
  out << ")";
}


TColumn::~TColumn() throw() {
}


void TColumn::__set_data(const TColumnData& val) {
  this->data = val;
}

void TColumn::__set_nulls(const std::vector<bool> & val) {
  this->nulls = val;
}
std::ostream& operator<<(std::ostream& out, const TColumn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nulls.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->nulls.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += iprot->readBool(this->nulls[_i52]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumn");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->nulls.size()));
    std::vector<bool> ::const_iterator _iter53;
    for (_iter53 = this->nulls.begin(); _iter53 != this->nulls.end(); ++_iter53)
    {
      xfer += oprot->writeBool((*_iter53));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumn &a, TColumn &b) {
  using ::std::swap;
  swap(a.data, b.data);
  swap(a.nulls, b.nulls);
  swap(a.__isset, b.__isset);
}

TColumn::TColumn(const TColumn& other54) {
  data = other54.data;
  nulls = other54.nulls;
  __isset = other54.__isset;
}
TColumn& TColumn::operator=(const TColumn& other55) {
  data = other55.data;
  nulls = other55.nulls;
  __isset = other55.__isset;
  return *this;
}
void TColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumn(";
  out << "data=" << to_string(data);
  out << ", " << "nulls=" << to_string(nulls);
  out << ")";
}


TStringRow::~TStringRow() throw() {
}


void TStringRow::__set_cols(const std::vector<TStringValue> & val) {
  this->cols = val;
}
std::ostream& operator<<(std::ostream& out, const TStringRow& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStringRow::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cols.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _etype59;
            xfer += iprot->readListBegin(_etype59, _size56);
            this->cols.resize(_size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              xfer += this->cols[_i60].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringRow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringRow");

  xfer += oprot->writeFieldBegin("cols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cols.size()));
    std::vector<TStringValue> ::const_iterator _iter61;
    for (_iter61 = this->cols.begin(); _iter61 != this->cols.end(); ++_iter61)
    {
      xfer += (*_iter61).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStringRow &a, TStringRow &b) {
  using ::std::swap;
  swap(a.cols, b.cols);
  swap(a.__isset, b.__isset);
}

TStringRow::TStringRow(const TStringRow& other62) {
  cols = other62.cols;
  __isset = other62.__isset;
}
TStringRow& TStringRow::operator=(const TStringRow& other63) {
  cols = other63.cols;
  __isset = other63.__isset;
  return *this;
}
void TStringRow::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStringRow(";
  out << "cols=" << to_string(cols);
  out << ")";
}


TKrb5Session::~TKrb5Session() throw() {
}


void TKrb5Session::__set_sessionId(const TSessionId& val) {
  this->sessionId = val;
}

void TKrb5Session::__set_krbToken(const TKrb5Token& val) {
  this->krbToken = val;
}
std::ostream& operator<<(std::ostream& out, const TKrb5Session& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TKrb5Session::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sessionId);
          this->__isset.sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->krbToken);
          this->__isset.krbToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TKrb5Session::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TKrb5Session");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("krbToken", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->krbToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKrb5Session &a, TKrb5Session &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.krbToken, b.krbToken);
  swap(a.__isset, b.__isset);
}

TKrb5Session::TKrb5Session(const TKrb5Session& other64) {
  sessionId = other64.sessionId;
  krbToken = other64.krbToken;
  __isset = other64.__isset;
}
TKrb5Session& TKrb5Session::operator=(const TKrb5Session& other65) {
  sessionId = other65.sessionId;
  krbToken = other65.krbToken;
  __isset = other65.__isset;
  return *this;
}
void TKrb5Session::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TKrb5Session(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "krbToken=" << to_string(krbToken);
  out << ")";
}


TStepResult::~TStepResult() throw() {
}


void TStepResult::__set_serialized_rows(const  ::TSerializedRows& val) {
  this->serialized_rows = val;
}

void TStepResult::__set_execution_finished(const bool val) {
  this->execution_finished = val;
}

void TStepResult::__set_merge_type(const TMergeType::type val) {
  this->merge_type = val;
}

void TStepResult::__set_sharded(const bool val) {
  this->sharded = val;
}

void TStepResult::__set_row_desc(const TRowDescriptor& val) {
  this->row_desc = val;
}

void TStepResult::__set_node_id(const int32_t val) {
  this->node_id = val;
}
std::ostream& operator<<(std::ostream& out, const TStepResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStepResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serialized_rows.read(iprot);
          this->__isset.serialized_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->execution_finished);
          this->__isset.execution_finished = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast66;
          xfer += iprot->readI32(ecast66);
          this->merge_type = (TMergeType::type)ecast66;
          this->__isset.merge_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sharded);
          this->__isset.sharded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_desc.clear();
            uint32_t _size67;
            ::apache::thrift::protocol::TType _etype70;
            xfer += iprot->readListBegin(_etype70, _size67);
            this->row_desc.resize(_size67);
            uint32_t _i71;
            for (_i71 = 0; _i71 < _size67; ++_i71)
            {
              xfer += this->row_desc[_i71].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStepResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStepResult");

  xfer += oprot->writeFieldBegin("serialized_rows", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->serialized_rows.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_finished", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->execution_finished);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("merge_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->merge_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sharded", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->sharded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_desc", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row_desc.size()));
    std::vector<TColumnType> ::const_iterator _iter72;
    for (_iter72 = this->row_desc.begin(); _iter72 != this->row_desc.end(); ++_iter72)
    {
      xfer += (*_iter72).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStepResult &a, TStepResult &b) {
  using ::std::swap;
  swap(a.serialized_rows, b.serialized_rows);
  swap(a.execution_finished, b.execution_finished);
  swap(a.merge_type, b.merge_type);
  swap(a.sharded, b.sharded);
  swap(a.row_desc, b.row_desc);
  swap(a.node_id, b.node_id);
  swap(a.__isset, b.__isset);
}

TStepResult::TStepResult(const TStepResult& other73) {
  serialized_rows = other73.serialized_rows;
  execution_finished = other73.execution_finished;
  merge_type = other73.merge_type;
  sharded = other73.sharded;
  row_desc = other73.row_desc;
  node_id = other73.node_id;
  __isset = other73.__isset;
}
TStepResult& TStepResult::operator=(const TStepResult& other74) {
  serialized_rows = other74.serialized_rows;
  execution_finished = other74.execution_finished;
  merge_type = other74.merge_type;
  sharded = other74.sharded;
  row_desc = other74.row_desc;
  node_id = other74.node_id;
  __isset = other74.__isset;
  return *this;
}
void TStepResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStepResult(";
  out << "serialized_rows=" << to_string(serialized_rows);
  out << ", " << "execution_finished=" << to_string(execution_finished);
  out << ", " << "merge_type=" << to_string(merge_type);
  out << ", " << "sharded=" << to_string(sharded);
  out << ", " << "row_desc=" << to_string(row_desc);
  out << ", " << "node_id=" << to_string(node_id);
  out << ")";
}


TRowSet::~TRowSet() throw() {
}


void TRowSet::__set_row_desc(const TRowDescriptor& val) {
  this->row_desc = val;
}

void TRowSet::__set_rows(const std::vector<TRow> & val) {
  this->rows = val;
}

void TRowSet::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
}

void TRowSet::__set_is_columnar(const bool val) {
  this->is_columnar = val;
}
std::ostream& operator<<(std::ostream& out, const TRowSet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRowSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_desc.clear();
            uint32_t _size75;
            ::apache::thrift::protocol::TType _etype78;
            xfer += iprot->readListBegin(_etype78, _size75);
            this->row_desc.resize(_size75);
            uint32_t _i79;
            for (_i79 = 0; _i79 < _size75; ++_i79)
            {
              xfer += this->row_desc[_i79].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rows.clear();
            uint32_t _size80;
            ::apache::thrift::protocol::TType _etype83;
            xfer += iprot->readListBegin(_etype83, _size80);
            this->rows.resize(_size80);
            uint32_t _i84;
            for (_i84 = 0; _i84 < _size80; ++_i84)
            {
              xfer += this->rows[_i84].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size85;
            ::apache::thrift::protocol::TType _etype88;
            xfer += iprot->readListBegin(_etype88, _size85);
            this->columns.resize(_size85);
            uint32_t _i89;
            for (_i89 = 0; _i89 < _size85; ++_i89)
            {
              xfer += this->columns[_i89].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_columnar);
          this->__isset.is_columnar = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRowSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRowSet");

  xfer += oprot->writeFieldBegin("row_desc", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row_desc.size()));
    std::vector<TColumnType> ::const_iterator _iter90;
    for (_iter90 = this->row_desc.begin(); _iter90 != this->row_desc.end(); ++_iter90)
    {
      xfer += (*_iter90).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rows.size()));
    std::vector<TRow> ::const_iterator _iter91;
    for (_iter91 = this->rows.begin(); _iter91 != this->rows.end(); ++_iter91)
    {
      xfer += (*_iter91).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumn> ::const_iterator _iter92;
    for (_iter92 = this->columns.begin(); _iter92 != this->columns.end(); ++_iter92)
    {
      xfer += (*_iter92).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_columnar", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_columnar);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRowSet &a, TRowSet &b) {
  using ::std::swap;
  swap(a.row_desc, b.row_desc);
  swap(a.rows, b.rows);
  swap(a.columns, b.columns);
  swap(a.is_columnar, b.is_columnar);
  swap(a.__isset, b.__isset);
}

TRowSet::TRowSet(const TRowSet& other93) {
  row_desc = other93.row_desc;
  rows = other93.rows;
  columns = other93.columns;
  is_columnar = other93.is_columnar;
  __isset = other93.__isset;
}
TRowSet& TRowSet::operator=(const TRowSet& other94) {
  row_desc = other94.row_desc;
  rows = other94.rows;
  columns = other94.columns;
  is_columnar = other94.is_columnar;
  __isset = other94.__isset;
  return *this;
}
void TRowSet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRowSet(";
  out << "row_desc=" << to_string(row_desc);
  out << ", " << "rows=" << to_string(rows);
  out << ", " << "columns=" << to_string(columns);
  out << ", " << "is_columnar=" << to_string(is_columnar);
  out << ")";
}


TQueryResult::~TQueryResult() throw() {
}


void TQueryResult::__set_row_set(const TRowSet& val) {
  this->row_set = val;
}

void TQueryResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TQueryResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}

void TQueryResult::__set_nonce(const std::string& val) {
  this->nonce = val;
}
std::ostream& operator<<(std::ostream& out, const TQueryResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TQueryResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_set.read(iprot);
          this->__isset.row_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          this->__isset.nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TQueryResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TQueryResult");

  xfer += oprot->writeFieldBegin("row_set", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->row_set.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TQueryResult &a, TQueryResult &b) {
  using ::std::swap;
  swap(a.row_set, b.row_set);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.nonce, b.nonce);
  swap(a.__isset, b.__isset);
}

TQueryResult::TQueryResult(const TQueryResult& other95) {
  row_set = other95.row_set;
  execution_time_ms = other95.execution_time_ms;
  total_time_ms = other95.total_time_ms;
  nonce = other95.nonce;
  __isset = other95.__isset;
}
TQueryResult& TQueryResult::operator=(const TQueryResult& other96) {
  row_set = other96.row_set;
  execution_time_ms = other96.execution_time_ms;
  total_time_ms = other96.total_time_ms;
  nonce = other96.nonce;
  __isset = other96.__isset;
  return *this;
}
void TQueryResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TQueryResult(";
  out << "row_set=" << to_string(row_set);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ", " << "nonce=" << to_string(nonce);
  out << ")";
}


TDataFrame::~TDataFrame() throw() {
}


void TDataFrame::__set_sm_handle(const std::string& val) {
  this->sm_handle = val;
}

void TDataFrame::__set_sm_size(const int64_t val) {
  this->sm_size = val;
}

void TDataFrame::__set_df_handle(const std::string& val) {
  this->df_handle = val;
}

void TDataFrame::__set_df_size(const int64_t val) {
  this->df_size = val;
}
std::ostream& operator<<(std::ostream& out, const TDataFrame& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDataFrame::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->sm_handle);
          this->__isset.sm_handle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sm_size);
          this->__isset.sm_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->df_handle);
          this->__isset.df_handle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->df_size);
          this->__isset.df_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDataFrame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataFrame");

  xfer += oprot->writeFieldBegin("sm_handle", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->sm_handle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sm_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->sm_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("df_handle", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->df_handle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("df_size", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->df_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDataFrame &a, TDataFrame &b) {
  using ::std::swap;
  swap(a.sm_handle, b.sm_handle);
  swap(a.sm_size, b.sm_size);
  swap(a.df_handle, b.df_handle);
  swap(a.df_size, b.df_size);
  swap(a.__isset, b.__isset);
}

TDataFrame::TDataFrame(const TDataFrame& other97) {
  sm_handle = other97.sm_handle;
  sm_size = other97.sm_size;
  df_handle = other97.df_handle;
  df_size = other97.df_size;
  __isset = other97.__isset;
}
TDataFrame& TDataFrame::operator=(const TDataFrame& other98) {
  sm_handle = other98.sm_handle;
  sm_size = other98.sm_size;
  df_handle = other98.df_handle;
  df_size = other98.df_size;
  __isset = other98.__isset;
  return *this;
}
void TDataFrame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDataFrame(";
  out << "sm_handle=" << to_string(sm_handle);
  out << ", " << "sm_size=" << to_string(sm_size);
  out << ", " << "df_handle=" << to_string(df_handle);
  out << ", " << "df_size=" << to_string(df_size);
  out << ")";
}


TDBInfo::~TDBInfo() throw() {
}


void TDBInfo::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void TDBInfo::__set_db_owner(const std::string& val) {
  this->db_owner = val;
}
std::ostream& operator<<(std::ostream& out, const TDBInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDBInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_owner);
          this->__isset.db_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDBInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDBInfo");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_owner", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDBInfo &a, TDBInfo &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.db_owner, b.db_owner);
  swap(a.__isset, b.__isset);
}

TDBInfo::TDBInfo(const TDBInfo& other99) {
  db_name = other99.db_name;
  db_owner = other99.db_owner;
  __isset = other99.__isset;
}
TDBInfo& TDBInfo::operator=(const TDBInfo& other100) {
  db_name = other100.db_name;
  db_owner = other100.db_owner;
  __isset = other100.__isset;
  return *this;
}
void TDBInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDBInfo(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "db_owner=" << to_string(db_owner);
  out << ")";
}


TMapDException::~TMapDException() throw() {
}


void TMapDException::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}
std::ostream& operator<<(std::ostream& out, const TMapDException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TMapDException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMapDException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMapDException");

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMapDException &a, TMapDException &b) {
  using ::std::swap;
  swap(a.error_msg, b.error_msg);
  swap(a.__isset, b.__isset);
}

TMapDException::TMapDException(const TMapDException& other101) : TException() {
  error_msg = other101.error_msg;
  __isset = other101.__isset;
}
TMapDException& TMapDException::operator=(const TMapDException& other102) {
  error_msg = other102.error_msg;
  __isset = other102.__isset;
  return *this;
}
void TMapDException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMapDException(";
  out << "error_msg=" << to_string(error_msg);
  out << ")";
}

const char* TMapDException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TMapDException";
  }
}


TCopyParams::~TCopyParams() throw() {
}


void TCopyParams::__set_delimiter(const std::string& val) {
  this->delimiter = val;
}

void TCopyParams::__set_null_str(const std::string& val) {
  this->null_str = val;
}

void TCopyParams::__set_has_header(const TImportHeaderRow::type val) {
  this->has_header = val;
}

void TCopyParams::__set_quoted(const bool val) {
  this->quoted = val;
}

void TCopyParams::__set_quote(const std::string& val) {
  this->quote = val;
}

void TCopyParams::__set_escape(const std::string& val) {
  this->escape = val;
}

void TCopyParams::__set_line_delim(const std::string& val) {
  this->line_delim = val;
}

void TCopyParams::__set_array_delim(const std::string& val) {
  this->array_delim = val;
}

void TCopyParams::__set_array_begin(const std::string& val) {
  this->array_begin = val;
}

void TCopyParams::__set_array_end(const std::string& val) {
  this->array_end = val;
}

void TCopyParams::__set_threads(const int32_t val) {
  this->threads = val;
}

void TCopyParams::__set_file_type(const TFileType::type val) {
  this->file_type = val;
}

void TCopyParams::__set_s3_access_key(const std::string& val) {
  this->s3_access_key = val;
}

void TCopyParams::__set_s3_secret_key(const std::string& val) {
  this->s3_secret_key = val;
}

void TCopyParams::__set_s3_region(const std::string& val) {
  this->s3_region = val;
}

void TCopyParams::__set_geo_coords_encoding(const  ::TEncodingType::type val) {
  this->geo_coords_encoding = val;
}

void TCopyParams::__set_geo_coords_comp_param(const int32_t val) {
  this->geo_coords_comp_param = val;
}

void TCopyParams::__set_geo_coords_type(const  ::TDatumType::type val) {
  this->geo_coords_type = val;
}

void TCopyParams::__set_geo_coords_srid(const int32_t val) {
  this->geo_coords_srid = val;
}

void TCopyParams::__set_sanitize_column_names(const bool val) {
  this->sanitize_column_names = val;
}

void TCopyParams::__set_geo_layer_name(const std::string& val) {
  this->geo_layer_name = val;
}

void TCopyParams::__set_s3_endpoint(const std::string& val) {
  this->s3_endpoint = val;
}
std::ostream& operator<<(std::ostream& out, const TCopyParams& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCopyParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->delimiter);
          this->__isset.delimiter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->null_str);
          this->__isset.null_str = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast103;
          xfer += iprot->readI32(ecast103);
          this->has_header = (TImportHeaderRow::type)ecast103;
          this->__isset.has_header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->quoted);
          this->__isset.quoted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->quote);
          this->__isset.quote = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->escape);
          this->__isset.escape = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->line_delim);
          this->__isset.line_delim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->array_delim);
          this->__isset.array_delim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->array_begin);
          this->__isset.array_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->array_end);
          this->__isset.array_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->threads);
          this->__isset.threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast104;
          xfer += iprot->readI32(ecast104);
          this->file_type = (TFileType::type)ecast104;
          this->__isset.file_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_access_key);
          this->__isset.s3_access_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_secret_key);
          this->__isset.s3_secret_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_region);
          this->__isset.s3_region = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast105;
          xfer += iprot->readI32(ecast105);
          this->geo_coords_encoding = ( ::TEncodingType::type)ecast105;
          this->__isset.geo_coords_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->geo_coords_comp_param);
          this->__isset.geo_coords_comp_param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast106;
          xfer += iprot->readI32(ecast106);
          this->geo_coords_type = ( ::TDatumType::type)ecast106;
          this->__isset.geo_coords_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->geo_coords_srid);
          this->__isset.geo_coords_srid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sanitize_column_names);
          this->__isset.sanitize_column_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->geo_layer_name);
          this->__isset.geo_layer_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_endpoint);
          this->__isset.s3_endpoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCopyParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCopyParams");

  xfer += oprot->writeFieldBegin("delimiter", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->delimiter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("null_str", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->null_str);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_header", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->has_header);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quoted", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->quoted);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quote", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->quote);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("escape", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->escape);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("line_delim", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->line_delim);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("array_delim", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->array_delim);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("array_begin", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->array_begin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("array_end", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->array_end);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("threads", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->threads);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("file_type", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32((int32_t)this->file_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_access_key", ::apache::thrift::protocol::T_STRING, 13);
  xfer += oprot->writeString(this->s3_access_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_secret_key", ::apache::thrift::protocol::T_STRING, 14);
  xfer += oprot->writeString(this->s3_secret_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_region", ::apache::thrift::protocol::T_STRING, 15);
  xfer += oprot->writeString(this->s3_region);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_encoding", ::apache::thrift::protocol::T_I32, 16);
  xfer += oprot->writeI32((int32_t)this->geo_coords_encoding);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_comp_param", ::apache::thrift::protocol::T_I32, 17);
  xfer += oprot->writeI32(this->geo_coords_comp_param);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_type", ::apache::thrift::protocol::T_I32, 18);
  xfer += oprot->writeI32((int32_t)this->geo_coords_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_srid", ::apache::thrift::protocol::T_I32, 19);
  xfer += oprot->writeI32(this->geo_coords_srid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sanitize_column_names", ::apache::thrift::protocol::T_BOOL, 20);
  xfer += oprot->writeBool(this->sanitize_column_names);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_layer_name", ::apache::thrift::protocol::T_STRING, 21);
  xfer += oprot->writeString(this->geo_layer_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_endpoint", ::apache::thrift::protocol::T_STRING, 22);
  xfer += oprot->writeString(this->s3_endpoint);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCopyParams &a, TCopyParams &b) {
  using ::std::swap;
  swap(a.delimiter, b.delimiter);
  swap(a.null_str, b.null_str);
  swap(a.has_header, b.has_header);
  swap(a.quoted, b.quoted);
  swap(a.quote, b.quote);
  swap(a.escape, b.escape);
  swap(a.line_delim, b.line_delim);
  swap(a.array_delim, b.array_delim);
  swap(a.array_begin, b.array_begin);
  swap(a.array_end, b.array_end);
  swap(a.threads, b.threads);
  swap(a.file_type, b.file_type);
  swap(a.s3_access_key, b.s3_access_key);
  swap(a.s3_secret_key, b.s3_secret_key);
  swap(a.s3_region, b.s3_region);
  swap(a.geo_coords_encoding, b.geo_coords_encoding);
  swap(a.geo_coords_comp_param, b.geo_coords_comp_param);
  swap(a.geo_coords_type, b.geo_coords_type);
  swap(a.geo_coords_srid, b.geo_coords_srid);
  swap(a.sanitize_column_names, b.sanitize_column_names);
  swap(a.geo_layer_name, b.geo_layer_name);
  swap(a.s3_endpoint, b.s3_endpoint);
  swap(a.__isset, b.__isset);
}

TCopyParams::TCopyParams(const TCopyParams& other107) {
  delimiter = other107.delimiter;
  null_str = other107.null_str;
  has_header = other107.has_header;
  quoted = other107.quoted;
  quote = other107.quote;
  escape = other107.escape;
  line_delim = other107.line_delim;
  array_delim = other107.array_delim;
  array_begin = other107.array_begin;
  array_end = other107.array_end;
  threads = other107.threads;
  file_type = other107.file_type;
  s3_access_key = other107.s3_access_key;
  s3_secret_key = other107.s3_secret_key;
  s3_region = other107.s3_region;
  geo_coords_encoding = other107.geo_coords_encoding;
  geo_coords_comp_param = other107.geo_coords_comp_param;
  geo_coords_type = other107.geo_coords_type;
  geo_coords_srid = other107.geo_coords_srid;
  sanitize_column_names = other107.sanitize_column_names;
  geo_layer_name = other107.geo_layer_name;
  s3_endpoint = other107.s3_endpoint;
  __isset = other107.__isset;
}
TCopyParams& TCopyParams::operator=(const TCopyParams& other108) {
  delimiter = other108.delimiter;
  null_str = other108.null_str;
  has_header = other108.has_header;
  quoted = other108.quoted;
  quote = other108.quote;
  escape = other108.escape;
  line_delim = other108.line_delim;
  array_delim = other108.array_delim;
  array_begin = other108.array_begin;
  array_end = other108.array_end;
  threads = other108.threads;
  file_type = other108.file_type;
  s3_access_key = other108.s3_access_key;
  s3_secret_key = other108.s3_secret_key;
  s3_region = other108.s3_region;
  geo_coords_encoding = other108.geo_coords_encoding;
  geo_coords_comp_param = other108.geo_coords_comp_param;
  geo_coords_type = other108.geo_coords_type;
  geo_coords_srid = other108.geo_coords_srid;
  sanitize_column_names = other108.sanitize_column_names;
  geo_layer_name = other108.geo_layer_name;
  s3_endpoint = other108.s3_endpoint;
  __isset = other108.__isset;
  return *this;
}
void TCopyParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCopyParams(";
  out << "delimiter=" << to_string(delimiter);
  out << ", " << "null_str=" << to_string(null_str);
  out << ", " << "has_header=" << to_string(has_header);
  out << ", " << "quoted=" << to_string(quoted);
  out << ", " << "quote=" << to_string(quote);
  out << ", " << "escape=" << to_string(escape);
  out << ", " << "line_delim=" << to_string(line_delim);
  out << ", " << "array_delim=" << to_string(array_delim);
  out << ", " << "array_begin=" << to_string(array_begin);
  out << ", " << "array_end=" << to_string(array_end);
  out << ", " << "threads=" << to_string(threads);
  out << ", " << "file_type=" << to_string(file_type);
  out << ", " << "s3_access_key=" << to_string(s3_access_key);
  out << ", " << "s3_secret_key=" << to_string(s3_secret_key);
  out << ", " << "s3_region=" << to_string(s3_region);
  out << ", " << "geo_coords_encoding=" << to_string(geo_coords_encoding);
  out << ", " << "geo_coords_comp_param=" << to_string(geo_coords_comp_param);
  out << ", " << "geo_coords_type=" << to_string(geo_coords_type);
  out << ", " << "geo_coords_srid=" << to_string(geo_coords_srid);
  out << ", " << "sanitize_column_names=" << to_string(sanitize_column_names);
  out << ", " << "geo_layer_name=" << to_string(geo_layer_name);
  out << ", " << "s3_endpoint=" << to_string(s3_endpoint);
  out << ")";
}


TCreateParams::~TCreateParams() throw() {
}


void TCreateParams::__set_is_replicated(const bool val) {
  this->is_replicated = val;
}
std::ostream& operator<<(std::ostream& out, const TCreateParams& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCreateParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_replicated);
          this->__isset.is_replicated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCreateParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCreateParams");

  xfer += oprot->writeFieldBegin("is_replicated", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_replicated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCreateParams &a, TCreateParams &b) {
  using ::std::swap;
  swap(a.is_replicated, b.is_replicated);
  swap(a.__isset, b.__isset);
}

TCreateParams::TCreateParams(const TCreateParams& other109) {
  is_replicated = other109.is_replicated;
  __isset = other109.__isset;
}
TCreateParams& TCreateParams::operator=(const TCreateParams& other110) {
  is_replicated = other110.is_replicated;
  __isset = other110.__isset;
  return *this;
}
void TCreateParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCreateParams(";
  out << "is_replicated=" << to_string(is_replicated);
  out << ")";
}


TDetectResult::~TDetectResult() throw() {
}


void TDetectResult::__set_row_set(const TRowSet& val) {
  this->row_set = val;
}

void TDetectResult::__set_copy_params(const TCopyParams& val) {
  this->copy_params = val;
}
std::ostream& operator<<(std::ostream& out, const TDetectResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDetectResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_set.read(iprot);
          this->__isset.row_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->copy_params.read(iprot);
          this->__isset.copy_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDetectResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDetectResult");

  xfer += oprot->writeFieldBegin("row_set", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->row_set.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("copy_params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->copy_params.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDetectResult &a, TDetectResult &b) {
  using ::std::swap;
  swap(a.row_set, b.row_set);
  swap(a.copy_params, b.copy_params);
  swap(a.__isset, b.__isset);
}

TDetectResult::TDetectResult(const TDetectResult& other111) {
  row_set = other111.row_set;
  copy_params = other111.copy_params;
  __isset = other111.__isset;
}
TDetectResult& TDetectResult::operator=(const TDetectResult& other112) {
  row_set = other112.row_set;
  copy_params = other112.copy_params;
  __isset = other112.__isset;
  return *this;
}
void TDetectResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDetectResult(";
  out << "row_set=" << to_string(row_set);
  out << ", " << "copy_params=" << to_string(copy_params);
  out << ")";
}


TImportStatus::~TImportStatus() throw() {
}


void TImportStatus::__set_elapsed(const int64_t val) {
  this->elapsed = val;
}

void TImportStatus::__set_rows_completed(const int64_t val) {
  this->rows_completed = val;
}

void TImportStatus::__set_rows_estimated(const int64_t val) {
  this->rows_estimated = val;
}

void TImportStatus::__set_rows_rejected(const int64_t val) {
  this->rows_rejected = val;
}
std::ostream& operator<<(std::ostream& out, const TImportStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TImportStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->elapsed);
          this->__isset.elapsed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows_completed);
          this->__isset.rows_completed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows_estimated);
          this->__isset.rows_estimated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows_rejected);
          this->__isset.rows_rejected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TImportStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TImportStatus");

  xfer += oprot->writeFieldBegin("elapsed", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->elapsed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows_completed", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->rows_completed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows_estimated", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->rows_estimated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows_rejected", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->rows_rejected);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TImportStatus &a, TImportStatus &b) {
  using ::std::swap;
  swap(a.elapsed, b.elapsed);
  swap(a.rows_completed, b.rows_completed);
  swap(a.rows_estimated, b.rows_estimated);
  swap(a.rows_rejected, b.rows_rejected);
  swap(a.__isset, b.__isset);
}

TImportStatus::TImportStatus(const TImportStatus& other113) {
  elapsed = other113.elapsed;
  rows_completed = other113.rows_completed;
  rows_estimated = other113.rows_estimated;
  rows_rejected = other113.rows_rejected;
  __isset = other113.__isset;
}
TImportStatus& TImportStatus::operator=(const TImportStatus& other114) {
  elapsed = other114.elapsed;
  rows_completed = other114.rows_completed;
  rows_estimated = other114.rows_estimated;
  rows_rejected = other114.rows_rejected;
  __isset = other114.__isset;
  return *this;
}
void TImportStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TImportStatus(";
  out << "elapsed=" << to_string(elapsed);
  out << ", " << "rows_completed=" << to_string(rows_completed);
  out << ", " << "rows_estimated=" << to_string(rows_estimated);
  out << ", " << "rows_rejected=" << to_string(rows_rejected);
  out << ")";
}


TFrontendView::~TFrontendView() throw() {
}


void TFrontendView::__set_view_name(const std::string& val) {
  this->view_name = val;
}

void TFrontendView::__set_view_state(const std::string& val) {
  this->view_state = val;
}

void TFrontendView::__set_image_hash(const std::string& val) {
  this->image_hash = val;
}

void TFrontendView::__set_update_time(const std::string& val) {
  this->update_time = val;
}

void TFrontendView::__set_view_metadata(const std::string& val) {
  this->view_metadata = val;
}
std::ostream& operator<<(std::ostream& out, const TFrontendView& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TFrontendView::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_name);
          this->__isset.view_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_state);
          this->__isset.view_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->image_hash);
          this->__isset.image_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->update_time);
          this->__isset.update_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_metadata);
          this->__isset.view_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TFrontendView::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFrontendView");

  xfer += oprot->writeFieldBegin("view_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->view_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_state", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->view_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("image_hash", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->image_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_time", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->update_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_metadata", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->view_metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFrontendView &a, TFrontendView &b) {
  using ::std::swap;
  swap(a.view_name, b.view_name);
  swap(a.view_state, b.view_state);
  swap(a.image_hash, b.image_hash);
  swap(a.update_time, b.update_time);
  swap(a.view_metadata, b.view_metadata);
  swap(a.__isset, b.__isset);
}

TFrontendView::TFrontendView(const TFrontendView& other115) {
  view_name = other115.view_name;
  view_state = other115.view_state;
  image_hash = other115.image_hash;
  update_time = other115.update_time;
  view_metadata = other115.view_metadata;
  __isset = other115.__isset;
}
TFrontendView& TFrontendView::operator=(const TFrontendView& other116) {
  view_name = other116.view_name;
  view_state = other116.view_state;
  image_hash = other116.image_hash;
  update_time = other116.update_time;
  view_metadata = other116.view_metadata;
  __isset = other116.__isset;
  return *this;
}
void TFrontendView::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFrontendView(";
  out << "view_name=" << to_string(view_name);
  out << ", " << "view_state=" << to_string(view_state);
  out << ", " << "image_hash=" << to_string(image_hash);
  out << ", " << "update_time=" << to_string(update_time);
  out << ", " << "view_metadata=" << to_string(view_metadata);
  out << ")";
}


TDashboard::~TDashboard() throw() {
}


void TDashboard::__set_dashboard_name(const std::string& val) {
  this->dashboard_name = val;
}

void TDashboard::__set_dashboard_state(const std::string& val) {
  this->dashboard_state = val;
}

void TDashboard::__set_image_hash(const std::string& val) {
  this->image_hash = val;
}

void TDashboard::__set_update_time(const std::string& val) {
  this->update_time = val;
}

void TDashboard::__set_dashboard_metadata(const std::string& val) {
  this->dashboard_metadata = val;
}

void TDashboard::__set_dashboard_id(const int32_t val) {
  this->dashboard_id = val;
}

void TDashboard::__set_dashboard_owner(const std::string& val) {
  this->dashboard_owner = val;
}

void TDashboard::__set_is_dash_shared(const bool val) {
  this->is_dash_shared = val;
}
std::ostream& operator<<(std::ostream& out, const TDashboard& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDashboard::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_name);
          this->__isset.dashboard_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_state);
          this->__isset.dashboard_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->image_hash);
          this->__isset.image_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->update_time);
          this->__isset.update_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_metadata);
          this->__isset.dashboard_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dashboard_id);
          this->__isset.dashboard_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_owner);
          this->__isset.dashboard_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_dash_shared);
          this->__isset.is_dash_shared = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDashboard::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDashboard");

  xfer += oprot->writeFieldBegin("dashboard_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dashboard_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_state", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dashboard_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("image_hash", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->image_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_time", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->update_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_metadata", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->dashboard_metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_id", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->dashboard_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_owner", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->dashboard_owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_dash_shared", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->is_dash_shared);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDashboard &a, TDashboard &b) {
  using ::std::swap;
  swap(a.dashboard_name, b.dashboard_name);
  swap(a.dashboard_state, b.dashboard_state);
  swap(a.image_hash, b.image_hash);
  swap(a.update_time, b.update_time);
  swap(a.dashboard_metadata, b.dashboard_metadata);
  swap(a.dashboard_id, b.dashboard_id);
  swap(a.dashboard_owner, b.dashboard_owner);
  swap(a.is_dash_shared, b.is_dash_shared);
  swap(a.__isset, b.__isset);
}

TDashboard::TDashboard(const TDashboard& other117) {
  dashboard_name = other117.dashboard_name;
  dashboard_state = other117.dashboard_state;
  image_hash = other117.image_hash;
  update_time = other117.update_time;
  dashboard_metadata = other117.dashboard_metadata;
  dashboard_id = other117.dashboard_id;
  dashboard_owner = other117.dashboard_owner;
  is_dash_shared = other117.is_dash_shared;
  __isset = other117.__isset;
}
TDashboard& TDashboard::operator=(const TDashboard& other118) {
  dashboard_name = other118.dashboard_name;
  dashboard_state = other118.dashboard_state;
  image_hash = other118.image_hash;
  update_time = other118.update_time;
  dashboard_metadata = other118.dashboard_metadata;
  dashboard_id = other118.dashboard_id;
  dashboard_owner = other118.dashboard_owner;
  is_dash_shared = other118.is_dash_shared;
  __isset = other118.__isset;
  return *this;
}
void TDashboard::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDashboard(";
  out << "dashboard_name=" << to_string(dashboard_name);
  out << ", " << "dashboard_state=" << to_string(dashboard_state);
  out << ", " << "image_hash=" << to_string(image_hash);
  out << ", " << "update_time=" << to_string(update_time);
  out << ", " << "dashboard_metadata=" << to_string(dashboard_metadata);
  out << ", " << "dashboard_id=" << to_string(dashboard_id);
  out << ", " << "dashboard_owner=" << to_string(dashboard_owner);
  out << ", " << "is_dash_shared=" << to_string(is_dash_shared);
  out << ")";
}


TServerStatus::~TServerStatus() throw() {
}


void TServerStatus::__set_read_only(const bool val) {
  this->read_only = val;
}

void TServerStatus::__set_version(const std::string& val) {
  this->version = val;
}

void TServerStatus::__set_rendering_enabled(const bool val) {
  this->rendering_enabled = val;
}

void TServerStatus::__set_start_time(const int64_t val) {
  this->start_time = val;
}

void TServerStatus::__set_edition(const std::string& val) {
  this->edition = val;
}

void TServerStatus::__set_host_name(const std::string& val) {
  this->host_name = val;
}

void TServerStatus::__set_poly_rendering_enabled(const bool val) {
  this->poly_rendering_enabled = val;
}

void TServerStatus::__set_role(const TRole::type val) {
  this->role = val;
}
std::ostream& operator<<(std::ostream& out, const TServerStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TServerStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->read_only);
          this->__isset.read_only = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rendering_enabled);
          this->__isset.rendering_enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_time);
          this->__isset.start_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->edition);
          this->__isset.edition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->poly_rendering_enabled);
          this->__isset.poly_rendering_enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast119;
          xfer += iprot->readI32(ecast119);
          this->role = (TRole::type)ecast119;
          this->__isset.role = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TServerStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TServerStatus");

  xfer += oprot->writeFieldBegin("read_only", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->read_only);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rendering_enabled", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->rendering_enabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_time", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->start_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("edition", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->edition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->host_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("poly_rendering_enabled", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->poly_rendering_enabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("role", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32((int32_t)this->role);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TServerStatus &a, TServerStatus &b) {
  using ::std::swap;
  swap(a.read_only, b.read_only);
  swap(a.version, b.version);
  swap(a.rendering_enabled, b.rendering_enabled);
  swap(a.start_time, b.start_time);
  swap(a.edition, b.edition);
  swap(a.host_name, b.host_name);
  swap(a.poly_rendering_enabled, b.poly_rendering_enabled);
  swap(a.role, b.role);
  swap(a.__isset, b.__isset);
}

TServerStatus::TServerStatus(const TServerStatus& other120) {
  read_only = other120.read_only;
  version = other120.version;
  rendering_enabled = other120.rendering_enabled;
  start_time = other120.start_time;
  edition = other120.edition;
  host_name = other120.host_name;
  poly_rendering_enabled = other120.poly_rendering_enabled;
  role = other120.role;
  __isset = other120.__isset;
}
TServerStatus& TServerStatus::operator=(const TServerStatus& other121) {
  read_only = other121.read_only;
  version = other121.version;
  rendering_enabled = other121.rendering_enabled;
  start_time = other121.start_time;
  edition = other121.edition;
  host_name = other121.host_name;
  poly_rendering_enabled = other121.poly_rendering_enabled;
  role = other121.role;
  __isset = other121.__isset;
  return *this;
}
void TServerStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TServerStatus(";
  out << "read_only=" << to_string(read_only);
  out << ", " << "version=" << to_string(version);
  out << ", " << "rendering_enabled=" << to_string(rendering_enabled);
  out << ", " << "start_time=" << to_string(start_time);
  out << ", " << "edition=" << to_string(edition);
  out << ", " << "host_name=" << to_string(host_name);
  out << ", " << "poly_rendering_enabled=" << to_string(poly_rendering_enabled);
  out << ", " << "role=" << to_string(role);
  out << ")";
}


TPixel::~TPixel() throw() {
}


void TPixel::__set_x(const int64_t val) {
  this->x = val;
}

void TPixel::__set_y(const int64_t val) {
  this->y = val;
}
std::ostream& operator<<(std::ostream& out, const TPixel& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPixel::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPixel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPixel");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPixel &a, TPixel &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.__isset, b.__isset);
}

TPixel::TPixel(const TPixel& other122) {
  x = other122.x;
  y = other122.y;
  __isset = other122.__isset;
}
TPixel& TPixel::operator=(const TPixel& other123) {
  x = other123.x;
  y = other123.y;
  __isset = other123.__isset;
  return *this;
}
void TPixel::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPixel(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ")";
}


TPixelTableRowResult::~TPixelTableRowResult() throw() {
}


void TPixelTableRowResult::__set_pixel(const TPixel& val) {
  this->pixel = val;
}

void TPixelTableRowResult::__set_vega_table_name(const std::string& val) {
  this->vega_table_name = val;
}

void TPixelTableRowResult::__set_table_id(const std::vector<int64_t> & val) {
  this->table_id = val;
}

void TPixelTableRowResult::__set_row_id(const std::vector<int64_t> & val) {
  this->row_id = val;
}

void TPixelTableRowResult::__set_row_set(const TRowSet& val) {
  this->row_set = val;
}

void TPixelTableRowResult::__set_nonce(const std::string& val) {
  this->nonce = val;
}
std::ostream& operator<<(std::ostream& out, const TPixelTableRowResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPixelTableRowResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pixel.read(iprot);
          this->__isset.pixel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vega_table_name);
          this->__isset.vega_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->table_id.clear();
            uint32_t _size124;
            ::apache::thrift::protocol::TType _etype127;
            xfer += iprot->readListBegin(_etype127, _size124);
            this->table_id.resize(_size124);
            uint32_t _i128;
            for (_i128 = 0; _i128 < _size124; ++_i128)
            {
              xfer += iprot->readI64(this->table_id[_i128]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_id.clear();
            uint32_t _size129;
            ::apache::thrift::protocol::TType _etype132;
            xfer += iprot->readListBegin(_etype132, _size129);
            this->row_id.resize(_size129);
            uint32_t _i133;
            for (_i133 = 0; _i133 < _size129; ++_i133)
            {
              xfer += iprot->readI64(this->row_id[_i133]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_set.read(iprot);
          this->__isset.row_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          this->__isset.nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPixelTableRowResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPixelTableRowResult");

  xfer += oprot->writeFieldBegin("pixel", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pixel.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vega_table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->vega_table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->table_id.size()));
    std::vector<int64_t> ::const_iterator _iter134;
    for (_iter134 = this->table_id.begin(); _iter134 != this->table_id.end(); ++_iter134)
    {
      xfer += oprot->writeI64((*_iter134));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_id", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->row_id.size()));
    std::vector<int64_t> ::const_iterator _iter135;
    for (_iter135 = this->row_id.begin(); _iter135 != this->row_id.end(); ++_iter135)
    {
      xfer += oprot->writeI64((*_iter135));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_set", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->row_set.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPixelTableRowResult &a, TPixelTableRowResult &b) {
  using ::std::swap;
  swap(a.pixel, b.pixel);
  swap(a.vega_table_name, b.vega_table_name);
  swap(a.table_id, b.table_id);
  swap(a.row_id, b.row_id);
  swap(a.row_set, b.row_set);
  swap(a.nonce, b.nonce);
  swap(a.__isset, b.__isset);
}

TPixelTableRowResult::TPixelTableRowResult(const TPixelTableRowResult& other136) {
  pixel = other136.pixel;
  vega_table_name = other136.vega_table_name;
  table_id = other136.table_id;
  row_id = other136.row_id;
  row_set = other136.row_set;
  nonce = other136.nonce;
  __isset = other136.__isset;
}
TPixelTableRowResult& TPixelTableRowResult::operator=(const TPixelTableRowResult& other137) {
  pixel = other137.pixel;
  vega_table_name = other137.vega_table_name;
  table_id = other137.table_id;
  row_id = other137.row_id;
  row_set = other137.row_set;
  nonce = other137.nonce;
  __isset = other137.__isset;
  return *this;
}
void TPixelTableRowResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPixelTableRowResult(";
  out << "pixel=" << to_string(pixel);
  out << ", " << "vega_table_name=" << to_string(vega_table_name);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "row_id=" << to_string(row_id);
  out << ", " << "row_set=" << to_string(row_set);
  out << ", " << "nonce=" << to_string(nonce);
  out << ")";
}


TRenderResult::~TRenderResult() throw() {
}


void TRenderResult::__set_image(const std::string& val) {
  this->image = val;
}

void TRenderResult::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void TRenderResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TRenderResult::__set_render_time_ms(const int64_t val) {
  this->render_time_ms = val;
}

void TRenderResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}

void TRenderResult::__set_vega_metadata(const std::string& val) {
  this->vega_metadata = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->image);
          this->__isset.image = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          this->__isset.nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->render_time_ms);
          this->__isset.render_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vega_metadata);
          this->__isset.vega_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderResult");

  xfer += oprot->writeFieldBegin("image", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->image);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_time_ms", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->render_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vega_metadata", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->vega_metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderResult &a, TRenderResult &b) {
  using ::std::swap;
  swap(a.image, b.image);
  swap(a.nonce, b.nonce);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.render_time_ms, b.render_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.vega_metadata, b.vega_metadata);
  swap(a.__isset, b.__isset);
}

TRenderResult::TRenderResult(const TRenderResult& other138) {
  image = other138.image;
  nonce = other138.nonce;
  execution_time_ms = other138.execution_time_ms;
  render_time_ms = other138.render_time_ms;
  total_time_ms = other138.total_time_ms;
  vega_metadata = other138.vega_metadata;
  __isset = other138.__isset;
}
TRenderResult& TRenderResult::operator=(const TRenderResult& other139) {
  image = other139.image;
  nonce = other139.nonce;
  execution_time_ms = other139.execution_time_ms;
  render_time_ms = other139.render_time_ms;
  total_time_ms = other139.total_time_ms;
  vega_metadata = other139.vega_metadata;
  __isset = other139.__isset;
  return *this;
}
void TRenderResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderResult(";
  out << "image=" << to_string(image);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "render_time_ms=" << to_string(render_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ", " << "vega_metadata=" << to_string(vega_metadata);
  out << ")";
}


TGpuSpecification::~TGpuSpecification() throw() {
}


void TGpuSpecification::__set_num_sm(const int32_t val) {
  this->num_sm = val;
}

void TGpuSpecification::__set_clock_frequency_kHz(const int64_t val) {
  this->clock_frequency_kHz = val;
}

void TGpuSpecification::__set_memory(const int64_t val) {
  this->memory = val;
}

void TGpuSpecification::__set_compute_capability_major(const int16_t val) {
  this->compute_capability_major = val;
}

void TGpuSpecification::__set_compute_capability_minor(const int16_t val) {
  this->compute_capability_minor = val;
}
std::ostream& operator<<(std::ostream& out, const TGpuSpecification& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGpuSpecification::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_sm);
          this->__isset.num_sm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->clock_frequency_kHz);
          this->__isset.clock_frequency_kHz = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->memory);
          this->__isset.memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->compute_capability_major);
          this->__isset.compute_capability_major = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->compute_capability_minor);
          this->__isset.compute_capability_minor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGpuSpecification::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGpuSpecification");

  xfer += oprot->writeFieldBegin("num_sm", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num_sm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("clock_frequency_kHz", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->clock_frequency_kHz);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("memory", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->memory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compute_capability_major", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->compute_capability_major);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compute_capability_minor", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->compute_capability_minor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGpuSpecification &a, TGpuSpecification &b) {
  using ::std::swap;
  swap(a.num_sm, b.num_sm);
  swap(a.clock_frequency_kHz, b.clock_frequency_kHz);
  swap(a.memory, b.memory);
  swap(a.compute_capability_major, b.compute_capability_major);
  swap(a.compute_capability_minor, b.compute_capability_minor);
  swap(a.__isset, b.__isset);
}

TGpuSpecification::TGpuSpecification(const TGpuSpecification& other140) {
  num_sm = other140.num_sm;
  clock_frequency_kHz = other140.clock_frequency_kHz;
  memory = other140.memory;
  compute_capability_major = other140.compute_capability_major;
  compute_capability_minor = other140.compute_capability_minor;
  __isset = other140.__isset;
}
TGpuSpecification& TGpuSpecification::operator=(const TGpuSpecification& other141) {
  num_sm = other141.num_sm;
  clock_frequency_kHz = other141.clock_frequency_kHz;
  memory = other141.memory;
  compute_capability_major = other141.compute_capability_major;
  compute_capability_minor = other141.compute_capability_minor;
  __isset = other141.__isset;
  return *this;
}
void TGpuSpecification::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGpuSpecification(";
  out << "num_sm=" << to_string(num_sm);
  out << ", " << "clock_frequency_kHz=" << to_string(clock_frequency_kHz);
  out << ", " << "memory=" << to_string(memory);
  out << ", " << "compute_capability_major=" << to_string(compute_capability_major);
  out << ", " << "compute_capability_minor=" << to_string(compute_capability_minor);
  out << ")";
}


THardwareInfo::~THardwareInfo() throw() {
}


void THardwareInfo::__set_num_gpu_hw(const int16_t val) {
  this->num_gpu_hw = val;
}

void THardwareInfo::__set_num_cpu_hw(const int16_t val) {
  this->num_cpu_hw = val;
}

void THardwareInfo::__set_num_gpu_allocated(const int16_t val) {
  this->num_gpu_allocated = val;
}

void THardwareInfo::__set_start_gpu(const int16_t val) {
  this->start_gpu = val;
}

void THardwareInfo::__set_host_name(const std::string& val) {
  this->host_name = val;
}

void THardwareInfo::__set_gpu_info(const std::vector<TGpuSpecification> & val) {
  this->gpu_info = val;
}
std::ostream& operator<<(std::ostream& out, const THardwareInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t THardwareInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->num_gpu_hw);
          this->__isset.num_gpu_hw = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->num_cpu_hw);
          this->__isset.num_cpu_hw = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->num_gpu_allocated);
          this->__isset.num_gpu_allocated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->start_gpu);
          this->__isset.start_gpu = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->gpu_info.clear();
            uint32_t _size142;
            ::apache::thrift::protocol::TType _etype145;
            xfer += iprot->readListBegin(_etype145, _size142);
            this->gpu_info.resize(_size142);
            uint32_t _i146;
            for (_i146 = 0; _i146 < _size142; ++_i146)
            {
              xfer += this->gpu_info[_i146].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.gpu_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t THardwareInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THardwareInfo");

  xfer += oprot->writeFieldBegin("num_gpu_hw", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->num_gpu_hw);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_cpu_hw", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->num_cpu_hw);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_gpu_allocated", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->num_gpu_allocated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_gpu", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->start_gpu);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->host_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gpu_info", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->gpu_info.size()));
    std::vector<TGpuSpecification> ::const_iterator _iter147;
    for (_iter147 = this->gpu_info.begin(); _iter147 != this->gpu_info.end(); ++_iter147)
    {
      xfer += (*_iter147).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THardwareInfo &a, THardwareInfo &b) {
  using ::std::swap;
  swap(a.num_gpu_hw, b.num_gpu_hw);
  swap(a.num_cpu_hw, b.num_cpu_hw);
  swap(a.num_gpu_allocated, b.num_gpu_allocated);
  swap(a.start_gpu, b.start_gpu);
  swap(a.host_name, b.host_name);
  swap(a.gpu_info, b.gpu_info);
  swap(a.__isset, b.__isset);
}

THardwareInfo::THardwareInfo(const THardwareInfo& other148) {
  num_gpu_hw = other148.num_gpu_hw;
  num_cpu_hw = other148.num_cpu_hw;
  num_gpu_allocated = other148.num_gpu_allocated;
  start_gpu = other148.start_gpu;
  host_name = other148.host_name;
  gpu_info = other148.gpu_info;
  __isset = other148.__isset;
}
THardwareInfo& THardwareInfo::operator=(const THardwareInfo& other149) {
  num_gpu_hw = other149.num_gpu_hw;
  num_cpu_hw = other149.num_cpu_hw;
  num_gpu_allocated = other149.num_gpu_allocated;
  start_gpu = other149.start_gpu;
  host_name = other149.host_name;
  gpu_info = other149.gpu_info;
  __isset = other149.__isset;
  return *this;
}
void THardwareInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THardwareInfo(";
  out << "num_gpu_hw=" << to_string(num_gpu_hw);
  out << ", " << "num_cpu_hw=" << to_string(num_cpu_hw);
  out << ", " << "num_gpu_allocated=" << to_string(num_gpu_allocated);
  out << ", " << "start_gpu=" << to_string(start_gpu);
  out << ", " << "host_name=" << to_string(host_name);
  out << ", " << "gpu_info=" << to_string(gpu_info);
  out << ")";
}


TClusterHardwareInfo::~TClusterHardwareInfo() throw() {
}


void TClusterHardwareInfo::__set_hardware_info(const std::vector<THardwareInfo> & val) {
  this->hardware_info = val;
}
std::ostream& operator<<(std::ostream& out, const TClusterHardwareInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TClusterHardwareInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->hardware_info.clear();
            uint32_t _size150;
            ::apache::thrift::protocol::TType _etype153;
            xfer += iprot->readListBegin(_etype153, _size150);
            this->hardware_info.resize(_size150);
            uint32_t _i154;
            for (_i154 = 0; _i154 < _size150; ++_i154)
            {
              xfer += this->hardware_info[_i154].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.hardware_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TClusterHardwareInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TClusterHardwareInfo");

  xfer += oprot->writeFieldBegin("hardware_info", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->hardware_info.size()));
    std::vector<THardwareInfo> ::const_iterator _iter155;
    for (_iter155 = this->hardware_info.begin(); _iter155 != this->hardware_info.end(); ++_iter155)
    {
      xfer += (*_iter155).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TClusterHardwareInfo &a, TClusterHardwareInfo &b) {
  using ::std::swap;
  swap(a.hardware_info, b.hardware_info);
  swap(a.__isset, b.__isset);
}

TClusterHardwareInfo::TClusterHardwareInfo(const TClusterHardwareInfo& other156) {
  hardware_info = other156.hardware_info;
  __isset = other156.__isset;
}
TClusterHardwareInfo& TClusterHardwareInfo::operator=(const TClusterHardwareInfo& other157) {
  hardware_info = other157.hardware_info;
  __isset = other157.__isset;
  return *this;
}
void TClusterHardwareInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TClusterHardwareInfo(";
  out << "hardware_info=" << to_string(hardware_info);
  out << ")";
}


TMemoryData::~TMemoryData() throw() {
}


void TMemoryData::__set_slab(const int64_t val) {
  this->slab = val;
}

void TMemoryData::__set_start_page(const int32_t val) {
  this->start_page = val;
}

void TMemoryData::__set_num_pages(const int64_t val) {
  this->num_pages = val;
}

void TMemoryData::__set_touch(const int32_t val) {
  this->touch = val;
}

void TMemoryData::__set_chunk_key(const std::vector<int64_t> & val) {
  this->chunk_key = val;
}

void TMemoryData::__set_buffer_epoch(const int32_t val) {
  this->buffer_epoch = val;
}

void TMemoryData::__set_is_free(const bool val) {
  this->is_free = val;
}
std::ostream& operator<<(std::ostream& out, const TMemoryData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TMemoryData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->slab);
          this->__isset.slab = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->start_page);
          this->__isset.start_page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_pages);
          this->__isset.num_pages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->touch);
          this->__isset.touch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->chunk_key.clear();
            uint32_t _size158;
            ::apache::thrift::protocol::TType _etype161;
            xfer += iprot->readListBegin(_etype161, _size158);
            this->chunk_key.resize(_size158);
            uint32_t _i162;
            for (_i162 = 0; _i162 < _size158; ++_i162)
            {
              xfer += iprot->readI64(this->chunk_key[_i162]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.chunk_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->buffer_epoch);
          this->__isset.buffer_epoch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_free);
          this->__isset.is_free = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMemoryData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMemoryData");

  xfer += oprot->writeFieldBegin("slab", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->slab);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_page", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->start_page);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_pages", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->num_pages);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("touch", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->touch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("chunk_key", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->chunk_key.size()));
    std::vector<int64_t> ::const_iterator _iter163;
    for (_iter163 = this->chunk_key.begin(); _iter163 != this->chunk_key.end(); ++_iter163)
    {
      xfer += oprot->writeI64((*_iter163));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("buffer_epoch", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->buffer_epoch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_free", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->is_free);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMemoryData &a, TMemoryData &b) {
  using ::std::swap;
  swap(a.slab, b.slab);
  swap(a.start_page, b.start_page);
  swap(a.num_pages, b.num_pages);
  swap(a.touch, b.touch);
  swap(a.chunk_key, b.chunk_key);
  swap(a.buffer_epoch, b.buffer_epoch);
  swap(a.is_free, b.is_free);
  swap(a.__isset, b.__isset);
}

TMemoryData::TMemoryData(const TMemoryData& other164) {
  slab = other164.slab;
  start_page = other164.start_page;
  num_pages = other164.num_pages;
  touch = other164.touch;
  chunk_key = other164.chunk_key;
  buffer_epoch = other164.buffer_epoch;
  is_free = other164.is_free;
  __isset = other164.__isset;
}
TMemoryData& TMemoryData::operator=(const TMemoryData& other165) {
  slab = other165.slab;
  start_page = other165.start_page;
  num_pages = other165.num_pages;
  touch = other165.touch;
  chunk_key = other165.chunk_key;
  buffer_epoch = other165.buffer_epoch;
  is_free = other165.is_free;
  __isset = other165.__isset;
  return *this;
}
void TMemoryData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMemoryData(";
  out << "slab=" << to_string(slab);
  out << ", " << "start_page=" << to_string(start_page);
  out << ", " << "num_pages=" << to_string(num_pages);
  out << ", " << "touch=" << to_string(touch);
  out << ", " << "chunk_key=" << to_string(chunk_key);
  out << ", " << "buffer_epoch=" << to_string(buffer_epoch);
  out << ", " << "is_free=" << to_string(is_free);
  out << ")";
}


TNodeMemoryInfo::~TNodeMemoryInfo() throw() {
}


void TNodeMemoryInfo::__set_host_name(const std::string& val) {
  this->host_name = val;
}

void TNodeMemoryInfo::__set_page_size(const int64_t val) {
  this->page_size = val;
}

void TNodeMemoryInfo::__set_max_num_pages(const int64_t val) {
  this->max_num_pages = val;
}

void TNodeMemoryInfo::__set_num_pages_allocated(const int64_t val) {
  this->num_pages_allocated = val;
}

void TNodeMemoryInfo::__set_is_allocation_capped(const bool val) {
  this->is_allocation_capped = val;
}

void TNodeMemoryInfo::__set_node_memory_data(const std::vector<TMemoryData> & val) {
  this->node_memory_data = val;
}
std::ostream& operator<<(std::ostream& out, const TNodeMemoryInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TNodeMemoryInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->page_size);
          this->__isset.page_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_num_pages);
          this->__isset.max_num_pages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_pages_allocated);
          this->__isset.num_pages_allocated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_allocation_capped);
          this->__isset.is_allocation_capped = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->node_memory_data.clear();
            uint32_t _size166;
            ::apache::thrift::protocol::TType _etype169;
            xfer += iprot->readListBegin(_etype169, _size166);
            this->node_memory_data.resize(_size166);
            uint32_t _i170;
            for (_i170 = 0; _i170 < _size166; ++_i170)
            {
              xfer += this->node_memory_data[_i170].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.node_memory_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TNodeMemoryInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TNodeMemoryInfo");

  xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("page_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->page_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_num_pages", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->max_num_pages);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_pages_allocated", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->num_pages_allocated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_allocation_capped", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_allocation_capped);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_memory_data", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->node_memory_data.size()));
    std::vector<TMemoryData> ::const_iterator _iter171;
    for (_iter171 = this->node_memory_data.begin(); _iter171 != this->node_memory_data.end(); ++_iter171)
    {
      xfer += (*_iter171).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TNodeMemoryInfo &a, TNodeMemoryInfo &b) {
  using ::std::swap;
  swap(a.host_name, b.host_name);
  swap(a.page_size, b.page_size);
  swap(a.max_num_pages, b.max_num_pages);
  swap(a.num_pages_allocated, b.num_pages_allocated);
  swap(a.is_allocation_capped, b.is_allocation_capped);
  swap(a.node_memory_data, b.node_memory_data);
  swap(a.__isset, b.__isset);
}

TNodeMemoryInfo::TNodeMemoryInfo(const TNodeMemoryInfo& other172) {
  host_name = other172.host_name;
  page_size = other172.page_size;
  max_num_pages = other172.max_num_pages;
  num_pages_allocated = other172.num_pages_allocated;
  is_allocation_capped = other172.is_allocation_capped;
  node_memory_data = other172.node_memory_data;
  __isset = other172.__isset;
}
TNodeMemoryInfo& TNodeMemoryInfo::operator=(const TNodeMemoryInfo& other173) {
  host_name = other173.host_name;
  page_size = other173.page_size;
  max_num_pages = other173.max_num_pages;
  num_pages_allocated = other173.num_pages_allocated;
  is_allocation_capped = other173.is_allocation_capped;
  node_memory_data = other173.node_memory_data;
  __isset = other173.__isset;
  return *this;
}
void TNodeMemoryInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TNodeMemoryInfo(";
  out << "host_name=" << to_string(host_name);
  out << ", " << "page_size=" << to_string(page_size);
  out << ", " << "max_num_pages=" << to_string(max_num_pages);
  out << ", " << "num_pages_allocated=" << to_string(num_pages_allocated);
  out << ", " << "is_allocation_capped=" << to_string(is_allocation_capped);
  out << ", " << "node_memory_data=" << to_string(node_memory_data);
  out << ")";
}


TTableMeta::~TTableMeta() throw() {
}


void TTableMeta::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void TTableMeta::__set_num_cols(const int64_t val) {
  this->num_cols = val;
}

void TTableMeta::__set_is_view(const bool val) {
  this->is_view = val;
}

void TTableMeta::__set_is_replicated(const bool val) {
  this->is_replicated = val;
}

void TTableMeta::__set_shard_count(const int64_t val) {
  this->shard_count = val;
}

void TTableMeta::__set_max_rows(const int64_t val) {
  this->max_rows = val;
}

void TTableMeta::__set_table_id(const int64_t val) {
  this->table_id = val;
}

void TTableMeta::__set_max_table_id(const int64_t val) {
  this->max_table_id = val;
}

void TTableMeta::__set_col_types(const std::vector< ::TTypeInfo> & val) {
  this->col_types = val;
}

void TTableMeta::__set_col_names(const std::vector<std::string> & val) {
  this->col_names = val;
}
std::ostream& operator<<(std::ostream& out, const TTableMeta& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableMeta::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_cols);
          this->__isset.num_cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_view);
          this->__isset.is_view = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_replicated);
          this->__isset.is_replicated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->shard_count);
          this->__isset.shard_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_rows);
          this->__isset.max_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_table_id);
          this->__isset.max_table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->col_types.clear();
            uint32_t _size174;
            ::apache::thrift::protocol::TType _etype177;
            xfer += iprot->readListBegin(_etype177, _size174);
            this->col_types.resize(_size174);
            uint32_t _i178;
            for (_i178 = 0; _i178 < _size174; ++_i178)
            {
              xfer += this->col_types[_i178].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.col_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->col_names.clear();
            uint32_t _size179;
            ::apache::thrift::protocol::TType _etype182;
            xfer += iprot->readListBegin(_etype182, _size179);
            this->col_names.resize(_size179);
            uint32_t _i183;
            for (_i183 = 0; _i183 < _size179; ++_i183)
            {
              xfer += iprot->readString(this->col_names[_i183]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.col_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableMeta::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableMeta");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_cols", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->num_cols);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_view", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_view);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_replicated", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_replicated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shard_count", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->shard_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_rows", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->max_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_table_id", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->max_table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_types", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->col_types.size()));
    std::vector< ::TTypeInfo> ::const_iterator _iter184;
    for (_iter184 = this->col_types.begin(); _iter184 != this->col_types.end(); ++_iter184)
    {
      xfer += (*_iter184).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_names", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->col_names.size()));
    std::vector<std::string> ::const_iterator _iter185;
    for (_iter185 = this->col_names.begin(); _iter185 != this->col_names.end(); ++_iter185)
    {
      xfer += oprot->writeString((*_iter185));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableMeta &a, TTableMeta &b) {
  using ::std::swap;
  swap(a.table_name, b.table_name);
  swap(a.num_cols, b.num_cols);
  swap(a.is_view, b.is_view);
  swap(a.is_replicated, b.is_replicated);
  swap(a.shard_count, b.shard_count);
  swap(a.max_rows, b.max_rows);
  swap(a.table_id, b.table_id);
  swap(a.max_table_id, b.max_table_id);
  swap(a.col_types, b.col_types);
  swap(a.col_names, b.col_names);
  swap(a.__isset, b.__isset);
}

TTableMeta::TTableMeta(const TTableMeta& other186) {
  table_name = other186.table_name;
  num_cols = other186.num_cols;
  is_view = other186.is_view;
  is_replicated = other186.is_replicated;
  shard_count = other186.shard_count;
  max_rows = other186.max_rows;
  table_id = other186.table_id;
  max_table_id = other186.max_table_id;
  col_types = other186.col_types;
  col_names = other186.col_names;
  __isset = other186.__isset;
}
TTableMeta& TTableMeta::operator=(const TTableMeta& other187) {
  table_name = other187.table_name;
  num_cols = other187.num_cols;
  is_view = other187.is_view;
  is_replicated = other187.is_replicated;
  shard_count = other187.shard_count;
  max_rows = other187.max_rows;
  table_id = other187.table_id;
  max_table_id = other187.max_table_id;
  col_types = other187.col_types;
  col_names = other187.col_names;
  __isset = other187.__isset;
  return *this;
}
void TTableMeta::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableMeta(";
  out << "table_name=" << to_string(table_name);
  out << ", " << "num_cols=" << to_string(num_cols);
  out << ", " << "is_view=" << to_string(is_view);
  out << ", " << "is_replicated=" << to_string(is_replicated);
  out << ", " << "shard_count=" << to_string(shard_count);
  out << ", " << "max_rows=" << to_string(max_rows);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "max_table_id=" << to_string(max_table_id);
  out << ", " << "col_types=" << to_string(col_types);
  out << ", " << "col_names=" << to_string(col_names);
  out << ")";
}


TTableDetails::~TTableDetails() throw() {
}


void TTableDetails::__set_row_desc(const TRowDescriptor& val) {
  this->row_desc = val;
}

void TTableDetails::__set_fragment_size(const int64_t val) {
  this->fragment_size = val;
}

void TTableDetails::__set_page_size(const int64_t val) {
  this->page_size = val;
}

void TTableDetails::__set_max_rows(const int64_t val) {
  this->max_rows = val;
}

void TTableDetails::__set_view_sql(const std::string& val) {
  this->view_sql = val;
}

void TTableDetails::__set_shard_count(const int64_t val) {
  this->shard_count = val;
}

void TTableDetails::__set_key_metainfo(const std::string& val) {
  this->key_metainfo = val;
}

void TTableDetails::__set_is_temporary(const bool val) {
  this->is_temporary = val;
}

void TTableDetails::__set_partition_detail(const TPartitionDetail::type val) {
  this->partition_detail = val;
}
std::ostream& operator<<(std::ostream& out, const TTableDetails& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableDetails::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_desc.clear();
            uint32_t _size188;
            ::apache::thrift::protocol::TType _etype191;
            xfer += iprot->readListBegin(_etype191, _size188);
            this->row_desc.resize(_size188);
            uint32_t _i192;
            for (_i192 = 0; _i192 < _size188; ++_i192)
            {
              xfer += this->row_desc[_i192].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->fragment_size);
          this->__isset.fragment_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->page_size);
          this->__isset.page_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_rows);
          this->__isset.max_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_sql);
          this->__isset.view_sql = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->shard_count);
          this->__isset.shard_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key_metainfo);
          this->__isset.key_metainfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_temporary);
          this->__isset.is_temporary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast193;
          xfer += iprot->readI32(ecast193);
          this->partition_detail = (TPartitionDetail::type)ecast193;
          this->__isset.partition_detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableDetails::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableDetails");

  xfer += oprot->writeFieldBegin("row_desc", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row_desc.size()));
    std::vector<TColumnType> ::const_iterator _iter194;
    for (_iter194 = this->row_desc.begin(); _iter194 != this->row_desc.end(); ++_iter194)
    {
      xfer += (*_iter194).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fragment_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->fragment_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("page_size", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->page_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_rows", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->max_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_sql", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->view_sql);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shard_count", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->shard_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_metainfo", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->key_metainfo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_temporary", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->is_temporary);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partition_detail", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32((int32_t)this->partition_detail);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableDetails &a, TTableDetails &b) {
  using ::std::swap;
  swap(a.row_desc, b.row_desc);
  swap(a.fragment_size, b.fragment_size);
  swap(a.page_size, b.page_size);
  swap(a.max_rows, b.max_rows);
  swap(a.view_sql, b.view_sql);
  swap(a.shard_count, b.shard_count);
  swap(a.key_metainfo, b.key_metainfo);
  swap(a.is_temporary, b.is_temporary);
  swap(a.partition_detail, b.partition_detail);
  swap(a.__isset, b.__isset);
}

TTableDetails::TTableDetails(const TTableDetails& other195) {
  row_desc = other195.row_desc;
  fragment_size = other195.fragment_size;
  page_size = other195.page_size;
  max_rows = other195.max_rows;
  view_sql = other195.view_sql;
  shard_count = other195.shard_count;
  key_metainfo = other195.key_metainfo;
  is_temporary = other195.is_temporary;
  partition_detail = other195.partition_detail;
  __isset = other195.__isset;
}
TTableDetails& TTableDetails::operator=(const TTableDetails& other196) {
  row_desc = other196.row_desc;
  fragment_size = other196.fragment_size;
  page_size = other196.page_size;
  max_rows = other196.max_rows;
  view_sql = other196.view_sql;
  shard_count = other196.shard_count;
  key_metainfo = other196.key_metainfo;
  is_temporary = other196.is_temporary;
  partition_detail = other196.partition_detail;
  __isset = other196.__isset;
  return *this;
}
void TTableDetails::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableDetails(";
  out << "row_desc=" << to_string(row_desc);
  out << ", " << "fragment_size=" << to_string(fragment_size);
  out << ", " << "page_size=" << to_string(page_size);
  out << ", " << "max_rows=" << to_string(max_rows);
  out << ", " << "view_sql=" << to_string(view_sql);
  out << ", " << "shard_count=" << to_string(shard_count);
  out << ", " << "key_metainfo=" << to_string(key_metainfo);
  out << ", " << "is_temporary=" << to_string(is_temporary);
  out << ", " << "partition_detail=" << to_string(partition_detail);
  out << ")";
}


TColumnRange::~TColumnRange() throw() {
}


void TColumnRange::__set_type(const TExpressionRangeType::type val) {
  this->type = val;
}

void TColumnRange::__set_col_id(const int32_t val) {
  this->col_id = val;
}

void TColumnRange::__set_table_id(const int32_t val) {
  this->table_id = val;
}

void TColumnRange::__set_has_nulls(const bool val) {
  this->has_nulls = val;
}

void TColumnRange::__set_int_min(const int64_t val) {
  this->int_min = val;
}

void TColumnRange::__set_int_max(const int64_t val) {
  this->int_max = val;
}

void TColumnRange::__set_bucket(const int64_t val) {
  this->bucket = val;
}

void TColumnRange::__set_fp_min(const double val) {
  this->fp_min = val;
}

void TColumnRange::__set_fp_max(const double val) {
  this->fp_max = val;
}
std::ostream& operator<<(std::ostream& out, const TColumnRange& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast197;
          xfer += iprot->readI32(ecast197);
          this->type = (TExpressionRangeType::type)ecast197;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->col_id);
          this->__isset.col_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_nulls);
          this->__isset.has_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->int_min);
          this->__isset.int_min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->int_max);
          this->__isset.int_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bucket);
          this->__isset.bucket = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fp_min);
          this->__isset.fp_min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fp_max);
          this->__isset.fp_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnRange");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->col_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_nulls", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->has_nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("int_min", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->int_min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("int_max", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->int_max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bucket", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->bucket);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fp_min", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->fp_min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fp_max", ::apache::thrift::protocol::T_DOUBLE, 9);
  xfer += oprot->writeDouble(this->fp_max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnRange &a, TColumnRange &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.col_id, b.col_id);
  swap(a.table_id, b.table_id);
  swap(a.has_nulls, b.has_nulls);
  swap(a.int_min, b.int_min);
  swap(a.int_max, b.int_max);
  swap(a.bucket, b.bucket);
  swap(a.fp_min, b.fp_min);
  swap(a.fp_max, b.fp_max);
  swap(a.__isset, b.__isset);
}

TColumnRange::TColumnRange(const TColumnRange& other198) {
  type = other198.type;
  col_id = other198.col_id;
  table_id = other198.table_id;
  has_nulls = other198.has_nulls;
  int_min = other198.int_min;
  int_max = other198.int_max;
  bucket = other198.bucket;
  fp_min = other198.fp_min;
  fp_max = other198.fp_max;
  __isset = other198.__isset;
}
TColumnRange& TColumnRange::operator=(const TColumnRange& other199) {
  type = other199.type;
  col_id = other199.col_id;
  table_id = other199.table_id;
  has_nulls = other199.has_nulls;
  int_min = other199.int_min;
  int_max = other199.int_max;
  bucket = other199.bucket;
  fp_min = other199.fp_min;
  fp_max = other199.fp_max;
  __isset = other199.__isset;
  return *this;
}
void TColumnRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnRange(";
  out << "type=" << to_string(type);
  out << ", " << "col_id=" << to_string(col_id);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "has_nulls=" << to_string(has_nulls);
  out << ", " << "int_min=" << to_string(int_min);
  out << ", " << "int_max=" << to_string(int_max);
  out << ", " << "bucket=" << to_string(bucket);
  out << ", " << "fp_min=" << to_string(fp_min);
  out << ", " << "fp_max=" << to_string(fp_max);
  out << ")";
}


TDictionaryGeneration::~TDictionaryGeneration() throw() {
}


void TDictionaryGeneration::__set_dict_id(const int32_t val) {
  this->dict_id = val;
}

void TDictionaryGeneration::__set_entry_count(const int64_t val) {
  this->entry_count = val;
}
std::ostream& operator<<(std::ostream& out, const TDictionaryGeneration& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDictionaryGeneration::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dict_id);
          this->__isset.dict_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->entry_count);
          this->__isset.entry_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDictionaryGeneration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDictionaryGeneration");

  xfer += oprot->writeFieldBegin("dict_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->dict_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entry_count", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->entry_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDictionaryGeneration &a, TDictionaryGeneration &b) {
  using ::std::swap;
  swap(a.dict_id, b.dict_id);
  swap(a.entry_count, b.entry_count);
  swap(a.__isset, b.__isset);
}

TDictionaryGeneration::TDictionaryGeneration(const TDictionaryGeneration& other200) {
  dict_id = other200.dict_id;
  entry_count = other200.entry_count;
  __isset = other200.__isset;
}
TDictionaryGeneration& TDictionaryGeneration::operator=(const TDictionaryGeneration& other201) {
  dict_id = other201.dict_id;
  entry_count = other201.entry_count;
  __isset = other201.__isset;
  return *this;
}
void TDictionaryGeneration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDictionaryGeneration(";
  out << "dict_id=" << to_string(dict_id);
  out << ", " << "entry_count=" << to_string(entry_count);
  out << ")";
}


TTableGeneration::~TTableGeneration() throw() {
}


void TTableGeneration::__set_table_id(const int32_t val) {
  this->table_id = val;
}

void TTableGeneration::__set_tuple_count(const int64_t val) {
  this->tuple_count = val;
}

void TTableGeneration::__set_start_rowid(const int64_t val) {
  this->start_rowid = val;
}
std::ostream& operator<<(std::ostream& out, const TTableGeneration& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableGeneration::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tuple_count);
          this->__isset.tuple_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_rowid);
          this->__isset.start_rowid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableGeneration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableGeneration");

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tuple_count", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->tuple_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_rowid", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->start_rowid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableGeneration &a, TTableGeneration &b) {
  using ::std::swap;
  swap(a.table_id, b.table_id);
  swap(a.tuple_count, b.tuple_count);
  swap(a.start_rowid, b.start_rowid);
  swap(a.__isset, b.__isset);
}

TTableGeneration::TTableGeneration(const TTableGeneration& other202) {
  table_id = other202.table_id;
  tuple_count = other202.tuple_count;
  start_rowid = other202.start_rowid;
  __isset = other202.__isset;
}
TTableGeneration& TTableGeneration::operator=(const TTableGeneration& other203) {
  table_id = other203.table_id;
  tuple_count = other203.tuple_count;
  start_rowid = other203.start_rowid;
  __isset = other203.__isset;
  return *this;
}
void TTableGeneration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableGeneration(";
  out << "table_id=" << to_string(table_id);
  out << ", " << "tuple_count=" << to_string(tuple_count);
  out << ", " << "start_rowid=" << to_string(start_rowid);
  out << ")";
}


TPendingQuery::~TPendingQuery() throw() {
}


void TPendingQuery::__set_id(const TQueryId val) {
  this->id = val;
}

void TPendingQuery::__set_column_ranges(const std::vector<TColumnRange> & val) {
  this->column_ranges = val;
}

void TPendingQuery::__set_dictionary_generations(const std::vector<TDictionaryGeneration> & val) {
  this->dictionary_generations = val;
}

void TPendingQuery::__set_table_generations(const std::vector<TTableGeneration> & val) {
  this->table_generations = val;
}
std::ostream& operator<<(std::ostream& out, const TPendingQuery& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPendingQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_ranges.clear();
            uint32_t _size204;
            ::apache::thrift::protocol::TType _etype207;
            xfer += iprot->readListBegin(_etype207, _size204);
            this->column_ranges.resize(_size204);
            uint32_t _i208;
            for (_i208 = 0; _i208 < _size204; ++_i208)
            {
              xfer += this->column_ranges[_i208].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dictionary_generations.clear();
            uint32_t _size209;
            ::apache::thrift::protocol::TType _etype212;
            xfer += iprot->readListBegin(_etype212, _size209);
            this->dictionary_generations.resize(_size209);
            uint32_t _i213;
            for (_i213 = 0; _i213 < _size209; ++_i213)
            {
              xfer += this->dictionary_generations[_i213].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dictionary_generations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->table_generations.clear();
            uint32_t _size214;
            ::apache::thrift::protocol::TType _etype217;
            xfer += iprot->readListBegin(_etype217, _size214);
            this->table_generations.resize(_size214);
            uint32_t _i218;
            for (_i218 = 0; _i218 < _size214; ++_i218)
            {
              xfer += this->table_generations[_i218].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.table_generations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPendingQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPendingQuery");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_ranges", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_ranges.size()));
    std::vector<TColumnRange> ::const_iterator _iter219;
    for (_iter219 = this->column_ranges.begin(); _iter219 != this->column_ranges.end(); ++_iter219)
    {
      xfer += (*_iter219).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dictionary_generations", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dictionary_generations.size()));
    std::vector<TDictionaryGeneration> ::const_iterator _iter220;
    for (_iter220 = this->dictionary_generations.begin(); _iter220 != this->dictionary_generations.end(); ++_iter220)
    {
      xfer += (*_iter220).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_generations", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->table_generations.size()));
    std::vector<TTableGeneration> ::const_iterator _iter221;
    for (_iter221 = this->table_generations.begin(); _iter221 != this->table_generations.end(); ++_iter221)
    {
      xfer += (*_iter221).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPendingQuery &a, TPendingQuery &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.column_ranges, b.column_ranges);
  swap(a.dictionary_generations, b.dictionary_generations);
  swap(a.table_generations, b.table_generations);
  swap(a.__isset, b.__isset);
}

TPendingQuery::TPendingQuery(const TPendingQuery& other222) {
  id = other222.id;
  column_ranges = other222.column_ranges;
  dictionary_generations = other222.dictionary_generations;
  table_generations = other222.table_generations;
  __isset = other222.__isset;
}
TPendingQuery& TPendingQuery::operator=(const TPendingQuery& other223) {
  id = other223.id;
  column_ranges = other223.column_ranges;
  dictionary_generations = other223.dictionary_generations;
  table_generations = other223.table_generations;
  __isset = other223.__isset;
  return *this;
}
void TPendingQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPendingQuery(";
  out << "id=" << to_string(id);
  out << ", " << "column_ranges=" << to_string(column_ranges);
  out << ", " << "dictionary_generations=" << to_string(dictionary_generations);
  out << ", " << "table_generations=" << to_string(table_generations);
  out << ")";
}


TVarLen::~TVarLen() throw() {
}


void TVarLen::__set_payload(const std::string& val) {
  this->payload = val;
}

void TVarLen::__set_is_null(const bool val) {
  this->is_null = val;
}
std::ostream& operator<<(std::ostream& out, const TVarLen& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TVarLen::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->payload);
          this->__isset.payload = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_null);
          this->__isset.is_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TVarLen::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TVarLen");

  xfer += oprot->writeFieldBegin("payload", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->payload);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_null", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TVarLen &a, TVarLen &b) {
  using ::std::swap;
  swap(a.payload, b.payload);
  swap(a.is_null, b.is_null);
  swap(a.__isset, b.__isset);
}

TVarLen::TVarLen(const TVarLen& other224) {
  payload = other224.payload;
  is_null = other224.is_null;
  __isset = other224.__isset;
}
TVarLen& TVarLen::operator=(const TVarLen& other225) {
  payload = other225.payload;
  is_null = other225.is_null;
  __isset = other225.__isset;
  return *this;
}
void TVarLen::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TVarLen(";
  out << "payload=" << to_string(payload);
  out << ", " << "is_null=" << to_string(is_null);
  out << ")";
}


TDataBlockPtr::~TDataBlockPtr() throw() {
}


void TDataBlockPtr::__set_fixed_len_data(const std::string& val) {
  this->fixed_len_data = val;
__isset.fixed_len_data = true;
}

void TDataBlockPtr::__set_var_len_data(const std::vector<TVarLen> & val) {
  this->var_len_data = val;
__isset.var_len_data = true;
}
std::ostream& operator<<(std::ostream& out, const TDataBlockPtr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDataBlockPtr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->fixed_len_data);
          this->__isset.fixed_len_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->var_len_data.clear();
            uint32_t _size226;
            ::apache::thrift::protocol::TType _etype229;
            xfer += iprot->readListBegin(_etype229, _size226);
            this->var_len_data.resize(_size226);
            uint32_t _i230;
            for (_i230 = 0; _i230 < _size226; ++_i230)
            {
              xfer += this->var_len_data[_i230].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.var_len_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDataBlockPtr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataBlockPtr");

  if (this->__isset.fixed_len_data) {
    xfer += oprot->writeFieldBegin("fixed_len_data", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->fixed_len_data);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.var_len_data) {
    xfer += oprot->writeFieldBegin("var_len_data", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->var_len_data.size()));
      std::vector<TVarLen> ::const_iterator _iter231;
      for (_iter231 = this->var_len_data.begin(); _iter231 != this->var_len_data.end(); ++_iter231)
      {
        xfer += (*_iter231).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDataBlockPtr &a, TDataBlockPtr &b) {
  using ::std::swap;
  swap(a.fixed_len_data, b.fixed_len_data);
  swap(a.var_len_data, b.var_len_data);
  swap(a.__isset, b.__isset);
}

TDataBlockPtr::TDataBlockPtr(const TDataBlockPtr& other232) {
  fixed_len_data = other232.fixed_len_data;
  var_len_data = other232.var_len_data;
  __isset = other232.__isset;
}
TDataBlockPtr& TDataBlockPtr::operator=(const TDataBlockPtr& other233) {
  fixed_len_data = other233.fixed_len_data;
  var_len_data = other233.var_len_data;
  __isset = other233.__isset;
  return *this;
}
void TDataBlockPtr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDataBlockPtr(";
  out << "fixed_len_data="; (__isset.fixed_len_data ? (out << to_string(fixed_len_data)) : (out << "<null>"));
  out << ", " << "var_len_data="; (__isset.var_len_data ? (out << to_string(var_len_data)) : (out << "<null>"));
  out << ")";
}


TInsertData::~TInsertData() throw() {
}


void TInsertData::__set_db_id(const int32_t val) {
  this->db_id = val;
}

void TInsertData::__set_table_id(const int32_t val) {
  this->table_id = val;
}

void TInsertData::__set_column_ids(const std::vector<int32_t> & val) {
  this->column_ids = val;
}

void TInsertData::__set_data(const std::vector<TDataBlockPtr> & val) {
  this->data = val;
}

void TInsertData::__set_num_rows(const int64_t val) {
  this->num_rows = val;
}
std::ostream& operator<<(std::ostream& out, const TInsertData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TInsertData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->db_id);
          this->__isset.db_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_ids.clear();
            uint32_t _size234;
            ::apache::thrift::protocol::TType _etype237;
            xfer += iprot->readListBegin(_etype237, _size234);
            this->column_ids.resize(_size234);
            uint32_t _i238;
            for (_i238 = 0; _i238 < _size234; ++_i238)
            {
              xfer += iprot->readI32(this->column_ids[_i238]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size239;
            ::apache::thrift::protocol::TType _etype242;
            xfer += iprot->readListBegin(_etype242, _size239);
            this->data.resize(_size239);
            uint32_t _i243;
            for (_i243 = 0; _i243 < _size239; ++_i243)
            {
              xfer += this->data[_i243].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_rows);
          this->__isset.num_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TInsertData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TInsertData");

  xfer += oprot->writeFieldBegin("db_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->db_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_ids", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->column_ids.size()));
    std::vector<int32_t> ::const_iterator _iter244;
    for (_iter244 = this->column_ids.begin(); _iter244 != this->column_ids.end(); ++_iter244)
    {
      xfer += oprot->writeI32((*_iter244));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->data.size()));
    std::vector<TDataBlockPtr> ::const_iterator _iter245;
    for (_iter245 = this->data.begin(); _iter245 != this->data.end(); ++_iter245)
    {
      xfer += (*_iter245).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_rows", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->num_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TInsertData &a, TInsertData &b) {
  using ::std::swap;
  swap(a.db_id, b.db_id);
  swap(a.table_id, b.table_id);
  swap(a.column_ids, b.column_ids);
  swap(a.data, b.data);
  swap(a.num_rows, b.num_rows);
  swap(a.__isset, b.__isset);
}

TInsertData::TInsertData(const TInsertData& other246) {
  db_id = other246.db_id;
  table_id = other246.table_id;
  column_ids = other246.column_ids;
  data = other246.data;
  num_rows = other246.num_rows;
  __isset = other246.__isset;
}
TInsertData& TInsertData::operator=(const TInsertData& other247) {
  db_id = other247.db_id;
  table_id = other247.table_id;
  column_ids = other247.column_ids;
  data = other247.data;
  num_rows = other247.num_rows;
  __isset = other247.__isset;
  return *this;
}
void TInsertData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TInsertData(";
  out << "db_id=" << to_string(db_id);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "column_ids=" << to_string(column_ids);
  out << ", " << "data=" << to_string(data);
  out << ", " << "num_rows=" << to_string(num_rows);
  out << ")";
}


TPendingRenderQuery::~TPendingRenderQuery() throw() {
}


void TPendingRenderQuery::__set_id(const TQueryId val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const TPendingRenderQuery& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPendingRenderQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPendingRenderQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPendingRenderQuery");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPendingRenderQuery &a, TPendingRenderQuery &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

TPendingRenderQuery::TPendingRenderQuery(const TPendingRenderQuery& other248) {
  id = other248.id;
  __isset = other248.__isset;
}
TPendingRenderQuery& TPendingRenderQuery::operator=(const TPendingRenderQuery& other249) {
  id = other249.id;
  __isset = other249.__isset;
  return *this;
}
void TPendingRenderQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPendingRenderQuery(";
  out << "id=" << to_string(id);
  out << ")";
}


TRenderParseResult::~TRenderParseResult() throw() {
}


void TRenderParseResult::__set_merge_type(const TMergeType::type val) {
  this->merge_type = val;
}

void TRenderParseResult::__set_node_id(const int32_t val) {
  this->node_id = val;
}

void TRenderParseResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TRenderParseResult::__set_render_time_ms(const int64_t val) {
  this->render_time_ms = val;
}

void TRenderParseResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderParseResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderParseResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast250;
          xfer += iprot->readI32(ecast250);
          this->merge_type = (TMergeType::type)ecast250;
          this->__isset.merge_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->render_time_ms);
          this->__isset.render_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderParseResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderParseResult");

  xfer += oprot->writeFieldBegin("merge_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->merge_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_time_ms", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->render_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderParseResult &a, TRenderParseResult &b) {
  using ::std::swap;
  swap(a.merge_type, b.merge_type);
  swap(a.node_id, b.node_id);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.render_time_ms, b.render_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.__isset, b.__isset);
}

TRenderParseResult::TRenderParseResult(const TRenderParseResult& other251) {
  merge_type = other251.merge_type;
  node_id = other251.node_id;
  execution_time_ms = other251.execution_time_ms;
  render_time_ms = other251.render_time_ms;
  total_time_ms = other251.total_time_ms;
  __isset = other251.__isset;
}
TRenderParseResult& TRenderParseResult::operator=(const TRenderParseResult& other252) {
  merge_type = other252.merge_type;
  node_id = other252.node_id;
  execution_time_ms = other252.execution_time_ms;
  render_time_ms = other252.render_time_ms;
  total_time_ms = other252.total_time_ms;
  __isset = other252.__isset;
  return *this;
}
void TRenderParseResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderParseResult(";
  out << "merge_type=" << to_string(merge_type);
  out << ", " << "node_id=" << to_string(node_id);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "render_time_ms=" << to_string(render_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ")";
}


TRawRenderPassDataResult::~TRawRenderPassDataResult() throw() {
}


void TRawRenderPassDataResult::__set_num_pixel_channels(const int32_t val) {
  this->num_pixel_channels = val;
}

void TRawRenderPassDataResult::__set_num_pixel_samples(const int32_t val) {
  this->num_pixel_samples = val;
}

void TRawRenderPassDataResult::__set_pixels(const std::string& val) {
  this->pixels = val;
}

void TRawRenderPassDataResult::__set_row_ids_A(const std::string& val) {
  this->row_ids_A = val;
}

void TRawRenderPassDataResult::__set_row_ids_B(const std::string& val) {
  this->row_ids_B = val;
}

void TRawRenderPassDataResult::__set_table_ids(const std::string& val) {
  this->table_ids = val;
}

void TRawRenderPassDataResult::__set_accum_data(const std::string& val) {
  this->accum_data = val;
}
std::ostream& operator<<(std::ostream& out, const TRawRenderPassDataResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRawRenderPassDataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_pixel_channels);
          this->__isset.num_pixel_channels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_pixel_samples);
          this->__isset.num_pixel_samples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pixels);
          this->__isset.pixels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row_ids_A);
          this->__isset.row_ids_A = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row_ids_B);
          this->__isset.row_ids_B = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->table_ids);
          this->__isset.table_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->accum_data);
          this->__isset.accum_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRawRenderPassDataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRawRenderPassDataResult");

  xfer += oprot->writeFieldBegin("num_pixel_channels", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num_pixel_channels);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_pixel_samples", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num_pixel_samples);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pixels", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->pixels);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_ids_A", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->row_ids_A);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_ids_B", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->row_ids_B);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_ids", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->table_ids);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("accum_data", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeBinary(this->accum_data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRawRenderPassDataResult &a, TRawRenderPassDataResult &b) {
  using ::std::swap;
  swap(a.num_pixel_channels, b.num_pixel_channels);
  swap(a.num_pixel_samples, b.num_pixel_samples);
  swap(a.pixels, b.pixels);
  swap(a.row_ids_A, b.row_ids_A);
  swap(a.row_ids_B, b.row_ids_B);
  swap(a.table_ids, b.table_ids);
  swap(a.accum_data, b.accum_data);
  swap(a.__isset, b.__isset);
}

TRawRenderPassDataResult::TRawRenderPassDataResult(const TRawRenderPassDataResult& other253) {
  num_pixel_channels = other253.num_pixel_channels;
  num_pixel_samples = other253.num_pixel_samples;
  pixels = other253.pixels;
  row_ids_A = other253.row_ids_A;
  row_ids_B = other253.row_ids_B;
  table_ids = other253.table_ids;
  accum_data = other253.accum_data;
  __isset = other253.__isset;
}
TRawRenderPassDataResult& TRawRenderPassDataResult::operator=(const TRawRenderPassDataResult& other254) {
  num_pixel_channels = other254.num_pixel_channels;
  num_pixel_samples = other254.num_pixel_samples;
  pixels = other254.pixels;
  row_ids_A = other254.row_ids_A;
  row_ids_B = other254.row_ids_B;
  table_ids = other254.table_ids;
  accum_data = other254.accum_data;
  __isset = other254.__isset;
  return *this;
}
void TRawRenderPassDataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRawRenderPassDataResult(";
  out << "num_pixel_channels=" << to_string(num_pixel_channels);
  out << ", " << "num_pixel_samples=" << to_string(num_pixel_samples);
  out << ", " << "pixels=" << to_string(pixels);
  out << ", " << "row_ids_A=" << to_string(row_ids_A);
  out << ", " << "row_ids_B=" << to_string(row_ids_B);
  out << ", " << "table_ids=" << to_string(table_ids);
  out << ", " << "accum_data=" << to_string(accum_data);
  out << ")";
}


TRawPixelData::~TRawPixelData() throw() {
}


void TRawPixelData::__set_width(const int32_t val) {
  this->width = val;
}

void TRawPixelData::__set_height(const int32_t val) {
  this->height = val;
}

void TRawPixelData::__set_render_pass_map(const TRenderPassMap& val) {
  this->render_pass_map = val;
}
std::ostream& operator<<(std::ostream& out, const TRawPixelData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRawPixelData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->width);
          this->__isset.width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->height);
          this->__isset.height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->render_pass_map.clear();
            uint32_t _size255;
            ::apache::thrift::protocol::TType _ktype256;
            ::apache::thrift::protocol::TType _vtype257;
            xfer += iprot->readMapBegin(_ktype256, _vtype257, _size255);
            uint32_t _i259;
            for (_i259 = 0; _i259 < _size255; ++_i259)
            {
              int32_t _key260;
              xfer += iprot->readI32(_key260);
              TRawRenderPassDataResult& _val261 = this->render_pass_map[_key260];
              xfer += _val261.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.render_pass_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRawPixelData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRawPixelData");

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_pass_map", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->render_pass_map.size()));
    std::map<int32_t, TRawRenderPassDataResult> ::const_iterator _iter262;
    for (_iter262 = this->render_pass_map.begin(); _iter262 != this->render_pass_map.end(); ++_iter262)
    {
      xfer += oprot->writeI32(_iter262->first);
      xfer += _iter262->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRawPixelData &a, TRawPixelData &b) {
  using ::std::swap;
  swap(a.width, b.width);
  swap(a.height, b.height);
  swap(a.render_pass_map, b.render_pass_map);
  swap(a.__isset, b.__isset);
}

TRawPixelData::TRawPixelData(const TRawPixelData& other263) {
  width = other263.width;
  height = other263.height;
  render_pass_map = other263.render_pass_map;
  __isset = other263.__isset;
}
TRawPixelData& TRawPixelData::operator=(const TRawPixelData& other264) {
  width = other264.width;
  height = other264.height;
  render_pass_map = other264.render_pass_map;
  __isset = other264.__isset;
  return *this;
}
void TRawPixelData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRawPixelData(";
  out << "width=" << to_string(width);
  out << ", " << "height=" << to_string(height);
  out << ", " << "render_pass_map=" << to_string(render_pass_map);
  out << ")";
}


TRenderDatum::~TRenderDatum() throw() {
}


void TRenderDatum::__set_type(const  ::TDatumType::type val) {
  this->type = val;
}

void TRenderDatum::__set_cnt(const int32_t val) {
  this->cnt = val;
}

void TRenderDatum::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderDatum& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderDatum::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast265;
          xfer += iprot->readI32(ecast265);
          this->type = ( ::TDatumType::type)ecast265;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cnt);
          this->__isset.cnt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderDatum::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderDatum");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cnt", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->cnt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderDatum &a, TRenderDatum &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.cnt, b.cnt);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TRenderDatum::TRenderDatum(const TRenderDatum& other266) {
  type = other266.type;
  cnt = other266.cnt;
  value = other266.value;
  __isset = other266.__isset;
}
TRenderDatum& TRenderDatum::operator=(const TRenderDatum& other267) {
  type = other267.type;
  cnt = other267.cnt;
  value = other267.value;
  __isset = other267.__isset;
  return *this;
}
void TRenderDatum::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderDatum(";
  out << "type=" << to_string(type);
  out << ", " << "cnt=" << to_string(cnt);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


TRenderStepResult::~TRenderStepResult() throw() {
}


void TRenderStepResult::__set_merge_data(const TRenderAggDataMap& val) {
  this->merge_data = val;
}

void TRenderStepResult::__set_raw_pixel_data(const TRawPixelData& val) {
  this->raw_pixel_data = val;
}

void TRenderStepResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TRenderStepResult::__set_render_time_ms(const int64_t val) {
  this->render_time_ms = val;
}

void TRenderStepResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderStepResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderStepResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->merge_data.clear();
            uint32_t _size268;
            ::apache::thrift::protocol::TType _ktype269;
            ::apache::thrift::protocol::TType _vtype270;
            xfer += iprot->readMapBegin(_ktype269, _vtype270, _size268);
            uint32_t _i272;
            for (_i272 = 0; _i272 < _size268; ++_i272)
            {
              std::string _key273;
              xfer += iprot->readString(_key273);
              std::map<std::string, std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > > & _val274 = this->merge_data[_key273];
              {
                _val274.clear();
                uint32_t _size275;
                ::apache::thrift::protocol::TType _ktype276;
                ::apache::thrift::protocol::TType _vtype277;
                xfer += iprot->readMapBegin(_ktype276, _vtype277, _size275);
                uint32_t _i279;
                for (_i279 = 0; _i279 < _size275; ++_i279)
                {
                  std::string _key280;
                  xfer += iprot->readString(_key280);
                  std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > & _val281 = _val274[_key280];
                  {
                    _val281.clear();
                    uint32_t _size282;
                    ::apache::thrift::protocol::TType _ktype283;
                    ::apache::thrift::protocol::TType _vtype284;
                    xfer += iprot->readMapBegin(_ktype283, _vtype284, _size282);
                    uint32_t _i286;
                    for (_i286 = 0; _i286 < _size282; ++_i286)
                    {
                      std::string _key287;
                      xfer += iprot->readString(_key287);
                      std::map<std::string, std::vector<TRenderDatum> > & _val288 = _val281[_key287];
                      {
                        _val288.clear();
                        uint32_t _size289;
                        ::apache::thrift::protocol::TType _ktype290;
                        ::apache::thrift::protocol::TType _vtype291;
                        xfer += iprot->readMapBegin(_ktype290, _vtype291, _size289);
                        uint32_t _i293;
                        for (_i293 = 0; _i293 < _size289; ++_i293)
                        {
                          std::string _key294;
                          xfer += iprot->readString(_key294);
                          std::vector<TRenderDatum> & _val295 = _val288[_key294];
                          {
                            _val295.clear();
                            uint32_t _size296;
                            ::apache::thrift::protocol::TType _etype299;
                            xfer += iprot->readListBegin(_etype299, _size296);
                            _val295.resize(_size296);
                            uint32_t _i300;
                            for (_i300 = 0; _i300 < _size296; ++_i300)
                            {
                              xfer += _val295[_i300].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                          }
                        }
                        xfer += iprot->readMapEnd();
                      }
                    }
                    xfer += iprot->readMapEnd();
                  }
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.merge_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->raw_pixel_data.read(iprot);
          this->__isset.raw_pixel_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->render_time_ms);
          this->__isset.render_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderStepResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderStepResult");

  xfer += oprot->writeFieldBegin("merge_data", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->merge_data.size()));
    std::map<std::string, std::map<std::string, std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > > > ::const_iterator _iter301;
    for (_iter301 = this->merge_data.begin(); _iter301 != this->merge_data.end(); ++_iter301)
    {
      xfer += oprot->writeString(_iter301->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(_iter301->second.size()));
        std::map<std::string, std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > > ::const_iterator _iter302;
        for (_iter302 = _iter301->second.begin(); _iter302 != _iter301->second.end(); ++_iter302)
        {
          xfer += oprot->writeString(_iter302->first);
          {
            xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(_iter302->second.size()));
            std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > ::const_iterator _iter303;
            for (_iter303 = _iter302->second.begin(); _iter303 != _iter302->second.end(); ++_iter303)
            {
              xfer += oprot->writeString(_iter303->first);
              {
                xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(_iter303->second.size()));
                std::map<std::string, std::vector<TRenderDatum> > ::const_iterator _iter304;
                for (_iter304 = _iter303->second.begin(); _iter304 != _iter303->second.end(); ++_iter304)
                {
                  xfer += oprot->writeString(_iter304->first);
                  {
                    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter304->second.size()));
                    std::vector<TRenderDatum> ::const_iterator _iter305;
                    for (_iter305 = _iter304->second.begin(); _iter305 != _iter304->second.end(); ++_iter305)
                    {
                      xfer += (*_iter305).write(oprot);
                    }
                    xfer += oprot->writeListEnd();
                  }
                }
                xfer += oprot->writeMapEnd();
              }
            }
            xfer += oprot->writeMapEnd();
          }
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("raw_pixel_data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->raw_pixel_data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_time_ms", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->render_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderStepResult &a, TRenderStepResult &b) {
  using ::std::swap;
  swap(a.merge_data, b.merge_data);
  swap(a.raw_pixel_data, b.raw_pixel_data);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.render_time_ms, b.render_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.__isset, b.__isset);
}

TRenderStepResult::TRenderStepResult(const TRenderStepResult& other306) {
  merge_data = other306.merge_data;
  raw_pixel_data = other306.raw_pixel_data;
  execution_time_ms = other306.execution_time_ms;
  render_time_ms = other306.render_time_ms;
  total_time_ms = other306.total_time_ms;
  __isset = other306.__isset;
}
TRenderStepResult& TRenderStepResult::operator=(const TRenderStepResult& other307) {
  merge_data = other307.merge_data;
  raw_pixel_data = other307.raw_pixel_data;
  execution_time_ms = other307.execution_time_ms;
  render_time_ms = other307.render_time_ms;
  total_time_ms = other307.total_time_ms;
  __isset = other307.__isset;
  return *this;
}
void TRenderStepResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderStepResult(";
  out << "merge_data=" << to_string(merge_data);
  out << ", " << "raw_pixel_data=" << to_string(raw_pixel_data);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "render_time_ms=" << to_string(render_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ")";
}


TDatabasePermissions::~TDatabasePermissions() throw() {
}


void TDatabasePermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TDatabasePermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}

void TDatabasePermissions::__set_view_sql_editor_(const bool val) {
  this->view_sql_editor_ = val;
}

void TDatabasePermissions::__set_access_(const bool val) {
  this->access_ = val;
}
std::ostream& operator<<(std::ostream& out, const TDatabasePermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDatabasePermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->view_sql_editor_);
          this->__isset.view_sql_editor_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->access_);
          this->__isset.access_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDatabasePermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDatabasePermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_sql_editor_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->view_sql_editor_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("access_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->access_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDatabasePermissions &a, TDatabasePermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.delete_, b.delete_);
  swap(a.view_sql_editor_, b.view_sql_editor_);
  swap(a.access_, b.access_);
  swap(a.__isset, b.__isset);
}

TDatabasePermissions::TDatabasePermissions(const TDatabasePermissions& other308) {
  create_ = other308.create_;
  delete_ = other308.delete_;
  view_sql_editor_ = other308.view_sql_editor_;
  access_ = other308.access_;
  __isset = other308.__isset;
}
TDatabasePermissions& TDatabasePermissions::operator=(const TDatabasePermissions& other309) {
  create_ = other309.create_;
  delete_ = other309.delete_;
  view_sql_editor_ = other309.view_sql_editor_;
  access_ = other309.access_;
  __isset = other309.__isset;
  return *this;
}
void TDatabasePermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDatabasePermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ", " << "view_sql_editor_=" << to_string(view_sql_editor_);
  out << ", " << "access_=" << to_string(access_);
  out << ")";
}


TTablePermissions::~TTablePermissions() throw() {
}


void TTablePermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TTablePermissions::__set_drop_(const bool val) {
  this->drop_ = val;
}

void TTablePermissions::__set_select_(const bool val) {
  this->select_ = val;
}

void TTablePermissions::__set_insert_(const bool val) {
  this->insert_ = val;
}

void TTablePermissions::__set_update_(const bool val) {
  this->update_ = val;
}

void TTablePermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}

void TTablePermissions::__set_truncate_(const bool val) {
  this->truncate_ = val;
}

void TTablePermissions::__set_alter_(const bool val) {
  this->alter_ = val;
}
std::ostream& operator<<(std::ostream& out, const TTablePermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTablePermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->drop_);
          this->__isset.drop_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->select_);
          this->__isset.select_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->insert_);
          this->__isset.insert_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->update_);
          this->__isset.update_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->truncate_);
          this->__isset.truncate_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->alter_);
          this->__isset.alter_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTablePermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTablePermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("drop_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->drop_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("select_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->select_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("insert_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->insert_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->update_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("truncate_", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->truncate_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("alter_", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->alter_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTablePermissions &a, TTablePermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.drop_, b.drop_);
  swap(a.select_, b.select_);
  swap(a.insert_, b.insert_);
  swap(a.update_, b.update_);
  swap(a.delete_, b.delete_);
  swap(a.truncate_, b.truncate_);
  swap(a.alter_, b.alter_);
  swap(a.__isset, b.__isset);
}

TTablePermissions::TTablePermissions(const TTablePermissions& other310) {
  create_ = other310.create_;
  drop_ = other310.drop_;
  select_ = other310.select_;
  insert_ = other310.insert_;
  update_ = other310.update_;
  delete_ = other310.delete_;
  truncate_ = other310.truncate_;
  alter_ = other310.alter_;
  __isset = other310.__isset;
}
TTablePermissions& TTablePermissions::operator=(const TTablePermissions& other311) {
  create_ = other311.create_;
  drop_ = other311.drop_;
  select_ = other311.select_;
  insert_ = other311.insert_;
  update_ = other311.update_;
  delete_ = other311.delete_;
  truncate_ = other311.truncate_;
  alter_ = other311.alter_;
  __isset = other311.__isset;
  return *this;
}
void TTablePermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTablePermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "drop_=" << to_string(drop_);
  out << ", " << "select_=" << to_string(select_);
  out << ", " << "insert_=" << to_string(insert_);
  out << ", " << "update_=" << to_string(update_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ", " << "truncate_=" << to_string(truncate_);
  out << ", " << "alter_=" << to_string(alter_);
  out << ")";
}


TDashboardPermissions::~TDashboardPermissions() throw() {
}


void TDashboardPermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TDashboardPermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}

void TDashboardPermissions::__set_view_(const bool val) {
  this->view_ = val;
}

void TDashboardPermissions::__set_edit_(const bool val) {
  this->edit_ = val;
}
std::ostream& operator<<(std::ostream& out, const TDashboardPermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDashboardPermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->view_);
          this->__isset.view_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->edit_);
          this->__isset.edit_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDashboardPermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDashboardPermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->view_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("edit_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->edit_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDashboardPermissions &a, TDashboardPermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.delete_, b.delete_);
  swap(a.view_, b.view_);
  swap(a.edit_, b.edit_);
  swap(a.__isset, b.__isset);
}

TDashboardPermissions::TDashboardPermissions(const TDashboardPermissions& other312) {
  create_ = other312.create_;
  delete_ = other312.delete_;
  view_ = other312.view_;
  edit_ = other312.edit_;
  __isset = other312.__isset;
}
TDashboardPermissions& TDashboardPermissions::operator=(const TDashboardPermissions& other313) {
  create_ = other313.create_;
  delete_ = other313.delete_;
  view_ = other313.view_;
  edit_ = other313.edit_;
  __isset = other313.__isset;
  return *this;
}
void TDashboardPermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDashboardPermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ", " << "view_=" << to_string(view_);
  out << ", " << "edit_=" << to_string(edit_);
  out << ")";
}


TViewPermissions::~TViewPermissions() throw() {
}


void TViewPermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TViewPermissions::__set_drop_(const bool val) {
  this->drop_ = val;
}

void TViewPermissions::__set_select_(const bool val) {
  this->select_ = val;
}

void TViewPermissions::__set_insert_(const bool val) {
  this->insert_ = val;
}

void TViewPermissions::__set_update_(const bool val) {
  this->update_ = val;
}

void TViewPermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}
std::ostream& operator<<(std::ostream& out, const TViewPermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TViewPermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->drop_);
          this->__isset.drop_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->select_);
          this->__isset.select_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->insert_);
          this->__isset.insert_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->update_);
          this->__isset.update_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TViewPermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TViewPermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("drop_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->drop_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("select_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->select_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("insert_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->insert_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->update_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TViewPermissions &a, TViewPermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.drop_, b.drop_);
  swap(a.select_, b.select_);
  swap(a.insert_, b.insert_);
  swap(a.update_, b.update_);
  swap(a.delete_, b.delete_);
  swap(a.__isset, b.__isset);
}

TViewPermissions::TViewPermissions(const TViewPermissions& other314) {
  create_ = other314.create_;
  drop_ = other314.drop_;
  select_ = other314.select_;
  insert_ = other314.insert_;
  update_ = other314.update_;
  delete_ = other314.delete_;
  __isset = other314.__isset;
}
TViewPermissions& TViewPermissions::operator=(const TViewPermissions& other315) {
  create_ = other315.create_;
  drop_ = other315.drop_;
  select_ = other315.select_;
  insert_ = other315.insert_;
  update_ = other315.update_;
  delete_ = other315.delete_;
  __isset = other315.__isset;
  return *this;
}
void TViewPermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TViewPermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "drop_=" << to_string(drop_);
  out << ", " << "select_=" << to_string(select_);
  out << ", " << "insert_=" << to_string(insert_);
  out << ", " << "update_=" << to_string(update_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ")";
}


TDBObjectPermissions::~TDBObjectPermissions() throw() {
}


void TDBObjectPermissions::__set_database_permissions_(const TDatabasePermissions& val) {
  this->database_permissions_ = val;
__isset.database_permissions_ = true;
}

void TDBObjectPermissions::__set_table_permissions_(const TTablePermissions& val) {
  this->table_permissions_ = val;
__isset.table_permissions_ = true;
}

void TDBObjectPermissions::__set_dashboard_permissions_(const TDashboardPermissions& val) {
  this->dashboard_permissions_ = val;
__isset.dashboard_permissions_ = true;
}

void TDBObjectPermissions::__set_view_permissions_(const TViewPermissions& val) {
  this->view_permissions_ = val;
__isset.view_permissions_ = true;
}
std::ostream& operator<<(std::ostream& out, const TDBObjectPermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDBObjectPermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->database_permissions_.read(iprot);
          this->__isset.database_permissions_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_permissions_.read(iprot);
          this->__isset.table_permissions_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dashboard_permissions_.read(iprot);
          this->__isset.dashboard_permissions_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->view_permissions_.read(iprot);
          this->__isset.view_permissions_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDBObjectPermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDBObjectPermissions");

  if (this->__isset.database_permissions_) {
    xfer += oprot->writeFieldBegin("database_permissions_", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->database_permissions_.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_permissions_) {
    xfer += oprot->writeFieldBegin("table_permissions_", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->table_permissions_.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dashboard_permissions_) {
    xfer += oprot->writeFieldBegin("dashboard_permissions_", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->dashboard_permissions_.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.view_permissions_) {
    xfer += oprot->writeFieldBegin("view_permissions_", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->view_permissions_.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDBObjectPermissions &a, TDBObjectPermissions &b) {
  using ::std::swap;
  swap(a.database_permissions_, b.database_permissions_);
  swap(a.table_permissions_, b.table_permissions_);
  swap(a.dashboard_permissions_, b.dashboard_permissions_);
  swap(a.view_permissions_, b.view_permissions_);
  swap(a.__isset, b.__isset);
}

TDBObjectPermissions::TDBObjectPermissions(const TDBObjectPermissions& other316) {
  database_permissions_ = other316.database_permissions_;
  table_permissions_ = other316.table_permissions_;
  dashboard_permissions_ = other316.dashboard_permissions_;
  view_permissions_ = other316.view_permissions_;
  __isset = other316.__isset;
}
TDBObjectPermissions& TDBObjectPermissions::operator=(const TDBObjectPermissions& other317) {
  database_permissions_ = other317.database_permissions_;
  table_permissions_ = other317.table_permissions_;
  dashboard_permissions_ = other317.dashboard_permissions_;
  view_permissions_ = other317.view_permissions_;
  __isset = other317.__isset;
  return *this;
}
void TDBObjectPermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDBObjectPermissions(";
  out << "database_permissions_="; (__isset.database_permissions_ ? (out << to_string(database_permissions_)) : (out << "<null>"));
  out << ", " << "table_permissions_="; (__isset.table_permissions_ ? (out << to_string(table_permissions_)) : (out << "<null>"));
  out << ", " << "dashboard_permissions_="; (__isset.dashboard_permissions_ ? (out << to_string(dashboard_permissions_)) : (out << "<null>"));
  out << ", " << "view_permissions_="; (__isset.view_permissions_ ? (out << to_string(view_permissions_)) : (out << "<null>"));
  out << ")";
}


TDBObject::~TDBObject() throw() {
}


void TDBObject::__set_objectName(const std::string& val) {
  this->objectName = val;
}

void TDBObject::__set_objectType(const TDBObjectType::type val) {
  this->objectType = val;
}

void TDBObject::__set_privs(const std::vector<bool> & val) {
  this->privs = val;
}

void TDBObject::__set_grantee(const std::string& val) {
  this->grantee = val;
}

void TDBObject::__set_privilegeObjectType(const TDBObjectType::type val) {
  this->privilegeObjectType = val;
}
std::ostream& operator<<(std::ostream& out, const TDBObject& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDBObject::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->objectName);
          this->__isset.objectName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast318;
          xfer += iprot->readI32(ecast318);
          this->objectType = (TDBObjectType::type)ecast318;
          this->__isset.objectType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->privs.clear();
            uint32_t _size319;
            ::apache::thrift::protocol::TType _etype322;
            xfer += iprot->readListBegin(_etype322, _size319);
            this->privs.resize(_size319);
            uint32_t _i323;
            for (_i323 = 0; _i323 < _size319; ++_i323)
            {
              xfer += iprot->readBool(this->privs[_i323]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.privs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->grantee);
          this->__isset.grantee = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast324;
          xfer += iprot->readI32(ecast324);
          this->privilegeObjectType = (TDBObjectType::type)ecast324;
          this->__isset.privilegeObjectType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDBObject::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDBObject");

  xfer += oprot->writeFieldBegin("objectName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->objectName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("objectType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->objectType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("privs", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->privs.size()));
    std::vector<bool> ::const_iterator _iter325;
    for (_iter325 = this->privs.begin(); _iter325 != this->privs.end(); ++_iter325)
    {
      xfer += oprot->writeBool((*_iter325));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantee", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->grantee);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("privilegeObjectType", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->privilegeObjectType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDBObject &a, TDBObject &b) {
  using ::std::swap;
  swap(a.objectName, b.objectName);
  swap(a.objectType, b.objectType);
  swap(a.privs, b.privs);
  swap(a.grantee, b.grantee);
  swap(a.privilegeObjectType, b.privilegeObjectType);
  swap(a.__isset, b.__isset);
}

TDBObject::TDBObject(const TDBObject& other326) {
  objectName = other326.objectName;
  objectType = other326.objectType;
  privs = other326.privs;
  grantee = other326.grantee;
  privilegeObjectType = other326.privilegeObjectType;
  __isset = other326.__isset;
}
TDBObject& TDBObject::operator=(const TDBObject& other327) {
  objectName = other327.objectName;
  objectType = other327.objectType;
  privs = other327.privs;
  grantee = other327.grantee;
  privilegeObjectType = other327.privilegeObjectType;
  __isset = other327.__isset;
  return *this;
}
void TDBObject::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDBObject(";
  out << "objectName=" << to_string(objectName);
  out << ", " << "objectType=" << to_string(objectType);
  out << ", " << "privs=" << to_string(privs);
  out << ", " << "grantee=" << to_string(grantee);
  out << ", " << "privilegeObjectType=" << to_string(privilegeObjectType);
  out << ")";
}


TDashboardGrantees::~TDashboardGrantees() throw() {
}


void TDashboardGrantees::__set_name(const std::string& val) {
  this->name = val;
}

void TDashboardGrantees::__set_is_user(const bool val) {
  this->is_user = val;
}

void TDashboardGrantees::__set_permissions(const TDashboardPermissions& val) {
  this->permissions = val;
}
std::ostream& operator<<(std::ostream& out, const TDashboardGrantees& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDashboardGrantees::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_user);
          this->__isset.is_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->permissions.read(iprot);
          this->__isset.permissions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDashboardGrantees::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDashboardGrantees");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_user", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("permissions", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->permissions.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDashboardGrantees &a, TDashboardGrantees &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.is_user, b.is_user);
  swap(a.permissions, b.permissions);
  swap(a.__isset, b.__isset);
}

TDashboardGrantees::TDashboardGrantees(const TDashboardGrantees& other328) {
  name = other328.name;
  is_user = other328.is_user;
  permissions = other328.permissions;
  __isset = other328.__isset;
}
TDashboardGrantees& TDashboardGrantees::operator=(const TDashboardGrantees& other329) {
  name = other329.name;
  is_user = other329.is_user;
  permissions = other329.permissions;
  __isset = other329.__isset;
  return *this;
}
void TDashboardGrantees::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDashboardGrantees(";
  out << "name=" << to_string(name);
  out << ", " << "is_user=" << to_string(is_user);
  out << ", " << "permissions=" << to_string(permissions);
  out << ")";
}


TLicenseInfo::~TLicenseInfo() throw() {
}


void TLicenseInfo::__set_claims(const std::vector<std::string> & val) {
  this->claims = val;
}
std::ostream& operator<<(std::ostream& out, const TLicenseInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TLicenseInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->claims.clear();
            uint32_t _size330;
            ::apache::thrift::protocol::TType _etype333;
            xfer += iprot->readListBegin(_etype333, _size330);
            this->claims.resize(_size330);
            uint32_t _i334;
            for (_i334 = 0; _i334 < _size330; ++_i334)
            {
              xfer += iprot->readString(this->claims[_i334]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.claims = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TLicenseInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLicenseInfo");

  xfer += oprot->writeFieldBegin("claims", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->claims.size()));
    std::vector<std::string> ::const_iterator _iter335;
    for (_iter335 = this->claims.begin(); _iter335 != this->claims.end(); ++_iter335)
    {
      xfer += oprot->writeString((*_iter335));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLicenseInfo &a, TLicenseInfo &b) {
  using ::std::swap;
  swap(a.claims, b.claims);
  swap(a.__isset, b.__isset);
}

TLicenseInfo::TLicenseInfo(const TLicenseInfo& other336) {
  claims = other336.claims;
  __isset = other336.__isset;
}
TLicenseInfo& TLicenseInfo::operator=(const TLicenseInfo& other337) {
  claims = other337.claims;
  __isset = other337.__isset;
  return *this;
}
void TLicenseInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLicenseInfo(";
  out << "claims=" << to_string(claims);
  out << ")";
}


TSessionInfo::~TSessionInfo() throw() {
}


void TSessionInfo::__set_user(const std::string& val) {
  this->user = val;
}

void TSessionInfo::__set_database(const std::string& val) {
  this->database = val;
}

void TSessionInfo::__set_start_time(const int64_t val) {
  this->start_time = val;
}

void TSessionInfo::__set_is_super(const bool val) {
  this->is_super = val;
}
std::ostream& operator<<(std::ostream& out, const TSessionInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSessionInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->database);
          this->__isset.database = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_time);
          this->__isset.start_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_super);
          this->__isset.is_super = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TSessionInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSessionInfo");

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("database", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->database);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_time", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->start_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_super", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_super);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSessionInfo &a, TSessionInfo &b) {
  using ::std::swap;
  swap(a.user, b.user);
  swap(a.database, b.database);
  swap(a.start_time, b.start_time);
  swap(a.is_super, b.is_super);
  swap(a.__isset, b.__isset);
}

TSessionInfo::TSessionInfo(const TSessionInfo& other338) {
  user = other338.user;
  database = other338.database;
  start_time = other338.start_time;
  is_super = other338.is_super;
  __isset = other338.__isset;
}
TSessionInfo& TSessionInfo::operator=(const TSessionInfo& other339) {
  user = other339.user;
  database = other339.database;
  start_time = other339.start_time;
  is_super = other339.is_super;
  __isset = other339.__isset;
  return *this;
}
void TSessionInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSessionInfo(";
  out << "user=" << to_string(user);
  out << ", " << "database=" << to_string(database);
  out << ", " << "start_time=" << to_string(start_time);
  out << ", " << "is_super=" << to_string(is_super);
  out << ")";
}


TGeoFileLayerInfo::~TGeoFileLayerInfo() throw() {
}


void TGeoFileLayerInfo::__set_name(const std::string& val) {
  this->name = val;
}

void TGeoFileLayerInfo::__set_contents(const TGeoFileLayerContents::type val) {
  this->contents = val;
}
std::ostream& operator<<(std::ostream& out, const TGeoFileLayerInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGeoFileLayerInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast340;
          xfer += iprot->readI32(ecast340);
          this->contents = (TGeoFileLayerContents::type)ecast340;
          this->__isset.contents = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGeoFileLayerInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGeoFileLayerInfo");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contents", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->contents);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGeoFileLayerInfo &a, TGeoFileLayerInfo &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.contents, b.contents);
  swap(a.__isset, b.__isset);
}

TGeoFileLayerInfo::TGeoFileLayerInfo(const TGeoFileLayerInfo& other341) {
  name = other341.name;
  contents = other341.contents;
  __isset = other341.__isset;
}
TGeoFileLayerInfo& TGeoFileLayerInfo::operator=(const TGeoFileLayerInfo& other342) {
  name = other342.name;
  contents = other342.contents;
  __isset = other342.__isset;
  return *this;
}
void TGeoFileLayerInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGeoFileLayerInfo(";
  out << "name=" << to_string(name);
  out << ", " << "contents=" << to_string(contents);
  out << ")";
}


