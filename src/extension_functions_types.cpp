/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "extension_functions_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kTExtArgumentTypeValues[] = {
  TExtArgumentType::Int8,
  TExtArgumentType::Int16,
  TExtArgumentType::Int32,
  TExtArgumentType::Int64,
  TExtArgumentType::Float,
  TExtArgumentType::Double,
  TExtArgumentType::Void,
  TExtArgumentType::PInt8,
  TExtArgumentType::PInt16,
  TExtArgumentType::PInt32,
  TExtArgumentType::PInt64,
  TExtArgumentType::PFloat,
  TExtArgumentType::PDouble,
  TExtArgumentType::Bool,
  TExtArgumentType::ArrayInt8,
  TExtArgumentType::ArrayInt16,
  TExtArgumentType::ArrayInt32,
  TExtArgumentType::ArrayInt64,
  TExtArgumentType::ArrayFloat,
  TExtArgumentType::ArrayDouble,
  TExtArgumentType::GeoPoint,
  TExtArgumentType::Cursor
};
const char* _kTExtArgumentTypeNames[] = {
  "Int8",
  "Int16",
  "Int32",
  "Int64",
  "Float",
  "Double",
  "Void",
  "PInt8",
  "PInt16",
  "PInt32",
  "PInt64",
  "PFloat",
  "PDouble",
  "Bool",
  "ArrayInt8",
  "ArrayInt16",
  "ArrayInt32",
  "ArrayInt64",
  "ArrayFloat",
  "ArrayDouble",
  "GeoPoint",
  "Cursor"
};
const std::map<int, const char*> _TExtArgumentType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(22, _kTExtArgumentTypeValues, _kTExtArgumentTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TExtArgumentType::type& val) {
  std::map<int, const char*>::const_iterator it = _TExtArgumentType_VALUES_TO_NAMES.find(val);
  if (it != _TExtArgumentType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTOutputBufferSizeTypeValues[] = {
  TOutputBufferSizeType::kUserSpecifiedConstantParameter,
  TOutputBufferSizeType::kUserSpecifiedRowMultiplier,
  TOutputBufferSizeType::kConstant
};
const char* _kTOutputBufferSizeTypeNames[] = {
  "kUserSpecifiedConstantParameter",
  "kUserSpecifiedRowMultiplier",
  "kConstant"
};
const std::map<int, const char*> _TOutputBufferSizeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTOutputBufferSizeTypeValues, _kTOutputBufferSizeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TOutputBufferSizeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TOutputBufferSizeType_VALUES_TO_NAMES.find(val);
  if (it != _TOutputBufferSizeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


TUserDefinedFunction::~TUserDefinedFunction() throw() {
}


void TUserDefinedFunction::__set_name(const std::string& val) {
  this->name = val;
}

void TUserDefinedFunction::__set_argTypes(const std::vector<TExtArgumentType::type> & val) {
  this->argTypes = val;
}

void TUserDefinedFunction::__set_retType(const TExtArgumentType::type val) {
  this->retType = val;
}
std::ostream& operator<<(std::ostream& out, const TUserDefinedFunction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TUserDefinedFunction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->argTypes.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->argTypes.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              int32_t ecast5;
              xfer += iprot->readI32(ecast5);
              this->argTypes[_i4] = (TExtArgumentType::type)ecast5;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.argTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast6;
          xfer += iprot->readI32(ecast6);
          this->retType = (TExtArgumentType::type)ecast6;
          this->__isset.retType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TUserDefinedFunction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUserDefinedFunction");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("argTypes", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->argTypes.size()));
    std::vector<TExtArgumentType::type> ::const_iterator _iter7;
    for (_iter7 = this->argTypes.begin(); _iter7 != this->argTypes.end(); ++_iter7)
    {
      xfer += oprot->writeI32((int32_t)(*_iter7));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("retType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->retType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUserDefinedFunction &a, TUserDefinedFunction &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.argTypes, b.argTypes);
  swap(a.retType, b.retType);
  swap(a.__isset, b.__isset);
}

TUserDefinedFunction::TUserDefinedFunction(const TUserDefinedFunction& other8) {
  name = other8.name;
  argTypes = other8.argTypes;
  retType = other8.retType;
  __isset = other8.__isset;
}
TUserDefinedFunction& TUserDefinedFunction::operator=(const TUserDefinedFunction& other9) {
  name = other9.name;
  argTypes = other9.argTypes;
  retType = other9.retType;
  __isset = other9.__isset;
  return *this;
}
void TUserDefinedFunction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUserDefinedFunction(";
  out << "name=" << to_string(name);
  out << ", " << "argTypes=" << to_string(argTypes);
  out << ", " << "retType=" << to_string(retType);
  out << ")";
}


TUserDefinedTableFunction::~TUserDefinedTableFunction() throw() {
}


void TUserDefinedTableFunction::__set_name(const std::string& val) {
  this->name = val;
}

void TUserDefinedTableFunction::__set_sizerType(const TOutputBufferSizeType::type val) {
  this->sizerType = val;
}

void TUserDefinedTableFunction::__set_sizerArgPos(const int32_t val) {
  this->sizerArgPos = val;
}

void TUserDefinedTableFunction::__set_inputArgTypes(const std::vector<TExtArgumentType::type> & val) {
  this->inputArgTypes = val;
}

void TUserDefinedTableFunction::__set_outputArgTypes(const std::vector<TExtArgumentType::type> & val) {
  this->outputArgTypes = val;
}

void TUserDefinedTableFunction::__set_sqlArgTypes(const std::vector<TExtArgumentType::type> & val) {
  this->sqlArgTypes = val;
}
std::ostream& operator<<(std::ostream& out, const TUserDefinedTableFunction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TUserDefinedTableFunction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->sizerType = (TOutputBufferSizeType::type)ecast10;
          this->__isset.sizerType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sizerArgPos);
          this->__isset.sizerArgPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->inputArgTypes.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size11);
            this->inputArgTypes.resize(_size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              int32_t ecast16;
              xfer += iprot->readI32(ecast16);
              this->inputArgTypes[_i15] = (TExtArgumentType::type)ecast16;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.inputArgTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->outputArgTypes.clear();
            uint32_t _size17;
            ::apache::thrift::protocol::TType _etype20;
            xfer += iprot->readListBegin(_etype20, _size17);
            this->outputArgTypes.resize(_size17);
            uint32_t _i21;
            for (_i21 = 0; _i21 < _size17; ++_i21)
            {
              int32_t ecast22;
              xfer += iprot->readI32(ecast22);
              this->outputArgTypes[_i21] = (TExtArgumentType::type)ecast22;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.outputArgTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sqlArgTypes.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->sqlArgTypes.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              int32_t ecast28;
              xfer += iprot->readI32(ecast28);
              this->sqlArgTypes[_i27] = (TExtArgumentType::type)ecast28;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sqlArgTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TUserDefinedTableFunction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUserDefinedTableFunction");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sizerType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->sizerType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sizerArgPos", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->sizerArgPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inputArgTypes", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->inputArgTypes.size()));
    std::vector<TExtArgumentType::type> ::const_iterator _iter29;
    for (_iter29 = this->inputArgTypes.begin(); _iter29 != this->inputArgTypes.end(); ++_iter29)
    {
      xfer += oprot->writeI32((int32_t)(*_iter29));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputArgTypes", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->outputArgTypes.size()));
    std::vector<TExtArgumentType::type> ::const_iterator _iter30;
    for (_iter30 = this->outputArgTypes.begin(); _iter30 != this->outputArgTypes.end(); ++_iter30)
    {
      xfer += oprot->writeI32((int32_t)(*_iter30));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sqlArgTypes", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->sqlArgTypes.size()));
    std::vector<TExtArgumentType::type> ::const_iterator _iter31;
    for (_iter31 = this->sqlArgTypes.begin(); _iter31 != this->sqlArgTypes.end(); ++_iter31)
    {
      xfer += oprot->writeI32((int32_t)(*_iter31));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUserDefinedTableFunction &a, TUserDefinedTableFunction &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.sizerType, b.sizerType);
  swap(a.sizerArgPos, b.sizerArgPos);
  swap(a.inputArgTypes, b.inputArgTypes);
  swap(a.outputArgTypes, b.outputArgTypes);
  swap(a.sqlArgTypes, b.sqlArgTypes);
  swap(a.__isset, b.__isset);
}

TUserDefinedTableFunction::TUserDefinedTableFunction(const TUserDefinedTableFunction& other32) {
  name = other32.name;
  sizerType = other32.sizerType;
  sizerArgPos = other32.sizerArgPos;
  inputArgTypes = other32.inputArgTypes;
  outputArgTypes = other32.outputArgTypes;
  sqlArgTypes = other32.sqlArgTypes;
  __isset = other32.__isset;
}
TUserDefinedTableFunction& TUserDefinedTableFunction::operator=(const TUserDefinedTableFunction& other33) {
  name = other33.name;
  sizerType = other33.sizerType;
  sizerArgPos = other33.sizerArgPos;
  inputArgTypes = other33.inputArgTypes;
  outputArgTypes = other33.outputArgTypes;
  sqlArgTypes = other33.sqlArgTypes;
  __isset = other33.__isset;
  return *this;
}
void TUserDefinedTableFunction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUserDefinedTableFunction(";
  out << "name=" << to_string(name);
  out << ", " << "sizerType=" << to_string(sizerType);
  out << ", " << "sizerArgPos=" << to_string(sizerArgPos);
  out << ", " << "inputArgTypes=" << to_string(inputArgTypes);
  out << ", " << "outputArgTypes=" << to_string(outputArgTypes);
  out << ", " << "sqlArgTypes=" << to_string(sqlArgTypes);
  out << ")";
}


